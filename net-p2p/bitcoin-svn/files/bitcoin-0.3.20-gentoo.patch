diff -Naur bitcoin-0.3.20.orig/src/cryptopp/config.h bitcoin-0.3.20/src/cryptopp/config.h
--- bitcoin-0.3.20.orig/src/cryptopp/config.h	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/config.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,462 +0,0 @@
-#ifndef CRYPTOPP_CONFIG_H
-#define CRYPTOPP_CONFIG_H
-
-//// Bitcoin: disable SSE2 on 32-bit
-#if !defined(_M_X64) && !defined(__x86_64__)
-#define CRYPTOPP_DISABLE_SSE2  1
-#endif
-//////////// end of Bitcoin changes
-
-
-// ***************** Important Settings ********************
-
-// define this if running on a big-endian CPU
-#if !defined(IS_LITTLE_ENDIAN) && (defined(__BIG_ENDIAN__) || defined(__sparc) || defined(__sparc__) || defined(__hppa__) || defined(__mips__) || (defined(__MWERKS__) && !defined(__INTEL__)))
-#	define IS_BIG_ENDIAN
-#endif
-
-// define this if running on a little-endian CPU
-// big endian will be assumed if IS_LITTLE_ENDIAN is not defined
-#ifndef IS_BIG_ENDIAN
-#	define IS_LITTLE_ENDIAN
-#endif
-
-// define this if you want to disable all OS-dependent features,
-// such as sockets and OS-provided random number generators
-// #define NO_OS_DEPENDENCE
-
-// Define this to use features provided by Microsoft's CryptoAPI.
-// Currently the only feature used is random number generation.
-// This macro will be ignored if NO_OS_DEPENDENCE is defined.
-#define USE_MS_CRYPTOAPI
-
-// Define this to 1 to enforce the requirement in FIPS 186-2 Change Notice 1 that only 1024 bit moduli be used
-#ifndef DSA_1024_BIT_MODULUS_ONLY
-#	define DSA_1024_BIT_MODULUS_ONLY 1
-#endif
-
-// ***************** Less Important Settings ***************
-
-// define this to retain (as much as possible) old deprecated function and class names
-// #define CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-
-#define GZIP_OS_CODE 0
-
-// Try this if your CPU has 256K internal cache or a slow multiply instruction
-// and you want a (possibly) faster IDEA implementation using log tables
-// #define IDEA_LARGECACHE
-
-// Define this if, for the linear congruential RNG, you want to use
-// the original constants as specified in S.K. Park and K.W. Miller's
-// CACM paper.
-// #define LCRNG_ORIGINAL_NUMBERS
-
-// choose which style of sockets to wrap (mostly useful for cygwin which has both)
-#define PREFER_BERKELEY_STYLE_SOCKETS
-// #define PREFER_WINDOWS_STYLE_SOCKETS
-
-// set the name of Rijndael cipher, was "Rijndael" before version 5.3
-#define CRYPTOPP_RIJNDAEL_NAME "AES"
-
-// ***************** Important Settings Again ********************
-// But the defaults should be ok.
-
-// namespace support is now required
-#ifdef NO_NAMESPACE
-#	error namespace support is now required
-#endif
-
-// Define this to workaround a Microsoft CryptoAPI bug where
-// each call to CryptAcquireContext causes a 100 KB memory leak.
-// Defining this will cause Crypto++ to make only one call to CryptAcquireContext.
-#define WORKAROUND_MS_BUG_Q258000
-
-#ifdef CRYPTOPP_DOXYGEN_PROCESSING
-// Avoid putting "CryptoPP::" in front of everything in Doxygen output
-#	define CryptoPP
-#	define NAMESPACE_BEGIN(x)
-#	define NAMESPACE_END
-// Get Doxygen to generate better documentation for these typedefs
-#	define DOCUMENTED_TYPEDEF(x, y) class y : public x {};
-#else
-#	define NAMESPACE_BEGIN(x) namespace x {
-#	define NAMESPACE_END }
-#	define DOCUMENTED_TYPEDEF(x, y) typedef x y;
-#endif
-#define ANONYMOUS_NAMESPACE_BEGIN namespace {
-#define USING_NAMESPACE(x) using namespace x;
-#define DOCUMENTED_NAMESPACE_BEGIN(x) namespace x {
-#define DOCUMENTED_NAMESPACE_END }
-
-// What is the type of the third parameter to bind?
-// For Unix, the new standard is ::socklen_t (typically unsigned int), and the old standard is int.
-// Unfortunately there is no way to tell whether or not socklen_t is defined.
-// To work around this, TYPE_OF_SOCKLEN_T is a macro so that you can change it from the makefile.
-#ifndef TYPE_OF_SOCKLEN_T
-#	if defined(_WIN32) || defined(__CYGWIN__)
-#		define TYPE_OF_SOCKLEN_T int
-#	else
-#		define TYPE_OF_SOCKLEN_T ::socklen_t
-#	endif
-#endif
-
-#if defined(__CYGWIN__) && defined(PREFER_WINDOWS_STYLE_SOCKETS)
-#	define __USE_W32_SOCKETS
-#endif
-
-typedef unsigned char byte;		// put in global namespace to avoid ambiguity with other byte typedefs
-
-NAMESPACE_BEGIN(CryptoPP)
-
-typedef unsigned short word16;
-typedef unsigned int word32;
-
-#if defined(_MSC_VER) || defined(__BORLANDC__)
-	typedef unsigned __int64 word64;
-	#define W64LIT(x) x##ui64
-#else
-	typedef unsigned long long word64;
-	#define W64LIT(x) x##ULL
-#endif
-
-// define large word type, used for file offsets and such
-typedef word64 lword;
-const lword LWORD_MAX = W64LIT(0xffffffffffffffff);
-
-#ifdef __GNUC__
-	#define CRYPTOPP_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
-#endif
-
-// define hword, word, and dword. these are used for multiprecision integer arithmetic
-// Intel compiler won't have _umul128 until version 10.0. See http://softwarecommunity.intel.com/isn/Community/en-US/forums/thread/30231625.aspx
-#if (defined(_MSC_VER) && (!defined(__INTEL_COMPILER) || __INTEL_COMPILER >= 1000) && (defined(_M_X64) || defined(_M_IA64))) || (defined(__DECCXX) && defined(__alpha__)) || (defined(__INTEL_COMPILER) && defined(__x86_64__)) || (defined(__SUNPRO_CC) && defined(__x86_64__))
-	typedef word32 hword;
-	typedef word64 word;
-#else
-	#define CRYPTOPP_NATIVE_DWORD_AVAILABLE
-	#if defined(__alpha__) || defined(__ia64__) || defined(_ARCH_PPC64) || defined(__x86_64__) || defined(__mips64) || defined(__sparc64__)
-		#if defined(__GNUC__) && !defined(__INTEL_COMPILER) && !(CRYPTOPP_GCC_VERSION == 40001 && defined(__APPLE__)) && CRYPTOPP_GCC_VERSION >= 30400
-			// GCC 4.0.1 on MacOS X is missing __umodti3 and __udivti3
-			// mode(TI) division broken on amd64 with GCC earlier than GCC 3.4
-			typedef word32 hword;
-			typedef word64 word;
-			typedef __uint128_t dword;
-			typedef __uint128_t word128;
-			#define CRYPTOPP_WORD128_AVAILABLE
-		#else
-			// if we're here, it means we're on a 64-bit CPU but we don't have a way to obtain 128-bit multiplication results
-			typedef word16 hword;
-			typedef word32 word;
-			typedef word64 dword;
-		#endif
-	#else
-		// being here means the native register size is probably 32 bits or less
-		#define CRYPTOPP_BOOL_SLOW_WORD64 1
-		typedef word16 hword;
-		typedef word32 word;
-		typedef word64 dword;
-	#endif
-#endif
-#ifndef CRYPTOPP_BOOL_SLOW_WORD64
-	#define CRYPTOPP_BOOL_SLOW_WORD64 0
-#endif
-
-const unsigned int WORD_SIZE = sizeof(word);
-const unsigned int WORD_BITS = WORD_SIZE * 8;
-
-NAMESPACE_END
-
-#ifndef CRYPTOPP_L1_CACHE_LINE_SIZE
-	// This should be a lower bound on the L1 cache line size. It's used for defense against timing attacks.
-	#if defined(_M_X64) || defined(__x86_64__)
-		#define CRYPTOPP_L1_CACHE_LINE_SIZE 64
-	#else
-		// L1 cache line size is 32 on Pentium III and earlier
-		#define CRYPTOPP_L1_CACHE_LINE_SIZE 32
-	#endif
-#endif
-
-#if defined(_MSC_VER)
-	#if _MSC_VER == 1200
-		#include <malloc.h>
-	#endif
-	#if _MSC_VER > 1200 || defined(_mm_free)
-		#define CRYPTOPP_MSVC6PP_OR_LATER		// VC 6 processor pack or later
-	#else
-		#define CRYPTOPP_MSVC6_NO_PP			// VC 6 without processor pack
-	#endif
-#endif
-
-#ifndef CRYPTOPP_ALIGN_DATA
-	#if defined(CRYPTOPP_MSVC6PP_OR_LATER)
-		#define CRYPTOPP_ALIGN_DATA(x) __declspec(align(x))
-	#elif defined(__GNUC__)
-		#define CRYPTOPP_ALIGN_DATA(x) __attribute__((aligned(x)))
-	#else
-		#define CRYPTOPP_ALIGN_DATA(x)
-	#endif
-#endif
-
-#ifndef CRYPTOPP_SECTION_ALIGN16
-	#if defined(__GNUC__) && !defined(__APPLE__)
-		// the alignment attribute doesn't seem to work without this section attribute when -fdata-sections is turned on
-		#define CRYPTOPP_SECTION_ALIGN16 __attribute__((section ("CryptoPP_Align16")))
-	#else
-		#define CRYPTOPP_SECTION_ALIGN16
-	#endif
-#endif
-
-#if defined(_MSC_VER) || defined(__fastcall)
-	#define CRYPTOPP_FASTCALL __fastcall
-#else
-	#define CRYPTOPP_FASTCALL
-#endif
-
-// VC60 workaround: it doesn't allow typename in some places
-#if defined(_MSC_VER) && (_MSC_VER < 1300)
-#define CPP_TYPENAME
-#else
-#define CPP_TYPENAME typename
-#endif
-
-// VC60 workaround: can't cast unsigned __int64 to float or double
-#if defined(_MSC_VER) && !defined(CRYPTOPP_MSVC6PP_OR_LATER)
-#define CRYPTOPP_VC6_INT64 (__int64)
-#else
-#define CRYPTOPP_VC6_INT64
-#endif
-
-#ifdef _MSC_VER
-#define CRYPTOPP_NO_VTABLE __declspec(novtable)
-#else
-#define CRYPTOPP_NO_VTABLE
-#endif
-
-#ifdef _MSC_VER
-	// 4231: nonstandard extension used : 'extern' before template explicit instantiation
-	// 4250: dominance
-	// 4251: member needs to have dll-interface
-	// 4275: base needs to have dll-interface
-	// 4660: explicitly instantiating a class that's already implicitly instantiated
-	// 4661: no suitable definition provided for explicit template instantiation request
-	// 4786: identifer was truncated in debug information
-	// 4355: 'this' : used in base member initializer list
-	// 4910: '__declspec(dllexport)' and 'extern' are incompatible on an explicit instantiation
-#	pragma warning(disable: 4231 4250 4251 4275 4660 4661 4786 4355 4910)
-#endif
-
-#ifdef __BORLANDC__
-// 8037: non-const function called for const object. needed to work around BCB2006 bug
-#	pragma warn -8037
-#endif
-
-#if (defined(_MSC_VER) && _MSC_VER <= 1300) || defined(__MWERKS__) || defined(_STLPORT_VERSION)
-#define CRYPTOPP_DISABLE_UNCAUGHT_EXCEPTION
-#endif
-
-#ifndef CRYPTOPP_DISABLE_UNCAUGHT_EXCEPTION
-#define CRYPTOPP_UNCAUGHT_EXCEPTION_AVAILABLE
-#endif
-
-#ifdef CRYPTOPP_DISABLE_X86ASM		// for backwards compatibility: this macro had both meanings
-#define CRYPTOPP_DISABLE_ASM
-#define CRYPTOPP_DISABLE_SSE2
-#endif
-
-#if !defined(CRYPTOPP_DISABLE_ASM) && ((defined(_MSC_VER) && defined(_M_IX86)) || (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))))
-	#define CRYPTOPP_X86_ASM_AVAILABLE
-
-	#if !defined(CRYPTOPP_DISABLE_SSE2) && (defined(CRYPTOPP_MSVC6PP_OR_LATER) || CRYPTOPP_GCC_VERSION >= 30300)
-		#define CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE 1
-	#else
-		#define CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE 0
-	#endif
-
-	// SSSE3 was actually introduced in GNU as 2.17, which was released 6/23/2006, but we can't tell what version of binutils is installed.
-	// GCC 4.1.2 was released on 2/13/2007, so we'll use that as a proxy for the binutils version.
-	#if !defined(CRYPTOPP_DISABLE_SSSE3) && (_MSC_VER >= 1400 || CRYPTOPP_GCC_VERSION >= 40102)
-		#define CRYPTOPP_BOOL_SSSE3_ASM_AVAILABLE 1
-	#else
-		#define CRYPTOPP_BOOL_SSSE3_ASM_AVAILABLE 0
-	#endif
-#endif
-
-#if !defined(CRYPTOPP_DISABLE_ASM) && defined(_MSC_VER) && defined(_M_X64)
-	#define CRYPTOPP_X64_MASM_AVAILABLE
-#endif
-
-#if !defined(CRYPTOPP_DISABLE_ASM) && defined(__GNUC__) && defined(__x86_64__)
-	#define CRYPTOPP_X64_ASM_AVAILABLE
-#endif
-
-#if !defined(CRYPTOPP_DISABLE_SSE2) && (defined(CRYPTOPP_MSVC6PP_OR_LATER) || defined(__SSE2__))
-	#define CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE 1
-#else
-	#define CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE 0
-#endif
-
-#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE || CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)
-	#define CRYPTOPP_BOOL_ALIGN16_ENABLED 1
-#else
-	#define CRYPTOPP_BOOL_ALIGN16_ENABLED 0
-#endif
-
-// how to allocate 16-byte aligned memory (for SSE2)
-#if defined(CRYPTOPP_MSVC6PP_OR_LATER)
-	#define CRYPTOPP_MM_MALLOC_AVAILABLE
-#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
-	#define CRYPTOPP_MALLOC_ALIGNMENT_IS_16
-#elif defined(__linux__) || defined(__sun__) || defined(__CYGWIN__)
-	#define CRYPTOPP_MEMALIGN_AVAILABLE
-#else
-	#define CRYPTOPP_NO_ALIGNED_ALLOC
-#endif
-
-// how to disable inlining
-#if defined(_MSC_VER) && _MSC_VER >= 1300
-#	define CRYPTOPP_NOINLINE_DOTDOTDOT
-#	define CRYPTOPP_NOINLINE __declspec(noinline)
-#elif defined(__GNUC__)
-#	define CRYPTOPP_NOINLINE_DOTDOTDOT
-#	define CRYPTOPP_NOINLINE __attribute__((noinline))
-#else
-#	define CRYPTOPP_NOINLINE_DOTDOTDOT ...
-#	define CRYPTOPP_NOINLINE 
-#endif
-
-// how to declare class constants
-#if (defined(_MSC_VER) && _MSC_VER <= 1300) || defined(__INTEL_COMPILER)
-#	define CRYPTOPP_CONSTANT(x) enum {x};
-#else
-#	define CRYPTOPP_CONSTANT(x) static const int x;
-#endif
-
-#if defined(_M_X64) || defined(__x86_64__)
-	#define CRYPTOPP_BOOL_X64 1
-#else
-	#define CRYPTOPP_BOOL_X64 0
-#endif
-
-// see http://predef.sourceforge.net/prearch.html
-#if defined(_M_IX86) || defined(__i386__) || defined(__i386) || defined(_X86_) || defined(__I86__) || defined(__INTEL__)
-	#define CRYPTOPP_BOOL_X86 1
-#else
-	#define CRYPTOPP_BOOL_X86 0
-#endif
-
-#if CRYPTOPP_BOOL_X64 || CRYPTOPP_BOOL_X86 || defined(__powerpc__)
-	#define CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
-#endif
-
-#define CRYPTOPP_VERSION 560
-
-// ***************** determine availability of OS features ********************
-
-#ifndef NO_OS_DEPENDENCE
-
-#if defined(_WIN32) || defined(__CYGWIN__)
-#define CRYPTOPP_WIN32_AVAILABLE
-#endif
-
-#if defined(__unix__) || defined(__MACH__) || defined(__NetBSD__) || defined(__sun)
-#define CRYPTOPP_UNIX_AVAILABLE
-#endif
-
-#if defined(CRYPTOPP_WIN32_AVAILABLE) || defined(CRYPTOPP_UNIX_AVAILABLE)
-#	define HIGHRES_TIMER_AVAILABLE
-#endif
-
-#ifdef CRYPTOPP_UNIX_AVAILABLE
-#	define HAS_BERKELEY_STYLE_SOCKETS
-#endif
-
-#ifdef CRYPTOPP_WIN32_AVAILABLE
-#	define HAS_WINDOWS_STYLE_SOCKETS
-#endif
-
-#if defined(HIGHRES_TIMER_AVAILABLE) && (defined(HAS_BERKELEY_STYLE_SOCKETS) || defined(HAS_WINDOWS_STYLE_SOCKETS))
-#	define SOCKETS_AVAILABLE
-#endif
-
-#if defined(HAS_WINDOWS_STYLE_SOCKETS) && (!defined(HAS_BERKELEY_STYLE_SOCKETS) || defined(PREFER_WINDOWS_STYLE_SOCKETS))
-#	define USE_WINDOWS_STYLE_SOCKETS
-#else
-#	define USE_BERKELEY_STYLE_SOCKETS
-#endif
-
-#if defined(HIGHRES_TIMER_AVAILABLE) && defined(CRYPTOPP_WIN32_AVAILABLE) && !defined(USE_BERKELEY_STYLE_SOCKETS)
-#	define WINDOWS_PIPES_AVAILABLE
-#endif
-
-#if defined(CRYPTOPP_WIN32_AVAILABLE) && defined(USE_MS_CRYPTOAPI)
-#	define NONBLOCKING_RNG_AVAILABLE
-#	define OS_RNG_AVAILABLE
-#endif
-
-#if defined(CRYPTOPP_UNIX_AVAILABLE) || defined(CRYPTOPP_DOXYGEN_PROCESSING)
-#	define NONBLOCKING_RNG_AVAILABLE
-#	define BLOCKING_RNG_AVAILABLE
-#	define OS_RNG_AVAILABLE
-#	define HAS_PTHREADS
-#	define THREADS_AVAILABLE
-#endif
-
-#ifdef CRYPTOPP_WIN32_AVAILABLE
-#	define HAS_WINTHREADS
-#	define THREADS_AVAILABLE
-#endif
-
-#endif	// NO_OS_DEPENDENCE
-
-// ***************** DLL related ********************
-
-#ifdef CRYPTOPP_WIN32_AVAILABLE
-
-#ifdef CRYPTOPP_EXPORTS
-#define CRYPTOPP_IS_DLL
-#define CRYPTOPP_DLL __declspec(dllexport)
-#elif defined(CRYPTOPP_IMPORTS)
-#define CRYPTOPP_IS_DLL
-#define CRYPTOPP_DLL __declspec(dllimport)
-#else
-#define CRYPTOPP_DLL
-#endif
-
-#define CRYPTOPP_API __cdecl
-
-#else	// CRYPTOPP_WIN32_AVAILABLE
-
-#define CRYPTOPP_DLL
-#define CRYPTOPP_API
-
-#endif	// CRYPTOPP_WIN32_AVAILABLE
-
-#if defined(__MWERKS__)
-#define CRYPTOPP_EXTERN_DLL_TEMPLATE_CLASS extern class CRYPTOPP_DLL
-#elif defined(__BORLANDC__) || defined(__SUNPRO_CC)
-#define CRYPTOPP_EXTERN_DLL_TEMPLATE_CLASS template class CRYPTOPP_DLL
-#else
-#define CRYPTOPP_EXTERN_DLL_TEMPLATE_CLASS extern template class CRYPTOPP_DLL
-#endif
-
-#if defined(CRYPTOPP_MANUALLY_INSTANTIATE_TEMPLATES) && !defined(CRYPTOPP_IMPORTS)
-#define CRYPTOPP_DLL_TEMPLATE_CLASS template class CRYPTOPP_DLL
-#else
-#define CRYPTOPP_DLL_TEMPLATE_CLASS CRYPTOPP_EXTERN_DLL_TEMPLATE_CLASS
-#endif
-
-#if defined(__MWERKS__)
-#define CRYPTOPP_EXTERN_STATIC_TEMPLATE_CLASS extern class
-#elif defined(__BORLANDC__) || defined(__SUNPRO_CC)
-#define CRYPTOPP_EXTERN_STATIC_TEMPLATE_CLASS template class
-#else
-#define CRYPTOPP_EXTERN_STATIC_TEMPLATE_CLASS extern template class
-#endif
-
-#if defined(CRYPTOPP_MANUALLY_INSTANTIATE_TEMPLATES) && !defined(CRYPTOPP_EXPORTS)
-#define CRYPTOPP_STATIC_TEMPLATE_CLASS template class
-#else
-#define CRYPTOPP_STATIC_TEMPLATE_CLASS CRYPTOPP_EXTERN_STATIC_TEMPLATE_CLASS
-#endif
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/cpu.cpp bitcoin-0.3.20/src/cryptopp/cpu.cpp
--- bitcoin-0.3.20.orig/src/cryptopp/cpu.cpp	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/cpu.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,199 +0,0 @@
-// cpu.cpp - written and placed in the public domain by Wei Dai
-
-#include "pch.h"
-
-#ifndef CRYPTOPP_IMPORTS
-
-#include "cpu.h"
-#include "misc.h"
-#include <algorithm>
-
-#ifdef __GNUC__
-#include <signal.h>
-#include <setjmp.h>
-#endif
-
-#ifdef CRYPTOPP_MSVC6PP_OR_LATER
-#include <emmintrin.h>
-#endif
-
-NAMESPACE_BEGIN(CryptoPP)
-
-#ifdef CRYPTOPP_X86_ASM_AVAILABLE
-
-#ifndef _MSC_VER
-typedef void (*SigHandler)(int);
-
-static jmp_buf s_jmpNoCPUID;
-static void SigIllHandlerCPUID(int)
-{
-	longjmp(s_jmpNoCPUID, 1);
-}
-#endif
-
-bool CpuId(word32 input, word32 *output)
-{
-#ifdef _MSC_VER
-    __try
-	{
-		__asm
-		{
-			mov eax, input
-			cpuid
-			mov edi, output
-			mov [edi], eax
-			mov [edi+4], ebx
-			mov [edi+8], ecx
-			mov [edi+12], edx
-		}
-	}
-    __except (1)
-	{
-		return false;
-    }
-	return true;
-#else
-	SigHandler oldHandler = signal(SIGILL, SigIllHandlerCPUID);
-	if (oldHandler == SIG_ERR)
-		return false;
-
-	bool result = true;
-	if (setjmp(s_jmpNoCPUID))
-		result = false;
-	else
-	{
-		__asm__
-		(
-			// save ebx in case -fPIC is being used
-#if CRYPTOPP_BOOL_X86
-			"push %%ebx; cpuid; mov %%ebx, %%edi; pop %%ebx"
-#else
-			"pushq %%rbx; cpuid; mov %%ebx, %%edi; popq %%rbx"
-#endif
-			: "=a" (output[0]), "=D" (output[1]), "=c" (output[2]), "=d" (output[3])
-			: "a" (input)
-		);
-	}
-
-	signal(SIGILL, oldHandler);
-	return result;
-#endif
-}
-
-#ifndef _MSC_VER
-static jmp_buf s_jmpNoSSE2;
-static void SigIllHandlerSSE2(int)
-{
-	longjmp(s_jmpNoSSE2, 1);
-}
-#endif
-
-#elif _MSC_VER >= 1400 && CRYPTOPP_BOOL_X64
-
-bool CpuId(word32 input, word32 *output)
-{
-	__cpuid((int *)output, input);
-	return true;
-}
-
-#endif
-
-#ifdef CRYPTOPP_CPUID_AVAILABLE
-
-static bool TrySSE2()
-{
-#if CRYPTOPP_BOOL_X64
-	return true;
-#elif defined(_MSC_VER)
-    __try
-	{
-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
-        AS2(por xmm0, xmm0)        // executing SSE2 instruction
-#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE
-		__mm128i x = _mm_setzero_si128();
-		return _mm_cvtsi128_si32(x) == 0;
-#endif
-	}
-    __except (1)
-	{
-		return false;
-    }
-	return true;
-#elif defined(__GNUC__)
-	SigHandler oldHandler = signal(SIGILL, SigIllHandlerSSE2);
-	if (oldHandler == SIG_ERR)
-		return false;
-
-	bool result = true;
-	if (setjmp(s_jmpNoSSE2))
-		result = false;
-	else
-	{
-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
-		__asm __volatile ("por %xmm0, %xmm0");
-#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE
-		__mm128i x = _mm_setzero_si128();
-		result = _mm_cvtsi128_si32(x) == 0;
-#endif
-	}
-
-	signal(SIGILL, oldHandler);
-	return result;
-#else
-	return false;
-#endif
-}
-
-bool g_x86DetectionDone = false;
-bool g_hasISSE = false, g_hasSSE2 = false, g_hasSSSE3 = false, g_hasMMX = false, g_isP4 = false;
-word32 g_cacheLineSize = CRYPTOPP_L1_CACHE_LINE_SIZE;
-
-void DetectX86Features()
-{
-	word32 cpuid[4], cpuid1[4];
-	if (!CpuId(0, cpuid))
-		return;
-	if (!CpuId(1, cpuid1))
-		return;
-
-	g_hasMMX = (cpuid1[3] & (1 << 23)) != 0;
-	if ((cpuid1[3] & (1 << 26)) != 0)
-		g_hasSSE2 = TrySSE2();
-	g_hasSSSE3 = g_hasSSE2 && (cpuid1[2] & (1<<9));
-
-	if ((cpuid1[3] & (1 << 25)) != 0)
-		g_hasISSE = true;
-	else
-	{
-		word32 cpuid2[4];
-		CpuId(0x080000000, cpuid2);
-		if (cpuid2[0] >= 0x080000001)
-		{
-			CpuId(0x080000001, cpuid2);
-			g_hasISSE = (cpuid2[3] & (1 << 22)) != 0;
-		}
-	}
-
-	std::swap(cpuid[2], cpuid[3]);
-	if (memcmp(cpuid+1, "GenuineIntel", 12) == 0)
-	{
-		g_isP4 = ((cpuid1[0] >> 8) & 0xf) == 0xf;
-		g_cacheLineSize = 8 * GETBYTE(cpuid1[1], 1);
-	}
-	else if (memcmp(cpuid+1, "AuthenticAMD", 12) == 0)
-	{
-		CpuId(0x80000005, cpuid);
-		g_cacheLineSize = GETBYTE(cpuid[2], 0);
-	}
-
-	if (!g_cacheLineSize)
-		g_cacheLineSize = CRYPTOPP_L1_CACHE_LINE_SIZE;
-
-	g_x86DetectionDone = true;
-}
-
-#endif
-
-NAMESPACE_END
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/cpu.h bitcoin-0.3.20/src/cryptopp/cpu.h
--- bitcoin-0.3.20.orig/src/cryptopp/cpu.h	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/cpu.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,263 +0,0 @@
-#ifndef CRYPTOPP_CPU_H
-#define CRYPTOPP_CPU_H
-
-#ifdef CRYPTOPP_GENERATE_X64_MASM
-
-#define CRYPTOPP_X86_ASM_AVAILABLE
-#define CRYPTOPP_BOOL_X64 1
-#define CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE 1
-#define NAMESPACE_END
-
-#else
-
-#include "config.h"
-
-#ifdef CRYPTOPP_MSVC6PP_OR_LATER
-	#include <emmintrin.h>
-#endif
-
-NAMESPACE_BEGIN(CryptoPP)
-
-#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || (_MSC_VER >= 1400 && CRYPTOPP_BOOL_X64)
-
-#define CRYPTOPP_CPUID_AVAILABLE
-
-// these should not be used directly
-extern CRYPTOPP_DLL bool g_x86DetectionDone;
-extern CRYPTOPP_DLL bool g_hasSSE2;
-extern CRYPTOPP_DLL bool g_hasISSE;
-extern CRYPTOPP_DLL bool g_hasMMX;
-extern CRYPTOPP_DLL bool g_hasSSSE3;
-extern CRYPTOPP_DLL bool g_isP4;
-extern CRYPTOPP_DLL word32 g_cacheLineSize;
-CRYPTOPP_DLL void CRYPTOPP_API DetectX86Features();
-
-CRYPTOPP_DLL bool CRYPTOPP_API CpuId(word32 input, word32 *output);
-
-#if CRYPTOPP_BOOL_X64
-inline bool HasSSE2()	{return true;}
-inline bool HasISSE()	{return true;}
-inline bool HasMMX()	{return true;}
-#else
-
-inline bool HasSSE2()
-{
-	if (!g_x86DetectionDone)
-		DetectX86Features();
-	return g_hasSSE2;
-}
-
-inline bool HasISSE()
-{
-	if (!g_x86DetectionDone)
-		DetectX86Features();
-	return g_hasISSE;
-}
-
-inline bool HasMMX()
-{
-	if (!g_x86DetectionDone)
-		DetectX86Features();
-	return g_hasMMX;
-}
-
-#endif
-
-inline bool HasSSSE3()
-{
-	if (!g_x86DetectionDone)
-		DetectX86Features();
-	return g_hasSSSE3;
-}
-
-inline bool IsP4()
-{
-	if (!g_x86DetectionDone)
-		DetectX86Features();
-	return g_isP4;
-}
-
-inline int GetCacheLineSize()
-{
-	if (!g_x86DetectionDone)
-		DetectX86Features();
-	return g_cacheLineSize;
-}
-
-#else
-
-inline int GetCacheLineSize()
-{
-	return CRYPTOPP_L1_CACHE_LINE_SIZE;
-}
-
-inline bool HasSSSE3()	{return false;}
-inline bool IsP4()		{return false;}
-
-// assume MMX and SSE2 if intrinsics are enabled
-#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE || CRYPTOPP_BOOL_X64
-inline bool HasSSE2()	{return true;}
-inline bool HasISSE()	{return true;}
-inline bool HasMMX()	{return true;}
-#else
-inline bool HasSSE2()	{return false;}
-inline bool HasISSE()	{return false;}
-inline bool HasMMX()	{return false;}
-#endif
-
-#endif		// #ifdef CRYPTOPP_X86_ASM_AVAILABLE || _MSC_VER >= 1400
-
-#endif
-
-#ifdef CRYPTOPP_GENERATE_X64_MASM
-	#define AS1(x) x*newline*
-	#define AS2(x, y) x, y*newline*
-	#define AS3(x, y, z) x, y, z*newline*
-	#define ASS(x, y, a, b, c, d) x, y, a*64+b*16+c*4+d*newline*
-	#define ASL(x) label##x:*newline*
-	#define ASJ(x, y, z) x label##y*newline*
-	#define ASC(x, y) x label##y*newline*
-	#define AS_HEX(y) 0##y##h
-#elif defined(__GNUC__)
-	// define these in two steps to allow arguments to be expanded
-	#define GNU_AS1(x) #x ";"
-	#define GNU_AS2(x, y) #x ", " #y ";"
-	#define GNU_AS3(x, y, z) #x ", " #y ", " #z ";"
-	#define GNU_ASL(x) "\n" #x ":"
-	#define GNU_ASJ(x, y, z) #x " " #y #z ";"
-	#define AS1(x) GNU_AS1(x)
-	#define AS2(x, y) GNU_AS2(x, y)
-	#define AS3(x, y, z) GNU_AS3(x, y, z)
-	#define ASS(x, y, a, b, c, d) #x ", " #y ", " #a "*64+" #b "*16+" #c "*4+" #d ";"
-	#define ASL(x) GNU_ASL(x)
-	#define ASJ(x, y, z) GNU_ASJ(x, y, z)
-	#define ASC(x, y) #x " " #y ";"
-	#define CRYPTOPP_NAKED
-	#define AS_HEX(y) 0x##y
-#else
-	#define AS1(x) __asm {x}
-	#define AS2(x, y) __asm {x, y}
-	#define AS3(x, y, z) __asm {x, y, z}
-	#define ASS(x, y, a, b, c, d) __asm {x, y, _MM_SHUFFLE(a, b, c, d)}
-	#define ASL(x) __asm {label##x:}
-	#define ASJ(x, y, z) __asm {x label##y}
-	#define ASC(x, y) __asm {x label##y}
-	#define CRYPTOPP_NAKED __declspec(naked)
-	#define AS_HEX(y) 0x##y
-#endif
-
-#define IF0(y)
-#define IF1(y) y
-
-#ifdef CRYPTOPP_GENERATE_X64_MASM
-#define ASM_MOD(x, y) ((x) MOD (y))
-#define XMMWORD_PTR XMMWORD PTR
-#else
-// GNU assembler doesn't seem to have mod operator
-#define ASM_MOD(x, y) ((x)-((x)/(y))*(y))
-// GAS 2.15 doesn't support XMMWORD PTR. it seems necessary only for MASM
-#define XMMWORD_PTR
-#endif
-
-#if CRYPTOPP_BOOL_X86
-	#define AS_REG_1 ecx
-	#define AS_REG_2 edx
-	#define AS_REG_3 esi
-	#define AS_REG_4 edi
-	#define AS_REG_5 eax
-	#define AS_REG_6 ebx
-	#define AS_REG_7 ebp
-	#define AS_REG_1d ecx
-	#define AS_REG_2d edx
-	#define AS_REG_3d esi
-	#define AS_REG_4d edi
-	#define AS_REG_5d eax
-	#define AS_REG_6d ebx
-	#define AS_REG_7d ebp
-	#define WORD_SZ 4
-	#define WORD_REG(x)	e##x
-	#define WORD_PTR DWORD PTR
-	#define AS_PUSH_IF86(x) AS1(push e##x)
-	#define AS_POP_IF86(x) AS1(pop e##x)
-	#define AS_JCXZ jecxz
-#elif CRYPTOPP_BOOL_X64
-	#ifdef CRYPTOPP_GENERATE_X64_MASM
-		#define AS_REG_1 rcx
-		#define AS_REG_2 rdx
-		#define AS_REG_3 r8
-		#define AS_REG_4 r9
-		#define AS_REG_5 rax
-		#define AS_REG_6 r10
-		#define AS_REG_7 r11
-		#define AS_REG_1d ecx
-		#define AS_REG_2d edx
-		#define AS_REG_3d r8d
-		#define AS_REG_4d r9d
-		#define AS_REG_5d eax
-		#define AS_REG_6d r10d
-		#define AS_REG_7d r11d
-	#else
-		#define AS_REG_1 rdi
-		#define AS_REG_2 rsi
-		#define AS_REG_3 rdx
-		#define AS_REG_4 rcx
-		#define AS_REG_5 r8
-		#define AS_REG_6 r9
-		#define AS_REG_7 r10
-		#define AS_REG_1d edi
-		#define AS_REG_2d esi
-		#define AS_REG_3d edx
-		#define AS_REG_4d ecx
-		#define AS_REG_5d r8d
-		#define AS_REG_6d r9d
-		#define AS_REG_7d r10d
-	#endif
-	#define WORD_SZ 8
-	#define WORD_REG(x)	r##x
-	#define WORD_PTR QWORD PTR
-	#define AS_PUSH_IF86(x)
-	#define AS_POP_IF86(x)
-	#define AS_JCXZ jrcxz
-#endif
-
-// helper macro for stream cipher output
-#define AS_XMM_OUTPUT4(labelPrefix, inputPtr, outputPtr, x0, x1, x2, x3, t, p0, p1, p2, p3, increment)\
-	AS2(	test	inputPtr, inputPtr)\
-	ASC(	jz,		labelPrefix##3)\
-	AS2(	test	inputPtr, 15)\
-	ASC(	jnz,	labelPrefix##7)\
-	AS2(	pxor	xmm##x0, [inputPtr+p0*16])\
-	AS2(	pxor	xmm##x1, [inputPtr+p1*16])\
-	AS2(	pxor	xmm##x2, [inputPtr+p2*16])\
-	AS2(	pxor	xmm##x3, [inputPtr+p3*16])\
-	AS2(	add		inputPtr, increment*16)\
-	ASC(	jmp,	labelPrefix##3)\
-	ASL(labelPrefix##7)\
-	AS2(	movdqu	xmm##t, [inputPtr+p0*16])\
-	AS2(	pxor	xmm##x0, xmm##t)\
-	AS2(	movdqu	xmm##t, [inputPtr+p1*16])\
-	AS2(	pxor	xmm##x1, xmm##t)\
-	AS2(	movdqu	xmm##t, [inputPtr+p2*16])\
-	AS2(	pxor	xmm##x2, xmm##t)\
-	AS2(	movdqu	xmm##t, [inputPtr+p3*16])\
-	AS2(	pxor	xmm##x3, xmm##t)\
-	AS2(	add		inputPtr, increment*16)\
-	ASL(labelPrefix##3)\
-	AS2(	test	outputPtr, 15)\
-	ASC(	jnz,	labelPrefix##8)\
-	AS2(	movdqa	[outputPtr+p0*16], xmm##x0)\
-	AS2(	movdqa	[outputPtr+p1*16], xmm##x1)\
-	AS2(	movdqa	[outputPtr+p2*16], xmm##x2)\
-	AS2(	movdqa	[outputPtr+p3*16], xmm##x3)\
-	ASC(	jmp,	labelPrefix##9)\
-	ASL(labelPrefix##8)\
-	AS2(	movdqu	[outputPtr+p0*16], xmm##x0)\
-	AS2(	movdqu	[outputPtr+p1*16], xmm##x1)\
-	AS2(	movdqu	[outputPtr+p2*16], xmm##x2)\
-	AS2(	movdqu	[outputPtr+p3*16], xmm##x3)\
-	ASL(labelPrefix##9)\
-	AS2(	add		outputPtr, increment*16)
-
-NAMESPACE_END
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/cryptlib.h bitcoin-0.3.20/src/cryptopp/cryptlib.h
--- bitcoin-0.3.20.orig/src/cryptopp/cryptlib.h	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/cryptlib.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,1668 +0,0 @@
-// cryptlib.h - written and placed in the public domain by Wei Dai
-/*! \file
- 	This file contains the declarations for the abstract base
-	classes that provide a uniform interface to this library.
-*/
-
-/*!	\mainpage Crypto++ Library 5.6.0 API Reference
-<dl>
-<dt>Abstract Base Classes<dd>
-	cryptlib.h
-<dt>Authenticated Encryption<dd>
-	AuthenticatedSymmetricCipherDocumentation
-<dt>Symmetric Ciphers<dd>
-	SymmetricCipherDocumentation
-<dt>Hash Functions<dd>
-	SHA1, SHA224, SHA256, SHA384, SHA512, Tiger, Whirlpool, RIPEMD160, RIPEMD320, RIPEMD128, RIPEMD256, Weak1::MD2, Weak1::MD4, Weak1::MD5
-<dt>Non-Cryptographic Checksums<dd>
-	CRC32, Adler32
-<dt>Message Authentication Codes<dd>
-	VMAC, HMAC, CBC_MAC, CMAC, DMAC, TTMAC, GCM (GMAC)
-<dt>Random Number Generators<dd>
-	NullRNG(), LC_RNG, RandomPool, BlockingRng, NonblockingRng, AutoSeededRandomPool, AutoSeededX917RNG, DefaultAutoSeededRNG
-<dt>Password-based Cryptography<dd>
-	PasswordBasedKeyDerivationFunction
-<dt>Public Key Cryptosystems<dd>
-	DLIES, ECIES, LUCES, RSAES, RabinES, LUC_IES
-<dt>Public Key Signature Schemes<dd>
-	DSA, GDSA, ECDSA, NR, ECNR, LUCSS, RSASS, RSASS_ISO, RabinSS, RWSS, ESIGN
-<dt>Key Agreement<dd>
-	#DH, DH2, #MQV, ECDH, ECMQV, XTR_DH
-<dt>Algebraic Structures<dd>
-	Integer, PolynomialMod2, PolynomialOver, RingOfPolynomialsOver,
-	ModularArithmetic, MontgomeryRepresentation, GFP2_ONB,
-	GF2NP, GF256, GF2_32, EC2N, ECP
-<dt>Secret Sharing and Information Dispersal<dd>
-	SecretSharing, SecretRecovery, InformationDispersal, InformationRecovery
-<dt>Compression<dd>
-	Deflator, Inflator, Gzip, Gunzip, ZlibCompressor, ZlibDecompressor
-<dt>Input Source Classes<dd>
-	StringSource, ArraySource, FileSource, SocketSource, WindowsPipeSource, RandomNumberSource
-<dt>Output Sink Classes<dd>
-	StringSinkTemplate, ArraySink, FileSink, SocketSink, WindowsPipeSink, RandomNumberSink
-<dt>Filter Wrappers<dd>
-	StreamTransformationFilter, HashFilter, HashVerificationFilter, SignerFilter, SignatureVerificationFilter
-<dt>Binary to Text Encoders and Decoders<dd>
-	HexEncoder, HexDecoder, Base64Encoder, Base64Decoder, Base32Encoder, Base32Decoder
-<dt>Wrappers for OS features<dd>
-	Timer, Socket, WindowsHandle, ThreadLocalStorage, ThreadUserTimer
-<dt>FIPS 140 related<dd>
-	fips140.h
-</dl>
-
-In the FIPS 140-2 validated DLL version of Crypto++, only the following implementation class are available.
-<dl>
-<dt>Block Ciphers<dd>
-	AES, DES_EDE2, DES_EDE3, SKIPJACK
-<dt>Cipher Modes (replace template parameter BC with one of the block ciphers above)<dd>
-	ECB_Mode\<BC\>, CTR_Mode\<BC\>, CBC_Mode\<BC\>, CFB_FIPS_Mode\<BC\>, OFB_Mode\<BC\>
-<dt>Hash Functions<dd>
-	SHA1, SHA224, SHA256, SHA384, SHA512
-<dt>Public Key Signature Schemes (replace template parameter H with one of the hash functions above)<dd>
-	RSASS\<PKCS1v15, H\>, RSASS\<PSS, H\>, RSASS_ISO\<H\>, RWSS\<P1363_EMSA2, H\>, DSA, ECDSA\<ECP, H\>, ECDSA\<EC2N, H\>
-<dt>Message Authentication Codes (replace template parameter H with one of the hash functions above)<dd>
-	HMAC\<H\>, CBC_MAC\<DES_EDE2\>, CBC_MAC\<DES_EDE3\>
-<dt>Random Number Generators<dd>
-	DefaultAutoSeededRNG (AutoSeededX917RNG\<AES\>)
-<dt>Key Agreement<dd>
-	#DH
-<dt>Public Key Cryptosystems<dd>
-	RSAES\<OAEP\<SHA1\> \>
-</dl>
-
-<p>This reference manual is a work in progress. Some classes are still lacking detailed descriptions.
-<p>Click <a href="CryptoPPRef.zip">here</a> to download a zip archive containing this manual.
-<p>Thanks to Ryan Phillips for providing the Doxygen configuration file
-and getting me started with this manual.
-*/
-
-#ifndef CRYPTOPP_CRYPTLIB_H
-#define CRYPTOPP_CRYPTLIB_H
-
-#include "config.h"
-#include "stdcpp.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-// forward declarations
-class Integer;
-class RandomNumberGenerator;
-class BufferedTransformation;
-
-//! used to specify a direction for a cipher to operate in (encrypt or decrypt)
-enum CipherDir {ENCRYPTION, DECRYPTION};
-
-//! used to represent infinite time
-const unsigned long INFINITE_TIME = ULONG_MAX;
-
-// VC60 workaround: using enums as template parameters causes problems
-template <typename ENUM_TYPE, int VALUE>
-struct EnumToType
-{
-	static ENUM_TYPE ToEnum() {return (ENUM_TYPE)VALUE;}
-};
-
-enum ByteOrder {LITTLE_ENDIAN_ORDER = 0, BIG_ENDIAN_ORDER = 1};
-typedef EnumToType<ByteOrder, LITTLE_ENDIAN_ORDER> LittleEndian;
-typedef EnumToType<ByteOrder, BIG_ENDIAN_ORDER> BigEndian;
-
-//! base class for all exceptions thrown by Crypto++
-class CRYPTOPP_DLL Exception : public std::exception
-{
-public:
-	//! error types
-	enum ErrorType {
-		//! a method is not implemented
-		NOT_IMPLEMENTED,
-		//! invalid function argument
-		INVALID_ARGUMENT,
-		//! BufferedTransformation received a Flush(true) signal but can't flush buffers
-		CANNOT_FLUSH,
-		//! data integerity check (such as CRC or MAC) failed
-		DATA_INTEGRITY_CHECK_FAILED,
-		//! received input data that doesn't conform to expected format
-		INVALID_DATA_FORMAT,
-		//! error reading from input device or writing to output device
-		IO_ERROR,
-		//! some error not belong to any of the above categories
-		OTHER_ERROR
-	};
-
-	explicit Exception(ErrorType errorType, const std::string &s) : m_errorType(errorType), m_what(s) {}
-	virtual ~Exception() throw() {}
-	const char *what() const throw() {return (m_what.c_str());}
-	const std::string &GetWhat() const {return m_what;}
-	void SetWhat(const std::string &s) {m_what = s;}
-	ErrorType GetErrorType() const {return m_errorType;}
-	void SetErrorType(ErrorType errorType) {m_errorType = errorType;}
-
-private:
-	ErrorType m_errorType;
-	std::string m_what;
-};
-
-//! exception thrown when an invalid argument is detected
-class CRYPTOPP_DLL InvalidArgument : public Exception
-{
-public:
-	explicit InvalidArgument(const std::string &s) : Exception(INVALID_ARGUMENT, s) {}
-};
-
-//! exception thrown when input data is received that doesn't conform to expected format
-class CRYPTOPP_DLL InvalidDataFormat : public Exception
-{
-public:
-	explicit InvalidDataFormat(const std::string &s) : Exception(INVALID_DATA_FORMAT, s) {}
-};
-
-//! exception thrown by decryption filters when trying to decrypt an invalid ciphertext
-class CRYPTOPP_DLL InvalidCiphertext : public InvalidDataFormat
-{
-public:
-	explicit InvalidCiphertext(const std::string &s) : InvalidDataFormat(s) {}
-};
-
-//! exception thrown by a class if a non-implemented method is called
-class CRYPTOPP_DLL NotImplemented : public Exception
-{
-public:
-	explicit NotImplemented(const std::string &s) : Exception(NOT_IMPLEMENTED, s) {}
-};
-
-//! exception thrown by a class when Flush(true) is called but it can't completely flush its buffers
-class CRYPTOPP_DLL CannotFlush : public Exception
-{
-public:
-	explicit CannotFlush(const std::string &s) : Exception(CANNOT_FLUSH, s) {}
-};
-
-//! error reported by the operating system
-class CRYPTOPP_DLL OS_Error : public Exception
-{
-public:
-	OS_Error(ErrorType errorType, const std::string &s, const std::string& operation, int errorCode)
-		: Exception(errorType, s), m_operation(operation), m_errorCode(errorCode) {}
-	~OS_Error() throw() {}
-
-	// the operating system API that reported the error
-	const std::string & GetOperation() const {return m_operation;}
-	// the error code return by the operating system
-	int GetErrorCode() const {return m_errorCode;}
-
-protected:
-	std::string m_operation;
-	int m_errorCode;
-};
-
-//! used to return decoding results
-struct CRYPTOPP_DLL DecodingResult
-{
-	explicit DecodingResult() : isValidCoding(false), messageLength(0) {}
-	explicit DecodingResult(size_t len) : isValidCoding(true), messageLength(len) {}
-
-	bool operator==(const DecodingResult &rhs) const {return isValidCoding == rhs.isValidCoding && messageLength == rhs.messageLength;}
-	bool operator!=(const DecodingResult &rhs) const {return !operator==(rhs);}
-
-	bool isValidCoding;
-	size_t messageLength;
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-	operator size_t() const {return isValidCoding ? messageLength : 0;}
-#endif
-};
-
-//! interface for retrieving values given their names
-/*! \note This class is used to safely pass a variable number of arbitrarily typed arguments to functions
-	and to read values from keys and crypto parameters.
-	\note To obtain an object that implements NameValuePairs for the purpose of parameter
-	passing, use the MakeParameters() function.
-	\note To get a value from NameValuePairs, you need to know the name and the type of the value. 
-	Call GetValueNames() on a NameValuePairs object to obtain a list of value names that it supports.
-	Then look at the Name namespace documentation to see what the type of each value is, or
-	alternatively, call GetIntValue() with the value name, and if the type is not int, a
-	ValueTypeMismatch exception will be thrown and you can get the actual type from the exception object.
-*/
-class CRYPTOPP_NO_VTABLE NameValuePairs
-{
-public:
-	virtual ~NameValuePairs() {}
-
-	//! exception thrown when trying to retrieve a value using a different type than expected
-	class CRYPTOPP_DLL ValueTypeMismatch : public InvalidArgument
-	{
-	public:
-		ValueTypeMismatch(const std::string &name, const std::type_info &stored, const std::type_info &retrieving)
-			: InvalidArgument("NameValuePairs: type mismatch for '" + name + "', stored '" + stored.name() + "', trying to retrieve '" + retrieving.name() + "'")
-			, m_stored(stored), m_retrieving(retrieving) {}
-
-		const std::type_info & GetStoredTypeInfo() const {return m_stored;}
-		const std::type_info & GetRetrievingTypeInfo() const {return m_retrieving;}
-
-	private:
-		const std::type_info &m_stored;
-		const std::type_info &m_retrieving;
-	};
-
-	//! get a copy of this object or a subobject of it
-	template <class T>
-	bool GetThisObject(T &object) const
-	{
-		return GetValue((std::string("ThisObject:")+typeid(T).name()).c_str(), object);
-	}
-
-	//! get a pointer to this object, as a pointer to T
-	template <class T>
-	bool GetThisPointer(T *&p) const
-	{
-		return GetValue((std::string("ThisPointer:")+typeid(T).name()).c_str(), p);
-	}
-
-	//! get a named value, returns true if the name exists
-	template <class T>
-	bool GetValue(const char *name, T &value) const
-	{
-		return GetVoidValue(name, typeid(T), &value);
-	}
-
-	//! get a named value, returns the default if the name doesn't exist
-	template <class T>
-	T GetValueWithDefault(const char *name, T defaultValue) const
-	{
-		GetValue(name, defaultValue);
-		return defaultValue;
-	}
-
-	//! get a list of value names that can be retrieved
-	CRYPTOPP_DLL std::string GetValueNames() const
-		{std::string result; GetValue("ValueNames", result); return result;}
-
-	//! get a named value with type int
-	/*! used to ensure we don't accidentally try to get an unsigned int
-		or some other type when we mean int (which is the most common case) */
-	CRYPTOPP_DLL bool GetIntValue(const char *name, int &value) const
-		{return GetValue(name, value);}
-
-	//! get a named value with type int, with default
-	CRYPTOPP_DLL int GetIntValueWithDefault(const char *name, int defaultValue) const
-		{return GetValueWithDefault(name, defaultValue);}
-
-	//! used by derived classes to check for type mismatch
-	CRYPTOPP_DLL static void CRYPTOPP_API ThrowIfTypeMismatch(const char *name, const std::type_info &stored, const std::type_info &retrieving)
-		{if (stored != retrieving) throw ValueTypeMismatch(name, stored, retrieving);}
-
-	template <class T>
-	void GetRequiredParameter(const char *className, const char *name, T &value) const
-	{
-		if (!GetValue(name, value))
-			throw InvalidArgument(std::string(className) + ": missing required parameter '" + name + "'");
-	}
-
-	CRYPTOPP_DLL void GetRequiredIntParameter(const char *className, const char *name, int &value) const
-	{
-		if (!GetIntValue(name, value))
-			throw InvalidArgument(std::string(className) + ": missing required parameter '" + name + "'");
-	}
-
-	//! to be implemented by derived classes, users should use one of the above functions instead
-	CRYPTOPP_DLL virtual bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const =0;
-};
-
-//! namespace containing value name definitions
-/*!	value names, types and semantics:
-
-	ThisObject:ClassName (ClassName, copy of this object or a subobject)
-	ThisPointer:ClassName (const ClassName *, pointer to this object or a subobject)
-*/
-DOCUMENTED_NAMESPACE_BEGIN(Name)
-// more names defined in argnames.h
-DOCUMENTED_NAMESPACE_END
-
-//! empty set of name-value pairs
-class CRYPTOPP_DLL NullNameValuePairs : public NameValuePairs
-{
-public:
-	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const {return false;}
-};
-
-//! _
-extern CRYPTOPP_DLL const NullNameValuePairs g_nullNameValuePairs;
-
-// ********************************************************
-
-//! interface for cloning objects, this is not implemented by most classes yet
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Clonable
-{
-public:
-	virtual ~Clonable() {}
-	//! this is not implemented by most classes yet
-	virtual Clonable* Clone() const {throw NotImplemented("Clone() is not implemented yet.");}	// TODO: make this =0
-};
-
-//! interface for all crypto algorithms
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Algorithm : public Clonable
-{
-public:
-	/*! When FIPS 140-2 compliance is enabled and checkSelfTestStatus == true,
-		this constructor throws SelfTestFailure if the self test hasn't been run or fails. */
-	Algorithm(bool checkSelfTestStatus = true);
-	//! returns name of this algorithm, not universally implemented yet
-	virtual std::string AlgorithmName() const {return "unknown";}
-};
-
-//! keying interface for crypto algorithms that take byte strings as keys
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE SimpleKeyingInterface
-{
-public:
-	virtual ~SimpleKeyingInterface() {}
-
-	//! returns smallest valid key length in bytes */
-	virtual size_t MinKeyLength() const =0;
-	//! returns largest valid key length in bytes */
-	virtual size_t MaxKeyLength() const =0;
-	//! returns default (recommended) key length in bytes */
-	virtual size_t DefaultKeyLength() const =0;
-
-	//! returns the smallest valid key length in bytes that is >= min(n, GetMaxKeyLength())
-	virtual size_t GetValidKeyLength(size_t n) const =0;
-
-	//! returns whether n is a valid key length
-	virtual bool IsValidKeyLength(size_t n) const
-		{return n == GetValidKeyLength(n);}
-
-	//! set or reset the key of this object
-	/*! \param params is used to specify Rounds, BlockSize, etc. */
-	virtual void SetKey(const byte *key, size_t length, const NameValuePairs &params = g_nullNameValuePairs);
-
-	//! calls SetKey() with an NameValuePairs object that just specifies "Rounds"
-	void SetKeyWithRounds(const byte *key, size_t length, int rounds);
-
-	//! calls SetKey() with an NameValuePairs object that just specifies "IV"
-	void SetKeyWithIV(const byte *key, size_t length, const byte *iv, size_t ivLength);
-
-	//! calls SetKey() with an NameValuePairs object that just specifies "IV"
-	void SetKeyWithIV(const byte *key, size_t length, const byte *iv)
-		{SetKeyWithIV(key, length, iv, IVSize());}
-
-	enum IV_Requirement {UNIQUE_IV = 0, RANDOM_IV, UNPREDICTABLE_RANDOM_IV, INTERNALLY_GENERATED_IV, NOT_RESYNCHRONIZABLE};
-	//! returns the minimal requirement for secure IVs
-	virtual IV_Requirement IVRequirement() const =0;
-
-	//! returns whether this object can be resynchronized (i.e. supports initialization vectors)
-	/*! If this function returns true, and no IV is passed to SetKey() and CanUseStructuredIVs()==true, an IV of all 0's will be assumed. */
-	bool IsResynchronizable() const {return IVRequirement() < NOT_RESYNCHRONIZABLE;}
-	//! returns whether this object can use random IVs (in addition to ones returned by GetNextIV)
-	bool CanUseRandomIVs() const {return IVRequirement() <= UNPREDICTABLE_RANDOM_IV;}
-	//! returns whether this object can use random but possibly predictable IVs (in addition to ones returned by GetNextIV)
-	bool CanUsePredictableIVs() const {return IVRequirement() <= RANDOM_IV;}
-	//! returns whether this object can use structured IVs, for example a counter (in addition to ones returned by GetNextIV)
-	bool CanUseStructuredIVs() const {return IVRequirement() <= UNIQUE_IV;}
-
-	virtual unsigned int IVSize() const {throw NotImplemented(GetAlgorithm().AlgorithmName() + ": this object doesn't support resynchronization");}
-	//! returns default length of IVs accepted by this object
-	unsigned int DefaultIVLength() const {return IVSize();}
-	//! returns minimal length of IVs accepted by this object
-	virtual unsigned int MinIVLength() const {return IVSize();}
-	//! returns maximal length of IVs accepted by this object
-	virtual unsigned int MaxIVLength() const {return IVSize();}
-	//! resynchronize with an IV. ivLength=-1 means use IVSize()
-	virtual void Resynchronize(const byte *iv, int ivLength=-1) {throw NotImplemented(GetAlgorithm().AlgorithmName() + ": this object doesn't support resynchronization");}
-	//! get a secure IV for the next message
-	/*! This method should be called after you finish encrypting one message and are ready to start the next one.
-		After calling it, you must call SetKey() or Resynchronize() before using this object again. 
-		This method is not implemented on decryption objects. */
-	virtual void GetNextIV(RandomNumberGenerator &rng, byte *IV);
-
-protected:
-	virtual const Algorithm & GetAlgorithm() const =0;
-	virtual void UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params) =0;
-
-	void ThrowIfInvalidKeyLength(size_t length);
-	void ThrowIfResynchronizable();			// to be called when no IV is passed
-	void ThrowIfInvalidIV(const byte *iv);	// check for NULL IV if it can't be used
-	size_t ThrowIfInvalidIVLength(int size);
-	const byte * GetIVAndThrowIfInvalid(const NameValuePairs &params, size_t &size);
-	inline void AssertValidKeyLength(size_t length) const
-		{assert(IsValidKeyLength(length));}
-};
-
-//! interface for the data processing part of block ciphers
-
-/*! Classes derived from BlockTransformation are block ciphers
-	in ECB mode (for example the DES::Encryption class), which are stateless.
-	These classes should not be used directly, but only in combination with
-	a mode class (see CipherModeDocumentation in modes.h).
-*/
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE BlockTransformation : public Algorithm
-{
-public:
-	//! encrypt or decrypt inBlock, xor with xorBlock, and write to outBlock
-	virtual void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const =0;
-
-	//! encrypt or decrypt one block
-	/*! \pre size of inBlock and outBlock == BlockSize() */
-	void ProcessBlock(const byte *inBlock, byte *outBlock) const
-		{ProcessAndXorBlock(inBlock, NULL, outBlock);}
-
-	//! encrypt or decrypt one block in place
-	void ProcessBlock(byte *inoutBlock) const
-		{ProcessAndXorBlock(inoutBlock, NULL, inoutBlock);}
-
-	//! block size of the cipher in bytes
-	virtual unsigned int BlockSize() const =0;
-
-	//! returns how inputs and outputs should be aligned for optimal performance
-	virtual unsigned int OptimalDataAlignment() const;
-
-	//! returns true if this is a permutation (i.e. there is an inverse transformation)
-	virtual bool IsPermutation() const {return true;}
-
-	//! returns true if this is an encryption object
-	virtual bool IsForwardTransformation() const =0;
-
-	//! return number of blocks that can be processed in parallel, for bit-slicing implementations
-	virtual unsigned int OptimalNumberOfParallelBlocks() const {return 1;}
-
-	enum {BT_InBlockIsCounter=1, BT_DontIncrementInOutPointers=2, BT_XorInput=4, BT_ReverseDirection=8} FlagsForAdvancedProcessBlocks;
-
-	//! encrypt and xor blocks according to flags (see FlagsForAdvancedProcessBlocks)
-	/*! /note If BT_InBlockIsCounter is set, last byte of inBlocks may be modified. */
-	virtual size_t AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const;
-
-	inline CipherDir GetCipherDirection() const {return IsForwardTransformation() ? ENCRYPTION : DECRYPTION;}
-};
-
-//! interface for the data processing part of stream ciphers
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE StreamTransformation : public Algorithm
-{
-public:
-	//! return a reference to this object, 
-	/*! This function is useful for passing a temporary StreamTransformation object to a 
-		function that takes a non-const reference. */
-	StreamTransformation& Ref() {return *this;}
-
-	//! returns block size, if input must be processed in blocks, otherwise 1
-	virtual unsigned int MandatoryBlockSize() const {return 1;}
-
-	//! returns the input block size that is most efficient for this cipher
-	/*! \note optimal input length is n * OptimalBlockSize() - GetOptimalBlockSizeUsed() for any n > 0 */
-	virtual unsigned int OptimalBlockSize() const {return MandatoryBlockSize();}
-	//! returns how much of the current block is used up
-	virtual unsigned int GetOptimalBlockSizeUsed() const {return 0;}
-
-	//! returns how input should be aligned for optimal performance
-	virtual unsigned int OptimalDataAlignment() const;
-
-	//! encrypt or decrypt an array of bytes of specified length
-	/*! \note either inString == outString, or they don't overlap */
-	virtual void ProcessData(byte *outString, const byte *inString, size_t length) =0;
-
-	//! for ciphers where the last block of data is special, encrypt or decrypt the last block of data
-	/*! For now the only use of this function is for CBC-CTS mode. */
-	virtual void ProcessLastBlock(byte *outString, const byte *inString, size_t length);
-	//! returns the minimum size of the last block, 0 indicating the last block is not special
-	virtual unsigned int MinLastBlockSize() const {return 0;}
-
-	//! same as ProcessData(inoutString, inoutString, length)
-	inline void ProcessString(byte *inoutString, size_t length)
-		{ProcessData(inoutString, inoutString, length);}
-	//! same as ProcessData(outString, inString, length)
-	inline void ProcessString(byte *outString, const byte *inString, size_t length)
-		{ProcessData(outString, inString, length);}
-	//! implemented as {ProcessData(&input, &input, 1); return input;}
-	inline byte ProcessByte(byte input)
-		{ProcessData(&input, &input, 1); return input;}
-
-	//! returns whether this cipher supports random access
-	virtual bool IsRandomAccess() const =0;
-	//! for random access ciphers, seek to an absolute position
-	virtual void Seek(lword n)
-	{
-		assert(!IsRandomAccess());
-		throw NotImplemented("StreamTransformation: this object doesn't support random access");
-	}
-
-	//! returns whether this transformation is self-inverting (e.g. xor with a keystream)
-	virtual bool IsSelfInverting() const =0;
-	//! returns whether this is an encryption object
-	virtual bool IsForwardTransformation() const =0;
-};
-
-//! interface for hash functions and data processing part of MACs
-
-/*! HashTransformation objects are stateful.  They are created in an initial state,
-	change state as Update() is called, and return to the initial
-	state when Final() is called.  This interface allows a large message to
-	be hashed in pieces by calling Update() on each piece followed by
-	calling Final().
-*/
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE HashTransformation : public Algorithm
-{
-public:
-	//! return a reference to this object, 
-	/*! This function is useful for passing a temporary HashTransformation object to a 
-		function that takes a non-const reference. */
-	HashTransformation& Ref() {return *this;}
-
-	//! process more input
-	virtual void Update(const byte *input, size_t length) =0;
-
-	//! request space to write input into
-	virtual byte * CreateUpdateSpace(size_t &size) {size=0; return NULL;}
-
-	//! compute hash for current message, then restart for a new message
-	/*!	\pre size of digest == DigestSize(). */
-	virtual void Final(byte *digest)
-		{TruncatedFinal(digest, DigestSize());}
-
-	//! discard the current state, and restart with a new message
-	virtual void Restart()
-		{TruncatedFinal(NULL, 0);}
-
-	//! size of the hash/digest/MAC returned by Final()
-	virtual unsigned int DigestSize() const =0;
-
-	//! same as DigestSize()
-	unsigned int TagSize() const {return DigestSize();}
-
-
-	//! block size of underlying compression function, or 0 if not block based
-	virtual unsigned int BlockSize() const {return 0;}
-
-	//! input to Update() should have length a multiple of this for optimal speed
-	virtual unsigned int OptimalBlockSize() const {return 1;}
-
-	//! returns how input should be aligned for optimal performance
-	virtual unsigned int OptimalDataAlignment() const;
-
-	//! use this if your input is in one piece and you don't want to call Update() and Final() separately
-	virtual void CalculateDigest(byte *digest, const byte *input, size_t length)
-		{Update(input, length); Final(digest);}
-
-	//! verify that digest is a valid digest for the current message, then reinitialize the object
-	/*! Default implementation is to call Final() and do a bitwise comparison
-		between its output and digest. */
-	virtual bool Verify(const byte *digest)
-		{return TruncatedVerify(digest, DigestSize());}
-
-	//! use this if your input is in one piece and you don't want to call Update() and Verify() separately
-	virtual bool VerifyDigest(const byte *digest, const byte *input, size_t length)
-		{Update(input, length); return Verify(digest);}
-
-	//! truncated version of Final()
-	virtual void TruncatedFinal(byte *digest, size_t digestSize) =0;
-
-	//! truncated version of CalculateDigest()
-	virtual void CalculateTruncatedDigest(byte *digest, size_t digestSize, const byte *input, size_t length)
-		{Update(input, length); TruncatedFinal(digest, digestSize);}
-
-	//! truncated version of Verify()
-	virtual bool TruncatedVerify(const byte *digest, size_t digestLength);
-
-	//! truncated version of VerifyDigest()
-	virtual bool VerifyTruncatedDigest(const byte *digest, size_t digestLength, const byte *input, size_t length)
-		{Update(input, length); return TruncatedVerify(digest, digestLength);}
-
-protected:
-	void ThrowIfInvalidTruncatedSize(size_t size) const;
-};
-
-typedef HashTransformation HashFunction;
-
-//! interface for one direction (encryption or decryption) of a block cipher
-/*! \note These objects usually should not be used directly. See BlockTransformation for more details. */
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE BlockCipher : public SimpleKeyingInterface, public BlockTransformation
-{
-protected:
-	const Algorithm & GetAlgorithm() const {return *this;}
-};
-
-//! interface for one direction (encryption or decryption) of a stream cipher or cipher mode
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE SymmetricCipher : public SimpleKeyingInterface, public StreamTransformation
-{
-protected:
-	const Algorithm & GetAlgorithm() const {return *this;}
-};
-
-//! interface for message authentication codes
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE MessageAuthenticationCode : public SimpleKeyingInterface, public HashTransformation
-{
-protected:
-	const Algorithm & GetAlgorithm() const {return *this;}
-};
-
-//! interface for for one direction (encryption or decryption) of a stream cipher or block cipher mode with authentication
-/*! The StreamTransformation part of this interface is used to encrypt/decrypt the data, and the MessageAuthenticationCode part of this
-	interface is used to input additional authenticated data (AAD, which is MAC'ed but not encrypted), and to generate/verify the MAC. */
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE AuthenticatedSymmetricCipher : public MessageAuthenticationCode, public StreamTransformation
-{
-public:
-	//! this indicates that a member function was called in the wrong state, for example trying to encrypt a message before having set the key or IV
-	class BadState : public Exception
-	{
-	public:
-		explicit BadState(const std::string &name, const char *message) : Exception(OTHER_ERROR, name + ": " + message) {}
-		explicit BadState(const std::string &name, const char *function, const char *state) : Exception(OTHER_ERROR, name + ": " + function + " was called before " + state) {}
-	};
-
-	//! the maximum length of AAD that can be input before the encrypted data
-	virtual lword MaxHeaderLength() const =0;
-	//! the maximum length of encrypted data
-	virtual lword MaxMessageLength() const =0;
-	//! the maximum length of AAD that can be input after the encrypted data
-	virtual lword MaxFooterLength() const {return 0;}
-	//! if this function returns true, SpecifyDataLengths() must be called before attempting to input data
-	/*! This is the case for some schemes, such as CCM. */
-	virtual bool NeedsPrespecifiedDataLengths() const {return false;}
-	//! this function only needs to be called if NeedsPrespecifiedDataLengths() returns true
-	void SpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength=0);
-	//! encrypt and generate MAC in one call. will truncate MAC if macSize < TagSize()
-	virtual void EncryptAndAuthenticate(byte *ciphertext, byte *mac, size_t macSize, const byte *iv, int ivLength, const byte *header, size_t headerLength, const byte *message, size_t messageLength);
-	//! decrypt and verify MAC in one call, returning true iff MAC is valid. will assume MAC is truncated if macLength < TagSize()
-	virtual bool DecryptAndVerify(byte *message, const byte *mac, size_t macLength, const byte *iv, int ivLength, const byte *header, size_t headerLength, const byte *ciphertext, size_t ciphertextLength);
-
-	// redeclare this to avoid compiler ambiguity errors
-	virtual std::string AlgorithmName() const =0;
-
-protected:
-	const Algorithm & GetAlgorithm() const {return *static_cast<const MessageAuthenticationCode *>(this);}
-	virtual void UncheckedSpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength) {}
-};
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-typedef SymmetricCipher StreamCipher;
-#endif
-
-//! interface for random number generators
-/*! All return values are uniformly distributed over the range specified.
-*/
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE RandomNumberGenerator : public Algorithm
-{
-public:
-	//! update RNG state with additional unpredictable values
-	virtual void IncorporateEntropy(const byte *input, size_t length) {throw NotImplemented("RandomNumberGenerator: IncorporateEntropy not implemented");}
-
-	//! returns true if IncorporateEntropy is implemented
-	virtual bool CanIncorporateEntropy() const {return false;}
-
-	//! generate new random byte and return it
-	virtual byte GenerateByte();
-
-	//! generate new random bit and return it
-	/*! Default implementation is to call GenerateByte() and return its lowest bit. */
-	virtual unsigned int GenerateBit();
-
-	//! generate a random 32 bit word in the range min to max, inclusive
-	virtual word32 GenerateWord32(word32 a=0, word32 b=0xffffffffL);
-
-	//! generate random array of bytes
-	virtual void GenerateBlock(byte *output, size_t size);
-
-	//! generate and discard n bytes
-	virtual void DiscardBytes(size_t n);
-
-	//! generate random bytes as input to a BufferedTransformation
-	virtual void GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword length);
-
-	//! randomly shuffle the specified array, resulting permutation is uniformly distributed
-	template <class IT> void Shuffle(IT begin, IT end)
-	{
-		for (; begin != end; ++begin)
-			std::iter_swap(begin, begin + GenerateWord32(0, end-begin-1));
-	}
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-	byte GetByte() {return GenerateByte();}
-	unsigned int GetBit() {return GenerateBit();}
-	word32 GetLong(word32 a=0, word32 b=0xffffffffL) {return GenerateWord32(a, b);}
-	word16 GetShort(word16 a=0, word16 b=0xffff) {return (word16)GenerateWord32(a, b);}
-	void GetBlock(byte *output, size_t size) {GenerateBlock(output, size);}
-#endif
-};
-
-//! returns a reference that can be passed to functions that ask for a RNG but doesn't actually use it
-CRYPTOPP_DLL RandomNumberGenerator & CRYPTOPP_API NullRNG();
-
-class WaitObjectContainer;
-class CallStack;
-
-//! interface for objects that you can wait for
-
-class CRYPTOPP_NO_VTABLE Waitable
-{
-public:
-	virtual ~Waitable() {}
-
-	//! maximum number of wait objects that this object can return
-	virtual unsigned int GetMaxWaitObjectCount() const =0;
-	//! put wait objects into container
-	/*! \param callStack is used for tracing no wait loops, example:
-	             something.GetWaitObjects(c, CallStack("my func after X", 0));
-			   - or in an outer GetWaitObjects() method that itself takes a callStack parameter:
-			     innerThing.GetWaitObjects(c, CallStack("MyClass::GetWaitObjects at X", &callStack)); */
-	virtual void GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack) =0;
-	//! wait on this object
-	/*! same as creating an empty container, calling GetWaitObjects(), and calling Wait() on the container */
-	bool Wait(unsigned long milliseconds, CallStack const& callStack);
-};
-
-//! the default channel for BufferedTransformation, equal to the empty string
-extern CRYPTOPP_DLL const std::string DEFAULT_CHANNEL;
-
-//! channel for additional authenticated data, equal to "AAD"
-extern CRYPTOPP_DLL const std::string AAD_CHANNEL;
-
-//! interface for buffered transformations
-
-/*! BufferedTransformation is a generalization of BlockTransformation,
-	StreamTransformation, and HashTransformation.
-
-	A buffered transformation is an object that takes a stream of bytes
-	as input (this may be done in stages), does some computation on them, and
-	then places the result into an internal buffer for later retrieval.  Any
-	partial result already in the output buffer is not modified by further
-	input.
-
-	If a method takes a "blocking" parameter, and you
-	pass "false" for it, the method will return before all input has been processed if
-	the input cannot be processed without waiting (for network buffers to become available, for example).
-	In this case the method will return true
-	or a non-zero integer value. When this happens you must continue to call the method with the same
-	parameters until it returns false or zero, before calling any other method on it or
-	attached BufferedTransformation. The integer return value in this case is approximately
-	the number of bytes left to be processed, and can be used to implement a progress bar.
-
-	For functions that take a "propagation" parameter, propagation != 0 means pass on the signal to attached
-	BufferedTransformation objects, with propagation decremented at each step until it reaches 0.
-	-1 means unlimited propagation.
-
-	\nosubgrouping
-*/
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE BufferedTransformation : public Algorithm, public Waitable
-{
-public:
-	// placed up here for CW8
-	static const std::string &NULL_CHANNEL;	// same as DEFAULT_CHANNEL, for backwards compatibility
-
-	BufferedTransformation() : Algorithm(false) {}
-
-	//! return a reference to this object
-	/*! This function is useful for passing a temporary BufferedTransformation object to a 
-		function that takes a non-const reference. */
-	BufferedTransformation& Ref() {return *this;}
-
-	//!	\name INPUT
-	//@{
-		//! input a byte for processing
-		size_t Put(byte inByte, bool blocking=true)
-			{return Put(&inByte, 1, blocking);}
-		//! input multiple bytes
-		size_t Put(const byte *inString, size_t length, bool blocking=true)
-			{return Put2(inString, length, 0, blocking);}
-
-		//! input a 16-bit word
-		size_t PutWord16(word16 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);
-		//! input a 32-bit word
-		size_t PutWord32(word32 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);
-
-		//! request space which can be written into by the caller, and then used as input to Put()
-		/*! \param size is requested size (as a hint) for input, and size of the returned space for output */
-		/*! \note The purpose of this method is to help avoid doing extra memory allocations. */
-		virtual byte * CreatePutSpace(size_t &size) {size=0; return NULL;}
-
-		virtual bool CanModifyInput() const {return false;}
-
-		//! input multiple bytes that may be modified by callee
-		size_t PutModifiable(byte *inString, size_t length, bool blocking=true)
-			{return PutModifiable2(inString, length, 0, blocking);}
-
-		bool MessageEnd(int propagation=-1, bool blocking=true)
-			{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}
-		size_t PutMessageEnd(const byte *inString, size_t length, int propagation=-1, bool blocking=true)
-			{return Put2(inString, length, propagation < 0 ? -1 : propagation+1, blocking);}
-
-		//! input multiple bytes for blocking or non-blocking processing
-		/*! \param messageEnd means how many filters to signal MessageEnd to, including this one */
-		virtual size_t Put2(const byte *inString, size_t length, int messageEnd, bool blocking) =0;
-		//! input multiple bytes that may be modified by callee for blocking or non-blocking processing
-		/*! \param messageEnd means how many filters to signal MessageEnd to, including this one */
-		virtual size_t PutModifiable2(byte *inString, size_t length, int messageEnd, bool blocking)
-			{return Put2(inString, length, messageEnd, blocking);}
-
-		//! thrown by objects that have not implemented nonblocking input processing
-		struct BlockingInputOnly : public NotImplemented
-			{BlockingInputOnly(const std::string &s) : NotImplemented(s + ": Nonblocking input is not implemented by this object.") {}};
-	//@}
-
-	//!	\name WAITING
-	//@{
-		unsigned int GetMaxWaitObjectCount() const;
-		void GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack);
-	//@}
-
-	//!	\name SIGNALS
-	//@{
-		virtual void IsolatedInitialize(const NameValuePairs &parameters) {throw NotImplemented("BufferedTransformation: this object can't be reinitialized");}
-		virtual bool IsolatedFlush(bool hardFlush, bool blocking) =0;
-		virtual bool IsolatedMessageSeriesEnd(bool blocking) {return false;}
-
-		//! initialize or reinitialize this object
-		virtual void Initialize(const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1);
-		//! flush buffered input and/or output
-		/*! \param hardFlush is used to indicate whether all data should be flushed
-			\note Hard flushes must be used with care. It means try to process and output everything, even if
-			there may not be enough data to complete the action. For example, hard flushing a HexDecoder would
-			cause an error if you do it after inputing an odd number of hex encoded characters.
-			For some types of filters, for example ZlibDecompressor, hard flushes can only
-			be done at "synchronization points". These synchronization points are positions in the data
-			stream that are created by hard flushes on the corresponding reverse filters, in this
-			example ZlibCompressor. This is useful when zlib compressed data is moved across a
-			network in packets and compression state is preserved across packets, as in the ssh2 protocol.
-		*/
-		virtual bool Flush(bool hardFlush, int propagation=-1, bool blocking=true);
-		//! mark end of a series of messages
-		/*! There should be a MessageEnd immediately before MessageSeriesEnd. */
-		virtual bool MessageSeriesEnd(int propagation=-1, bool blocking=true);
-
-		//! set propagation of automatically generated and transferred signals
-		/*! propagation == 0 means do not automaticly generate signals */
-		virtual void SetAutoSignalPropagation(int propagation) {}
-
-		//!
-		virtual int GetAutoSignalPropagation() const {return 0;}
-public:
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-		void Close() {MessageEnd();}
-#endif
-	//@}
-
-	//!	\name RETRIEVAL OF ONE MESSAGE
-	//@{
-		//! returns number of bytes that is currently ready for retrieval
-		/*! All retrieval functions return the actual number of bytes
-			retrieved, which is the lesser of the request number and
-			MaxRetrievable(). */
-		virtual lword MaxRetrievable() const;
-
-		//! returns whether any bytes are currently ready for retrieval
-		virtual bool AnyRetrievable() const;
-
-		//! try to retrieve a single byte
-		virtual size_t Get(byte &outByte);
-		//! try to retrieve multiple bytes
-		virtual size_t Get(byte *outString, size_t getMax);
-
-		//! peek at the next byte without removing it from the output buffer
-		virtual size_t Peek(byte &outByte) const;
-		//! peek at multiple bytes without removing them from the output buffer
-		virtual size_t Peek(byte *outString, size_t peekMax) const;
-
-		//! try to retrieve a 16-bit word
-		size_t GetWord16(word16 &value, ByteOrder order=BIG_ENDIAN_ORDER);
-		//! try to retrieve a 32-bit word
-		size_t GetWord32(word32 &value, ByteOrder order=BIG_ENDIAN_ORDER);
-
-		//! try to peek at a 16-bit word
-		size_t PeekWord16(word16 &value, ByteOrder order=BIG_ENDIAN_ORDER) const;
-		//! try to peek at a 32-bit word
-		size_t PeekWord32(word32 &value, ByteOrder order=BIG_ENDIAN_ORDER) const;
-
-		//! move transferMax bytes of the buffered output to target as input
-		lword TransferTo(BufferedTransformation &target, lword transferMax=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL)
-			{TransferTo2(target, transferMax, channel); return transferMax;}
-
-		//! discard skipMax bytes from the output buffer
-		virtual lword Skip(lword skipMax=LWORD_MAX);
-
-		//! copy copyMax bytes of the buffered output to target as input
-		lword CopyTo(BufferedTransformation &target, lword copyMax=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL) const
-			{return CopyRangeTo(target, 0, copyMax, channel);}
-
-		//! copy copyMax bytes of the buffered output, starting at position (relative to current position), to target as input
-		lword CopyRangeTo(BufferedTransformation &target, lword position, lword copyMax=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL) const
-			{lword i = position; CopyRangeTo2(target, i, i+copyMax, channel); return i-position;}
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-		unsigned long MaxRetrieveable() const {return MaxRetrievable();}
-#endif
-	//@}
-
-	//!	\name RETRIEVAL OF MULTIPLE MESSAGES
-	//@{
-		//!
-		virtual lword TotalBytesRetrievable() const;
-		//! number of times MessageEnd() has been received minus messages retrieved or skipped
-		virtual unsigned int NumberOfMessages() const;
-		//! returns true if NumberOfMessages() > 0
-		virtual bool AnyMessages() const;
-		//! start retrieving the next message
-		/*!
-			Returns false if no more messages exist or this message 
-			is not completely retrieved.
-		*/
-		virtual bool GetNextMessage();
-		//! skip count number of messages
-		virtual unsigned int SkipMessages(unsigned int count=UINT_MAX);
-		//!
-		unsigned int TransferMessagesTo(BufferedTransformation &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL)
-			{TransferMessagesTo2(target, count, channel); return count;}
-		//!
-		unsigned int CopyMessagesTo(BufferedTransformation &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL) const;
-
-		//!
-		virtual void SkipAll();
-		//!
-		void TransferAllTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)
-			{TransferAllTo2(target, channel);}
-		//!
-		void CopyAllTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL) const;
-
-		virtual bool GetNextMessageSeries() {return false;}
-		virtual unsigned int NumberOfMessagesInThisSeries() const {return NumberOfMessages();}
-		virtual unsigned int NumberOfMessageSeries() const {return 0;}
-	//@}
-
-	//!	\name NON-BLOCKING TRANSFER OF OUTPUT
-	//@{
-		//! upon return, byteCount contains number of bytes that have finished being transfered, and returns the number of bytes left in the current transfer block
-		virtual size_t TransferTo2(BufferedTransformation &target, lword &byteCount, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) =0;
-		//! upon return, begin contains the start position of data yet to be finished copying, and returns the number of bytes left in the current transfer block
-		virtual size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const =0;
-		//! upon return, messageCount contains number of messages that have finished being transfered, and returns the number of bytes left in the current transfer block
-		size_t TransferMessagesTo2(BufferedTransformation &target, unsigned int &messageCount, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
-		//! returns the number of bytes left in the current transfer block
-		size_t TransferAllTo2(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
-	//@}
-
-	//!	\name CHANNELS
-	//@{
-		struct NoChannelSupport : public NotImplemented
-			{NoChannelSupport(const std::string &name) : NotImplemented(name + ": this object doesn't support multiple channels") {}};
-		struct InvalidChannelName : public InvalidArgument
-			{InvalidChannelName(const std::string &name, const std::string &channel) : InvalidArgument(name + ": unexpected channel name \"" + channel + "\"") {}};
-
-		size_t ChannelPut(const std::string &channel, byte inByte, bool blocking=true)
-			{return ChannelPut(channel, &inByte, 1, blocking);}
-		size_t ChannelPut(const std::string &channel, const byte *inString, size_t length, bool blocking=true)
-			{return ChannelPut2(channel, inString, length, 0, blocking);}
-
-		size_t ChannelPutModifiable(const std::string &channel, byte *inString, size_t length, bool blocking=true)
-			{return ChannelPutModifiable2(channel, inString, length, 0, blocking);}
-
-		size_t ChannelPutWord16(const std::string &channel, word16 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);
-		size_t ChannelPutWord32(const std::string &channel, word32 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);
-
-		bool ChannelMessageEnd(const std::string &channel, int propagation=-1, bool blocking=true)
-			{return !!ChannelPut2(channel, NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}
-		size_t ChannelPutMessageEnd(const std::string &channel, const byte *inString, size_t length, int propagation=-1, bool blocking=true)
-			{return ChannelPut2(channel, inString, length, propagation < 0 ? -1 : propagation+1, blocking);}
-
-		virtual byte * ChannelCreatePutSpace(const std::string &channel, size_t &size);
-
-		virtual size_t ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking);
-		virtual size_t ChannelPutModifiable2(const std::string &channel, byte *begin, size_t length, int messageEnd, bool blocking);
-
-		virtual bool ChannelFlush(const std::string &channel, bool hardFlush, int propagation=-1, bool blocking=true);
-		virtual bool ChannelMessageSeriesEnd(const std::string &channel, int propagation=-1, bool blocking=true);
-
-		virtual void SetRetrievalChannel(const std::string &channel);
-	//@}
-
-	//!	\name ATTACHMENT
-	/*! Some BufferedTransformation objects (e.g. Filter objects)
-		allow other BufferedTransformation objects to be attached. When
-		this is done, the first object instead of buffering its output,
-		sents that output to the attached object as input. The entire
-		attachment chain is deleted when the anchor object is destructed.
-	*/
-	//@{
-		//! returns whether this object allows attachment
-		virtual bool Attachable() {return false;}
-		//! returns the object immediately attached to this object or NULL for no attachment
-		virtual BufferedTransformation *AttachedTransformation() {assert(!Attachable()); return 0;}
-		//!
-		virtual const BufferedTransformation *AttachedTransformation() const
-			{return const_cast<BufferedTransformation *>(this)->AttachedTransformation();}
-		//! delete the current attachment chain and replace it with newAttachment
-		virtual void Detach(BufferedTransformation *newAttachment = 0)
-			{assert(!Attachable()); throw NotImplemented("BufferedTransformation: this object is not attachable");}
-		//! add newAttachment to the end of attachment chain
-		virtual void Attach(BufferedTransformation *newAttachment);
-	//@}
-
-protected:
-	static int DecrementPropagation(int propagation)
-		{return propagation != 0 ? propagation - 1 : 0;}
-
-private:
-	byte m_buf[4];	// for ChannelPutWord16 and ChannelPutWord32, to ensure buffer isn't deallocated before non-blocking operation completes
-};
-
-//! returns a reference to a BufferedTransformation object that discards all input
-BufferedTransformation & TheBitBucket();
-
-//! interface for crypto material, such as public and private keys, and crypto parameters
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CryptoMaterial : public NameValuePairs
-{
-public:
-	//! exception thrown when invalid crypto material is detected
-	class CRYPTOPP_DLL InvalidMaterial : public InvalidDataFormat
-	{
-	public:
-		explicit InvalidMaterial(const std::string &s) : InvalidDataFormat(s) {}
-	};
-
-	//! assign values from source to this object
-	/*! \note This function can be used to create a public key from a private key. */
-	virtual void AssignFrom(const NameValuePairs &source) =0;
-
-	//! check this object for errors
-	/*! \param level denotes the level of thoroughness:
-		0 - using this object won't cause a crash or exception (rng is ignored)
-		1 - this object will probably function (encrypt, sign, etc.) correctly (but may not check for weak keys and such)
-		2 - make sure this object will function correctly, and do reasonable security checks
-		3 - do checks that may take a long time
-		\return true if the tests pass */
-	virtual bool Validate(RandomNumberGenerator &rng, unsigned int level) const =0;
-
-	//! throws InvalidMaterial if this object fails Validate() test
-	virtual void ThrowIfInvalid(RandomNumberGenerator &rng, unsigned int level) const
-		{if (!Validate(rng, level)) throw InvalidMaterial("CryptoMaterial: this object contains invalid values");}
-
-//	virtual std::vector<std::string> GetSupportedFormats(bool includeSaveOnly=false, bool includeLoadOnly=false);
-
-	//! save key into a BufferedTransformation
-	virtual void Save(BufferedTransformation &bt) const
-		{throw NotImplemented("CryptoMaterial: this object does not support saving");}
-
-	//! load key from a BufferedTransformation
-	/*! \throws KeyingErr if decode fails
-		\note Generally does not check that the key is valid.
-			Call ValidateKey() or ThrowIfInvalidKey() to check that. */
-	virtual void Load(BufferedTransformation &bt)
-		{throw NotImplemented("CryptoMaterial: this object does not support loading");}
-
-	//! \return whether this object supports precomputation
-	virtual bool SupportsPrecomputation() const {return false;}
-	//! do precomputation
-	/*! The exact semantics of Precompute() is varies, but
-		typically it means calculate a table of n objects
-		that can be used later to speed up computation. */
-	virtual void Precompute(unsigned int n)
-		{assert(!SupportsPrecomputation()); throw NotImplemented("CryptoMaterial: this object does not support precomputation");}
-	//! retrieve previously saved precomputation
-	virtual void LoadPrecomputation(BufferedTransformation &storedPrecomputation)
-		{assert(!SupportsPrecomputation()); throw NotImplemented("CryptoMaterial: this object does not support precomputation");}
-	//! save precomputation for later use
-	virtual void SavePrecomputation(BufferedTransformation &storedPrecomputation) const
-		{assert(!SupportsPrecomputation()); throw NotImplemented("CryptoMaterial: this object does not support precomputation");}
-
-	// for internal library use
-	void DoQuickSanityCheck() const	{ThrowIfInvalid(NullRNG(), 0);}
-
-#if (defined(__SUNPRO_CC) && __SUNPRO_CC < 0x590)
-	// Sun Studio 11/CC 5.8 workaround: it generates incorrect code when casting to an empty virtual base class
-	char m_sunCCworkaround;
-#endif
-};
-
-//! interface for generatable crypto material, such as private keys and crypto parameters
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE GeneratableCryptoMaterial : virtual public CryptoMaterial
-{
-public:
-	//! generate a random key or crypto parameters
-	/*! \throws KeyingErr if algorithm parameters are invalid, or if a key can't be generated
-		(e.g., if this is a public key object) */
-	virtual void GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &params = g_nullNameValuePairs)
-		{throw NotImplemented("GeneratableCryptoMaterial: this object does not support key/parameter generation");}
-
-	//! calls the above function with a NameValuePairs object that just specifies "KeySize"
-	void GenerateRandomWithKeySize(RandomNumberGenerator &rng, unsigned int keySize);
-};
-
-//! interface for public keys
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PublicKey : virtual public CryptoMaterial
-{
-};
-
-//! interface for private keys
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PrivateKey : public GeneratableCryptoMaterial
-{
-};
-
-//! interface for crypto prameters
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CryptoParameters : public GeneratableCryptoMaterial
-{
-};
-
-//! interface for asymmetric algorithms
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE AsymmetricAlgorithm : public Algorithm
-{
-public:
-	//! returns a reference to the crypto material used by this object
-	virtual CryptoMaterial & AccessMaterial() =0;
-	//! returns a const reference to the crypto material used by this object
-	virtual const CryptoMaterial & GetMaterial() const =0;
-
-	//! for backwards compatibility, calls AccessMaterial().Load(bt)
-	void BERDecode(BufferedTransformation &bt)
-		{AccessMaterial().Load(bt);}
-	//! for backwards compatibility, calls GetMaterial().Save(bt)
-	void DEREncode(BufferedTransformation &bt) const
-		{GetMaterial().Save(bt);}
-};
-
-//! interface for asymmetric algorithms using public keys
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PublicKeyAlgorithm : public AsymmetricAlgorithm
-{
-public:
-	// VC60 workaround: no co-variant return type
-	CryptoMaterial & AccessMaterial() {return AccessPublicKey();}
-	const CryptoMaterial & GetMaterial() const {return GetPublicKey();}
-
-	virtual PublicKey & AccessPublicKey() =0;
-	virtual const PublicKey & GetPublicKey() const {return const_cast<PublicKeyAlgorithm *>(this)->AccessPublicKey();}
-};
-
-//! interface for asymmetric algorithms using private keys
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PrivateKeyAlgorithm : public AsymmetricAlgorithm
-{
-public:
-	CryptoMaterial & AccessMaterial() {return AccessPrivateKey();}
-	const CryptoMaterial & GetMaterial() const {return GetPrivateKey();}
-
-	virtual PrivateKey & AccessPrivateKey() =0;
-	virtual const PrivateKey & GetPrivateKey() const {return const_cast<PrivateKeyAlgorithm *>(this)->AccessPrivateKey();}
-};
-
-//! interface for key agreement algorithms
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE KeyAgreementAlgorithm : public AsymmetricAlgorithm
-{
-public:
-	CryptoMaterial & AccessMaterial() {return AccessCryptoParameters();}
-	const CryptoMaterial & GetMaterial() const {return GetCryptoParameters();}
-
-	virtual CryptoParameters & AccessCryptoParameters() =0;
-	virtual const CryptoParameters & GetCryptoParameters() const {return const_cast<KeyAgreementAlgorithm *>(this)->AccessCryptoParameters();}
-};
-
-//! interface for public-key encryptors and decryptors
-
-/*! This class provides an interface common to encryptors and decryptors
-	for querying their plaintext and ciphertext lengths.
-*/
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_CryptoSystem
-{
-public:
-	virtual ~PK_CryptoSystem() {}
-
-	//! maximum length of plaintext for a given ciphertext length
-	/*! \note This function returns 0 if ciphertextLength is not valid (too long or too short). */
-	virtual size_t MaxPlaintextLength(size_t ciphertextLength) const =0;
-
-	//! calculate length of ciphertext given length of plaintext
-	/*! \note This function returns 0 if plaintextLength is not valid (too long). */
-	virtual size_t CiphertextLength(size_t plaintextLength) const =0;
-
-	//! this object supports the use of the parameter with the given name
-	/*! some possible parameter names: EncodingParameters, KeyDerivationParameters */
-	virtual bool ParameterSupported(const char *name) const =0;
-
-	//! return fixed ciphertext length, if one exists, otherwise return 0
-	/*! \note "Fixed" here means length of ciphertext does not depend on length of plaintext.
-		It usually does depend on the key length. */
-	virtual size_t FixedCiphertextLength() const {return 0;}
-
-	//! return maximum plaintext length given the fixed ciphertext length, if one exists, otherwise return 0
-	virtual size_t FixedMaxPlaintextLength() const {return 0;}
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-	size_t MaxPlainTextLength(size_t cipherTextLength) const {return MaxPlaintextLength(cipherTextLength);}
-	size_t CipherTextLength(size_t plainTextLength) const {return CiphertextLength(plainTextLength);}
-#endif
-};
-
-//! interface for public-key encryptors
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_Encryptor : public PK_CryptoSystem, public PublicKeyAlgorithm
-{
-public:
-	//! exception thrown when trying to encrypt plaintext of invalid length
-	class CRYPTOPP_DLL InvalidPlaintextLength : public Exception
-	{
-	public:
-		InvalidPlaintextLength() : Exception(OTHER_ERROR, "PK_Encryptor: invalid plaintext length") {}
-	};
-
-	//! encrypt a byte string
-	/*! \pre CiphertextLength(plaintextLength) != 0 (i.e., plaintext isn't too long)
-		\pre size of ciphertext == CiphertextLength(plaintextLength)
-	*/
-	virtual void Encrypt(RandomNumberGenerator &rng, 
-		const byte *plaintext, size_t plaintextLength, 
-		byte *ciphertext, const NameValuePairs &parameters = g_nullNameValuePairs) const =0;
-
-	//! create a new encryption filter
-	/*! \note The caller is responsible for deleting the returned pointer.
-		\note Encoding parameters should be passed in the "EP" channel.
-	*/
-	virtual BufferedTransformation * CreateEncryptionFilter(RandomNumberGenerator &rng, 
-		BufferedTransformation *attachment=NULL, const NameValuePairs &parameters = g_nullNameValuePairs) const;
-};
-
-//! interface for public-key decryptors
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_Decryptor : public PK_CryptoSystem, public PrivateKeyAlgorithm
-{
-public:
-	//! decrypt a byte string, and return the length of plaintext
-	/*! \pre size of plaintext == MaxPlaintextLength(ciphertextLength) bytes.
-		\return the actual length of the plaintext, indication that decryption failed.
-	*/
-	virtual DecodingResult Decrypt(RandomNumberGenerator &rng, 
-		const byte *ciphertext, size_t ciphertextLength, 
-		byte *plaintext, const NameValuePairs &parameters = g_nullNameValuePairs) const =0;
-
-	//! create a new decryption filter
-	/*! \note caller is responsible for deleting the returned pointer
-	*/
-	virtual BufferedTransformation * CreateDecryptionFilter(RandomNumberGenerator &rng, 
-		BufferedTransformation *attachment=NULL, const NameValuePairs &parameters = g_nullNameValuePairs) const;
-
-	//! decrypt a fixed size ciphertext
-	DecodingResult FixedLengthDecrypt(RandomNumberGenerator &rng, const byte *ciphertext, byte *plaintext, const NameValuePairs &parameters = g_nullNameValuePairs) const
-		{return Decrypt(rng, ciphertext, FixedCiphertextLength(), plaintext, parameters);}
-};
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-typedef PK_CryptoSystem PK_FixedLengthCryptoSystem;
-typedef PK_Encryptor PK_FixedLengthEncryptor;
-typedef PK_Decryptor PK_FixedLengthDecryptor;
-#endif
-
-//! interface for public-key signers and verifiers
-
-/*! This class provides an interface common to signers and verifiers
-	for querying scheme properties.
-*/
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_SignatureScheme
-{
-public:
-	//! invalid key exception, may be thrown by any function in this class if the private or public key has a length that can't be used
-	class CRYPTOPP_DLL InvalidKeyLength : public Exception
-	{
-	public:
-		InvalidKeyLength(const std::string &message) : Exception(OTHER_ERROR, message) {}
-	};
-
-	//! key too short exception, may be thrown by any function in this class if the private or public key is too short to sign or verify anything
-	class CRYPTOPP_DLL KeyTooShort : public InvalidKeyLength
-	{
-	public:
-		KeyTooShort() : InvalidKeyLength("PK_Signer: key too short for this signature scheme") {}
-	};
-
-	virtual ~PK_SignatureScheme() {}
-
-	//! signature length if it only depends on the key, otherwise 0
-	virtual size_t SignatureLength() const =0;
-
-	//! maximum signature length produced for a given length of recoverable message part
-	virtual size_t MaxSignatureLength(size_t recoverablePartLength = 0) const {return SignatureLength();}
-
-	//! length of longest message that can be recovered, or 0 if this signature scheme does not support message recovery
-	virtual size_t MaxRecoverableLength() const =0;
-
-	//! length of longest message that can be recovered from a signature of given length, or 0 if this signature scheme does not support message recovery
-	virtual size_t MaxRecoverableLengthFromSignatureLength(size_t signatureLength) const =0;
-
-	//! requires a random number generator to sign
-	/*! if this returns false, NullRNG() can be passed to functions that take RandomNumberGenerator & */
-	virtual bool IsProbabilistic() const =0;
-
-	//! whether or not a non-recoverable message part can be signed
-	virtual bool AllowNonrecoverablePart() const =0;
-
-	//! if this function returns true, during verification you must input the signature before the message, otherwise you can input it at anytime */
-	virtual bool SignatureUpfront() const {return false;}
-
-	//! whether you must input the recoverable part before the non-recoverable part during signing
-	virtual bool RecoverablePartFirst() const =0;
-};
-
-//! interface for accumulating messages to be signed or verified
-/*! Only Update() should be called
-	on this class. No other functions inherited from HashTransformation should be called.
-*/
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_MessageAccumulator : public HashTransformation
-{
-public:
-	//! should not be called on PK_MessageAccumulator
-	unsigned int DigestSize() const
-		{throw NotImplemented("PK_MessageAccumulator: DigestSize() should not be called");}
-	//! should not be called on PK_MessageAccumulator
-	void TruncatedFinal(byte *digest, size_t digestSize) 
-		{throw NotImplemented("PK_MessageAccumulator: TruncatedFinal() should not be called");}
-};
-
-//! interface for public-key signers
-
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_Signer : public PK_SignatureScheme, public PrivateKeyAlgorithm
-{
-public:
-	//! create a new HashTransformation to accumulate the message to be signed
-	virtual PK_MessageAccumulator * NewSignatureAccumulator(RandomNumberGenerator &rng) const =0;
-
-	virtual void InputRecoverableMessage(PK_MessageAccumulator &messageAccumulator, const byte *recoverableMessage, size_t recoverableMessageLength) const =0;
-
-	//! sign and delete messageAccumulator (even in case of exception thrown)
-	/*! \pre size of signature == MaxSignatureLength()
-		\return actual signature length
-	*/
-	virtual size_t Sign(RandomNumberGenerator &rng, PK_MessageAccumulator *messageAccumulator, byte *signature) const;
-
-	//! sign and restart messageAccumulator
-	/*! \pre size of signature == MaxSignatureLength()
-		\return actual signature length
-	*/
-	virtual size_t SignAndRestart(RandomNumberGenerator &rng, PK_MessageAccumulator &messageAccumulator, byte *signature, bool restart=true) const =0;
-
-	//! sign a message
-	/*! \pre size of signature == MaxSignatureLength()
-		\return actual signature length
-	*/
-	virtual size_t SignMessage(RandomNumberGenerator &rng, const byte *message, size_t messageLen, byte *signature) const;
-
-	//! sign a recoverable message
-	/*! \pre size of signature == MaxSignatureLength(recoverableMessageLength)
-		\return actual signature length
-	*/
-	virtual size_t SignMessageWithRecovery(RandomNumberGenerator &rng, const byte *recoverableMessage, size_t recoverableMessageLength, 
-		const byte *nonrecoverableMessage, size_t nonrecoverableMessageLength, byte *signature) const;
-};
-
-//! interface for public-key signature verifiers
-/*! The Recover* functions throw NotImplemented if the signature scheme does not support
-	message recovery.
-	The Verify* functions throw InvalidDataFormat if the scheme does support message
-	recovery and the signature contains a non-empty recoverable message part. The
-	Recovery* functions should be used in that case.
-*/
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_Verifier : public PK_SignatureScheme, public PublicKeyAlgorithm
-{
-public:
-	//! create a new HashTransformation to accumulate the message to be verified
-	virtual PK_MessageAccumulator * NewVerificationAccumulator() const =0;
-
-	//! input signature into a message accumulator
-	virtual void InputSignature(PK_MessageAccumulator &messageAccumulator, const byte *signature, size_t signatureLength) const =0;
-
-	//! check whether messageAccumulator contains a valid signature and message, and delete messageAccumulator (even in case of exception thrown)
-	virtual bool Verify(PK_MessageAccumulator *messageAccumulator) const;
-
-	//! check whether messageAccumulator contains a valid signature and message, and restart messageAccumulator
-	virtual bool VerifyAndRestart(PK_MessageAccumulator &messageAccumulator) const =0;
-
-	//! check whether input signature is a valid signature for input message
-	virtual bool VerifyMessage(const byte *message, size_t messageLen, 
-		const byte *signature, size_t signatureLength) const;
-
-	//! recover a message from its signature
-	/*! \pre size of recoveredMessage == MaxRecoverableLengthFromSignatureLength(signatureLength)
-	*/
-	virtual DecodingResult Recover(byte *recoveredMessage, PK_MessageAccumulator *messageAccumulator) const;
-
-	//! recover a message from its signature
-	/*! \pre size of recoveredMessage == MaxRecoverableLengthFromSignatureLength(signatureLength)
-	*/
-	virtual DecodingResult RecoverAndRestart(byte *recoveredMessage, PK_MessageAccumulator &messageAccumulator) const =0;
-
-	//! recover a message from its signature
-	/*! \pre size of recoveredMessage == MaxRecoverableLengthFromSignatureLength(signatureLength)
-	*/
-	virtual DecodingResult RecoverMessage(byte *recoveredMessage, 
-		const byte *nonrecoverableMessage, size_t nonrecoverableMessageLength, 
-		const byte *signature, size_t signatureLength) const;
-};
-
-//! interface for domains of simple key agreement protocols
-
-/*! A key agreement domain is a set of parameters that must be shared
-	by two parties in a key agreement protocol, along with the algorithms
-	for generating key pairs and deriving agreed values.
-*/
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE SimpleKeyAgreementDomain : public KeyAgreementAlgorithm
-{
-public:
-	//! return length of agreed value produced
-	virtual unsigned int AgreedValueLength() const =0;
-	//! return length of private keys in this domain
-	virtual unsigned int PrivateKeyLength() const =0;
-	//! return length of public keys in this domain
-	virtual unsigned int PublicKeyLength() const =0;
-	//! generate private key
-	/*! \pre size of privateKey == PrivateKeyLength() */
-	virtual void GeneratePrivateKey(RandomNumberGenerator &rng, byte *privateKey) const =0;
-	//! generate public key
-	/*!	\pre size of publicKey == PublicKeyLength() */
-	virtual void GeneratePublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const =0;
-	//! generate private/public key pair
-	/*! \note equivalent to calling GeneratePrivateKey() and then GeneratePublicKey() */
-	virtual void GenerateKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const;
-	//! derive agreed value from your private key and couterparty's public key, return false in case of failure
-	/*! \note If you have previously validated the public key, use validateOtherPublicKey=false to save time.
-		\pre size of agreedValue == AgreedValueLength()
-		\pre length of privateKey == PrivateKeyLength()
-		\pre length of otherPublicKey == PublicKeyLength()
-	*/
-	virtual bool Agree(byte *agreedValue, const byte *privateKey, const byte *otherPublicKey, bool validateOtherPublicKey=true) const =0;
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-	bool ValidateDomainParameters(RandomNumberGenerator &rng) const
-		{return GetCryptoParameters().Validate(rng, 2);}
-#endif
-};
-
-//! interface for domains of authenticated key agreement protocols
-
-/*! In an authenticated key agreement protocol, each party has two
-	key pairs. The long-lived key pair is called the static key pair,
-	and the short-lived key pair is called the ephemeral key pair.
-*/
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE AuthenticatedKeyAgreementDomain : public KeyAgreementAlgorithm
-{
-public:
-	//! return length of agreed value produced
-	virtual unsigned int AgreedValueLength() const =0;
-
-	//! return length of static private keys in this domain
-	virtual unsigned int StaticPrivateKeyLength() const =0;
-	//! return length of static public keys in this domain
-	virtual unsigned int StaticPublicKeyLength() const =0;
-	//! generate static private key
-	/*! \pre size of privateKey == PrivateStaticKeyLength() */
-	virtual void GenerateStaticPrivateKey(RandomNumberGenerator &rng, byte *privateKey) const =0;
-	//! generate static public key
-	/*!	\pre size of publicKey == PublicStaticKeyLength() */
-	virtual void GenerateStaticPublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const =0;
-	//! generate private/public key pair
-	/*! \note equivalent to calling GenerateStaticPrivateKey() and then GenerateStaticPublicKey() */
-	virtual void GenerateStaticKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const;
-
-	//! return length of ephemeral private keys in this domain
-	virtual unsigned int EphemeralPrivateKeyLength() const =0;
-	//! return length of ephemeral public keys in this domain
-	virtual unsigned int EphemeralPublicKeyLength() const =0;
-	//! generate ephemeral private key
-	/*! \pre size of privateKey == PrivateEphemeralKeyLength() */
-	virtual void GenerateEphemeralPrivateKey(RandomNumberGenerator &rng, byte *privateKey) const =0;
-	//! generate ephemeral public key
-	/*!	\pre size of publicKey == PublicEphemeralKeyLength() */
-	virtual void GenerateEphemeralPublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const =0;
-	//! generate private/public key pair
-	/*! \note equivalent to calling GenerateEphemeralPrivateKey() and then GenerateEphemeralPublicKey() */
-	virtual void GenerateEphemeralKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const;
-
-	//! derive agreed value from your private keys and couterparty's public keys, return false in case of failure
-	/*! \note The ephemeral public key will always be validated.
-		      If you have previously validated the static public key, use validateStaticOtherPublicKey=false to save time.
-		\pre size of agreedValue == AgreedValueLength()
-		\pre length of staticPrivateKey == StaticPrivateKeyLength()
-		\pre length of ephemeralPrivateKey == EphemeralPrivateKeyLength()
-		\pre length of staticOtherPublicKey == StaticPublicKeyLength()
-		\pre length of ephemeralOtherPublicKey == EphemeralPublicKeyLength()
-	*/
-	virtual bool Agree(byte *agreedValue,
-		const byte *staticPrivateKey, const byte *ephemeralPrivateKey,
-		const byte *staticOtherPublicKey, const byte *ephemeralOtherPublicKey,
-		bool validateStaticOtherPublicKey=true) const =0;
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-	bool ValidateDomainParameters(RandomNumberGenerator &rng) const
-		{return GetCryptoParameters().Validate(rng, 2);}
-#endif
-};
-
-// interface for password authenticated key agreement protocols, not implemented yet
-#if 0
-//! interface for protocol sessions
-/*! The methods should be called in the following order:
-
-	InitializeSession(rng, parameters);	// or call initialize method in derived class
-	while (true)
-	{
-		if (OutgoingMessageAvailable())
-		{
-			length = GetOutgoingMessageLength();
-			GetOutgoingMessage(message);
-			; // send outgoing message
-		}
-
-		if (LastMessageProcessed())
-			break;
-
-		; // receive incoming message
-		ProcessIncomingMessage(message);
-	}
-	; // call methods in derived class to obtain result of protocol session
-*/
-class ProtocolSession
-{
-public:
-	//! exception thrown when an invalid protocol message is processed
-	class ProtocolError : public Exception
-	{
-	public:
-		ProtocolError(ErrorType errorType, const std::string &s) : Exception(errorType, s) {}
-	};
-
-	//! exception thrown when a function is called unexpectedly
-	/*! for example calling ProcessIncomingMessage() when ProcessedLastMessage() == true */
-	class UnexpectedMethodCall : public Exception
-	{
-	public:
-		UnexpectedMethodCall(const std::string &s) : Exception(OTHER_ERROR, s) {}
-	};
-
-	ProtocolSession() : m_rng(NULL), m_throwOnProtocolError(true), m_validState(false) {}
-	virtual ~ProtocolSession() {}
-
-	virtual void InitializeSession(RandomNumberGenerator &rng, const NameValuePairs &parameters) =0;
-
-	bool GetThrowOnProtocolError() const {return m_throwOnProtocolError;}
-	void SetThrowOnProtocolError(bool throwOnProtocolError) {m_throwOnProtocolError = throwOnProtocolError;}
-
-	bool HasValidState() const {return m_validState;}
-
-	virtual bool OutgoingMessageAvailable() const =0;
-	virtual unsigned int GetOutgoingMessageLength() const =0;
-	virtual void GetOutgoingMessage(byte *message) =0;
-
-	virtual bool LastMessageProcessed() const =0;
-	virtual void ProcessIncomingMessage(const byte *message, unsigned int messageLength) =0;
-
-protected:
-	void HandleProtocolError(Exception::ErrorType errorType, const std::string &s) const;
-	void CheckAndHandleInvalidState() const;
-	void SetValidState(bool valid) {m_validState = valid;}
-
-	RandomNumberGenerator *m_rng;
-
-private:
-	bool m_throwOnProtocolError, m_validState;
-};
-
-class KeyAgreementSession : public ProtocolSession
-{
-public:
-	virtual unsigned int GetAgreedValueLength() const =0;
-	virtual void GetAgreedValue(byte *agreedValue) const =0;
-};
-
-class PasswordAuthenticatedKeyAgreementSession : public KeyAgreementSession
-{
-public:
-	void InitializePasswordAuthenticatedKeyAgreementSession(RandomNumberGenerator &rng, 
-		const byte *myId, unsigned int myIdLength, 
-		const byte *counterPartyId, unsigned int counterPartyIdLength, 
-		const byte *passwordOrVerifier, unsigned int passwordOrVerifierLength);
-};
-
-class PasswordAuthenticatedKeyAgreementDomain : public KeyAgreementAlgorithm
-{
-public:
-	//! return whether the domain parameters stored in this object are valid
-	virtual bool ValidateDomainParameters(RandomNumberGenerator &rng) const
-		{return GetCryptoParameters().Validate(rng, 2);}
-
-	virtual unsigned int GetPasswordVerifierLength(const byte *password, unsigned int passwordLength) const =0;
-	virtual void GeneratePasswordVerifier(RandomNumberGenerator &rng, const byte *userId, unsigned int userIdLength, const byte *password, unsigned int passwordLength, byte *verifier) const =0;
-
-	enum RoleFlags {CLIENT=1, SERVER=2, INITIATOR=4, RESPONDER=8};
-
-	virtual bool IsValidRole(unsigned int role) =0;
-	virtual PasswordAuthenticatedKeyAgreementSession * CreateProtocolSession(unsigned int role) const =0;
-};
-#endif
-
-//! BER Decode Exception Class, may be thrown during an ASN1 BER decode operation
-class CRYPTOPP_DLL BERDecodeErr : public InvalidArgument
-{
-public: 
-	BERDecodeErr() : InvalidArgument("BER decode error") {}
-	BERDecodeErr(const std::string &s) : InvalidArgument(s) {}
-};
-
-//! interface for encoding and decoding ASN1 objects
-class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE ASN1Object
-{
-public:
-	virtual ~ASN1Object() {}
-	//! decode this object from a BufferedTransformation, using BER (Basic Encoding Rules)
-	virtual void BERDecode(BufferedTransformation &bt) =0;
-	//! encode this object into a BufferedTransformation, using DER (Distinguished Encoding Rules)
-	virtual void DEREncode(BufferedTransformation &bt) const =0;
-	//! encode this object into a BufferedTransformation, using BER
-	/*! this may be useful if DEREncode() would be too inefficient */
-	virtual void BEREncode(BufferedTransformation &bt) const {DEREncode(bt);}
-};
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-typedef PK_SignatureScheme PK_SignatureSystem;
-typedef SimpleKeyAgreementDomain PK_SimpleKeyAgreementDomain;
-typedef AuthenticatedKeyAgreementDomain PK_AuthenticatedKeyAgreementDomain;
-#endif
-
-NAMESPACE_END
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/iterhash.h bitcoin-0.3.20/src/cryptopp/iterhash.h
--- bitcoin-0.3.20.orig/src/cryptopp/iterhash.h	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/iterhash.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
-#ifndef CRYPTOPP_ITERHASH_H
-#define CRYPTOPP_ITERHASH_H
-
-#include "secblock.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-// *** trimmed down dependency from iterhash.h ***
-template <class T_HashWordType, class T_Endianness, unsigned int T_BlockSize, unsigned int T_StateSize, class T_Transform, unsigned int T_DigestSize = 0, bool T_StateAligned = false>
-class CRYPTOPP_NO_VTABLE IteratedHashWithStaticTransform
-{
-public:
-	CRYPTOPP_CONSTANT(DIGESTSIZE = T_DigestSize ? T_DigestSize : T_StateSize)
-	unsigned int DigestSize() const {return DIGESTSIZE;};
-    typedef T_HashWordType HashWordType;
-    CRYPTOPP_CONSTANT(BLOCKSIZE = T_BlockSize)
-
-protected:
-	IteratedHashWithStaticTransform() {this->Init();}
-	void HashEndianCorrectedBlock(const T_HashWordType *data) {T_Transform::Transform(this->m_state, data);}
-	void Init() {T_Transform::InitState(this->m_state);}
-
-	T_HashWordType* StateBuf() {return this->m_state;}
-	FixedSizeAlignedSecBlock<T_HashWordType, T_BlockSize/sizeof(T_HashWordType), T_StateAligned> m_state;
-};
-
-NAMESPACE_END
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/License.txt bitcoin-0.3.20/src/cryptopp/License.txt
--- bitcoin-0.3.20.orig/src/cryptopp/License.txt	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/License.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-Compilation Copyright (c) 1995-2009 by Wei Dai.  All rights reserved.
-This copyright applies only to this software distribution package 
-as a compilation, and does not imply a copyright on any particular 
-file in the package.
-
-The following files are copyrighted by their respective original authors,
-and their use is subject to additional licenses included in these files.
-
-mars.cpp - Copyright 1998 Brian Gladman.
-
-All other files in this compilation are placed in the public domain by
-Wei Dai and other contributors.
-
-I would like to thank the following authors for placing their works into
-the public domain:
-
-Joan Daemen - 3way.cpp
-Leonard Janke - cast.cpp, seal.cpp
-Steve Reid - cast.cpp
-Phil Karn - des.cpp
-Andrew M. Kuchling - md2.cpp, md4.cpp
-Colin Plumb - md5.cpp
-Seal Woods - rc6.cpp
-Chris Morgan - rijndael.cpp
-Paulo Baretto - rijndael.cpp, skipjack.cpp, square.cpp
-Richard De Moliner - safer.cpp
-Matthew Skala - twofish.cpp
-Kevin Springle - camellia.cpp, shacal2.cpp, ttmac.cpp, whrlpool.cpp, ripemd.cpp
-
-Permission to use, copy, modify, and distribute this compilation for
-any purpose, including commercial applications, is hereby granted
-without fee, subject to the following restrictions:
-
-1. Any copy or modification of this compilation in any form, except
-in object code form as part of an application software, must include
-the above copyright notice and this license.
-
-2. Users of this software agree that any modification or extension
-they provide to Wei Dai will be considered public domain and not
-copyrighted unless it includes an explicit copyright notice.
-
-3. Wei Dai makes no warranty or representation that the operation of the
-software in this compilation will be error-free, and Wei Dai is under no
-obligation to provide any services, by way of maintenance, update, or
-otherwise.  THE SOFTWARE AND ANY DOCUMENTATION ARE PROVIDED "AS IS"
-WITHOUT EXPRESS OR IMPLIED WARRANTY INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE. IN NO EVENT WILL WEI DAI OR ANY OTHER CONTRIBUTOR BE LIABLE FOR
-DIRECT, INCIDENTAL OR CONSEQUENTIAL DAMAGES, EVEN IF
-ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
-
-4. Users will not use Wei Dai or any other contributor's name in any 
-publicity or advertising, without prior written consent in each case.
-
-5. Export of this software from the United States may require a
-specific license from the United States Government.  It is the
-responsibility of any person or organization contemplating export
-to obtain such a license before exporting.
-
-6. Certain parts of this software may be protected by patents.  It
-is the users' responsibility to obtain the appropriate
-licenses before using those parts.
-
-If this compilation is used in object code form in an application
-software, acknowledgement of the author is not required but would be
-appreciated. The contribution of any useful modifications or extensions
-to Wei Dai is not required but would also be appreciated.
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/misc.h bitcoin-0.3.20/src/cryptopp/misc.h
--- bitcoin-0.3.20.orig/src/cryptopp/misc.h	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/misc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,1134 +0,0 @@
-#ifndef CRYPTOPP_MISC_H
-#define CRYPTOPP_MISC_H
-
-#include "cryptlib.h"
-#include "smartptr.h"
-#include <string.h>		// for memcpy and memmove
-
-#ifdef _MSC_VER
-	#include <stdlib.h>
-	#if _MSC_VER >= 1400
-		// VC2005 workaround: disable declarations that conflict with winnt.h
-		#define _interlockedbittestandset CRYPTOPP_DISABLED_INTRINSIC_1
-		#define _interlockedbittestandreset CRYPTOPP_DISABLED_INTRINSIC_2
-		#define _interlockedbittestandset64 CRYPTOPP_DISABLED_INTRINSIC_3
-		#define _interlockedbittestandreset64 CRYPTOPP_DISABLED_INTRINSIC_4
-		#include <intrin.h>
-		#undef _interlockedbittestandset
-		#undef _interlockedbittestandreset
-		#undef _interlockedbittestandset64
-		#undef _interlockedbittestandreset64
-		#define CRYPTOPP_FAST_ROTATE(x) 1
-	#elif _MSC_VER >= 1300
-		#define CRYPTOPP_FAST_ROTATE(x) ((x) == 32 | (x) == 64)
-	#else
-		#define CRYPTOPP_FAST_ROTATE(x) ((x) == 32)
-	#endif
-#elif (defined(__MWERKS__) && TARGET_CPU_PPC) || \
-	(defined(__GNUC__) && (defined(_ARCH_PWR2) || defined(_ARCH_PWR) || defined(_ARCH_PPC) || defined(_ARCH_PPC64) || defined(_ARCH_COM)))
-	#define CRYPTOPP_FAST_ROTATE(x) ((x) == 32)
-#elif defined(__GNUC__) && (CRYPTOPP_BOOL_X64 || CRYPTOPP_BOOL_X86)	// depend on GCC's peephole optimization to generate rotate instructions
-	#define CRYPTOPP_FAST_ROTATE(x) 1
-#else
-	#define CRYPTOPP_FAST_ROTATE(x) 0
-#endif
-
-#ifdef __BORLANDC__
-#include <mem.h>
-#endif
-
-#if defined(__GNUC__) && defined(__linux__)
-#define CRYPTOPP_BYTESWAP_AVAILABLE
-#include <byteswap.h>
-#endif
-
-NAMESPACE_BEGIN(CryptoPP)
-
-// ************** compile-time assertion ***************
-
-template <bool b>
-struct CompileAssert
-{
-	static char dummy[2*b-1];
-};
-
-#define CRYPTOPP_COMPILE_ASSERT(assertion) CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, __LINE__)
-#if defined(CRYPTOPP_EXPORTS) || defined(CRYPTOPP_IMPORTS)
-#define CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, instance)
-#else
-#define CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, instance) static CompileAssert<(assertion)> CRYPTOPP_ASSERT_JOIN(cryptopp_assert_, instance)
-#endif
-#define CRYPTOPP_ASSERT_JOIN(X, Y) CRYPTOPP_DO_ASSERT_JOIN(X, Y)
-#define CRYPTOPP_DO_ASSERT_JOIN(X, Y) X##Y
-
-// ************** misc classes ***************
-
-class CRYPTOPP_DLL Empty
-{
-};
-
-//! _
-template <class BASE1, class BASE2>
-class CRYPTOPP_NO_VTABLE TwoBases : public BASE1, public BASE2
-{
-};
-
-//! _
-template <class BASE1, class BASE2, class BASE3>
-class CRYPTOPP_NO_VTABLE ThreeBases : public BASE1, public BASE2, public BASE3
-{
-};
-
-template <class T>
-class ObjectHolder
-{
-protected:
-	T m_object;
-};
-
-class NotCopyable
-{
-public:
-	NotCopyable() {}
-private:
-    NotCopyable(const NotCopyable &);
-    void operator=(const NotCopyable &);
-};
-
-template <class T>
-struct NewObject
-{
-	T* operator()() const {return new T;}
-};
-
-/*! This function safely initializes a static object in a multithreaded environment without using locks.
-	It may leak memory when two threads try to initialize the static object at the same time
-	but this should be acceptable since each static object is only initialized once per session.
-*/
-template <class T, class F = NewObject<T>, int instance=0>
-class Singleton
-{
-public:
-	Singleton(F objectFactory = F()) : m_objectFactory(objectFactory) {}
-
-	// prevent this function from being inlined
-	CRYPTOPP_NOINLINE const T & Ref(CRYPTOPP_NOINLINE_DOTDOTDOT) const;
-
-private:
-	F m_objectFactory;
-};
-
-template <class T, class F, int instance>
-const T & Singleton<T, F, instance>::Ref(CRYPTOPP_NOINLINE_DOTDOTDOT) const
-{
-	static simple_ptr<T> s_pObject;
-	static char s_objectState = 0;
-
-retry:
-	switch (s_objectState)
-	{
-	case 0:
-		s_objectState = 1;
-		try
-		{
-			s_pObject.m_p = m_objectFactory();
-		}
-		catch(...)
-		{
-			s_objectState = 0;
-			throw;
-		}
-		s_objectState = 2;
-		break;
-	case 1:
-		goto retry;
-	default:
-		break;
-	}
-	return *s_pObject.m_p;
-}
-
-// ************** misc functions ***************
-
-#if (!__STDC_WANT_SECURE_LIB__)
-inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)
-{
-	if (count > sizeInBytes)
-		throw InvalidArgument("memcpy_s: buffer overflow");
-	memcpy(dest, src, count);
-}
-
-inline void memmove_s(void *dest, size_t sizeInBytes, const void *src, size_t count)
-{
-	if (count > sizeInBytes)
-		throw InvalidArgument("memmove_s: buffer overflow");
-	memmove(dest, src, count);
-}
-#endif
-
-inline void * memset_z(void *ptr, int value, size_t num)
-{
-// avoid extranous warning on GCC 4.3.2 Ubuntu 8.10
-#if CRYPTOPP_GCC_VERSION >= 30001
-	if (__builtin_constant_p(num) && num==0)
-		return ptr;
-#endif
-	return memset(ptr, value, num);
-}
-
-// can't use std::min or std::max in MSVC60 or Cygwin 1.1.0
-template <class T> inline const T& STDMIN(const T& a, const T& b)
-{
-	return b < a ? b : a;
-}
-
-template <class T1, class T2> inline const T1 UnsignedMin(const T1& a, const T2& b)
-{
-	CRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));
-	assert(a==0 || a>0);	// GCC workaround: get rid of the warning "comparison is always true due to limited range of data type"
-	assert(b>=0);
-
-	if (sizeof(T1)<=sizeof(T2))
-		return b < (T2)a ? (T1)b : a;
-	else
-		return (T1)b < a ? (T1)b : a;
-}
-
-template <class T> inline const T& STDMAX(const T& a, const T& b)
-{
-	return a < b ? b : a;
-}
-
-#define RETURN_IF_NONZERO(x) size_t returnedValue = x; if (returnedValue) return returnedValue
-
-// this version of the macro is fastest on Pentium 3 and Pentium 4 with MSVC 6 SP5 w/ Processor Pack
-#define GETBYTE(x, y) (unsigned int)byte((x)>>(8*(y)))
-// these may be faster on other CPUs/compilers
-// #define GETBYTE(x, y) (unsigned int)(((x)>>(8*(y)))&255)
-// #define GETBYTE(x, y) (((byte *)&(x))[y])
-
-#define CRYPTOPP_GET_BYTE_AS_BYTE(x, y) byte((x)>>(8*(y)))
-
-template <class T>
-unsigned int Parity(T value)
-{
-	for (unsigned int i=8*sizeof(value)/2; i>0; i/=2)
-		value ^= value >> i;
-	return (unsigned int)value&1;
-}
-
-template <class T>
-unsigned int BytePrecision(const T &value)
-{
-	if (!value)
-		return 0;
-
-	unsigned int l=0, h=8*sizeof(value);
-
-	while (h-l > 8)
-	{
-		unsigned int t = (l+h)/2;
-		if (value >> t)
-			l = t;
-		else
-			h = t;
-	}
-
-	return h/8;
-}
-
-template <class T>
-unsigned int BitPrecision(const T &value)
-{
-	if (!value)
-		return 0;
-
-	unsigned int l=0, h=8*sizeof(value);
-
-	while (h-l > 1)
-	{
-		unsigned int t = (l+h)/2;
-		if (value >> t)
-			l = t;
-		else
-			h = t;
-	}
-
-	return h;
-}
-
-template <class T>
-inline T Crop(T value, size_t size)
-{
-	if (size < 8*sizeof(value))
-    	return T(value & ((T(1) << size) - 1));
-	else
-		return value;
-}
-
-template <class T1, class T2>
-inline bool SafeConvert(T1 from, T2 &to)
-{
-	to = (T2)from;
-	if (from != to || (from > 0) != (to > 0))
-		return false;
-	return true;
-}
-
-inline size_t BitsToBytes(size_t bitCount)
-{
-	return ((bitCount+7)/(8));
-}
-
-inline size_t BytesToWords(size_t byteCount)
-{
-	return ((byteCount+WORD_SIZE-1)/WORD_SIZE);
-}
-
-inline size_t BitsToWords(size_t bitCount)
-{
-	return ((bitCount+WORD_BITS-1)/(WORD_BITS));
-}
-
-inline size_t BitsToDwords(size_t bitCount)
-{
-	return ((bitCount+2*WORD_BITS-1)/(2*WORD_BITS));
-}
-
-CRYPTOPP_DLL void CRYPTOPP_API xorbuf(byte *buf, const byte *mask, size_t count);
-CRYPTOPP_DLL void CRYPTOPP_API xorbuf(byte *output, const byte *input, const byte *mask, size_t count);
-
-CRYPTOPP_DLL bool CRYPTOPP_API VerifyBufsEqual(const byte *buf1, const byte *buf2, size_t count);
-
-template <class T>
-inline bool IsPowerOf2(const T &n)
-{
-	return n > 0 && (n & (n-1)) == 0;
-}
-
-template <class T1, class T2>
-inline T2 ModPowerOf2(const T1 &a, const T2 &b)
-{
-	assert(IsPowerOf2(b));
-	return T2(a) & (b-1);
-}
-
-template <class T1, class T2>
-inline T1 RoundDownToMultipleOf(const T1 &n, const T2 &m)
-{
-	if (IsPowerOf2(m))
-		return n - ModPowerOf2(n, m);
-	else
-		return n - n%m;
-}
-
-template <class T1, class T2>
-inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)
-{
-	if (n+m-1 < n)
-		throw InvalidArgument("RoundUpToMultipleOf: integer overflow");
-	return RoundDownToMultipleOf(n+m-1, m);
-}
-
-template <class T>
-inline unsigned int GetAlignmentOf(T *dummy=NULL)	// VC60 workaround
-{
-#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
-	if (sizeof(T) < 16)
-		return 1;
-#endif
-
-#if (_MSC_VER >= 1300)
-	return __alignof(T);
-#elif defined(__GNUC__)
-	return __alignof__(T);
-#elif CRYPTOPP_BOOL_SLOW_WORD64
-	return UnsignedMin(4U, sizeof(T));
-#else
-	return sizeof(T);
-#endif
-}
-
-inline bool IsAlignedOn(const void *p, unsigned int alignment)
-{
-	return alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);
-}
-
-template <class T>
-inline bool IsAligned(const void *p, T *dummy=NULL)	// VC60 workaround
-{
-	return IsAlignedOn(p, GetAlignmentOf<T>());
-}
-
-#ifdef IS_LITTLE_ENDIAN
-	typedef LittleEndian NativeByteOrder;
-#else
-	typedef BigEndian NativeByteOrder;
-#endif
-
-inline ByteOrder GetNativeByteOrder()
-{
-	return NativeByteOrder::ToEnum();
-}
-
-inline bool NativeByteOrderIs(ByteOrder order)
-{
-	return order == GetNativeByteOrder();
-}
-
-template <class T>
-std::string IntToString(T a, unsigned int base = 10)
-{
-	if (a == 0)
-		return "0";
-	bool negate = false;
-	if (a < 0)
-	{
-		negate = true;
-		a = 0-a;	// VC .NET does not like -a
-	}
-	std::string result;
-	while (a > 0)
-	{
-		T digit = a % base;
-		result = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;
-		a /= base;
-	}
-	if (negate)
-		result = "-" + result;
-	return result;
-}
-
-template <class T1, class T2>
-inline T1 SaturatingSubtract(const T1 &a, const T2 &b)
-{
-	return T1((a > b) ? (a - b) : 0);
-}
-
-template <class T>
-inline CipherDir GetCipherDir(const T &obj)
-{
-	return obj.IsForwardTransformation() ? ENCRYPTION : DECRYPTION;
-}
-
-CRYPTOPP_DLL void CRYPTOPP_API CallNewHandler();
-
-inline void IncrementCounterByOne(byte *inout, unsigned int s)
-{
-	for (int i=s-1, carry=1; i>=0 && carry; i--)
-		carry = !++inout[i];
-}
-
-inline void IncrementCounterByOne(byte *output, const byte *input, unsigned int s)
-{
-	int i, carry;
-	for (i=s-1, carry=1; i>=0 && carry; i--)
-		carry = ((output[i] = input[i]+1) == 0);
-	memcpy_s(output, s, input, i+1);
-}
-
-// ************** rotate functions ***************
-
-template <class T> inline T rotlFixed(T x, unsigned int y)
-{
-	assert(y < sizeof(T)*8);
-	return T((x<<y) | (x>>(sizeof(T)*8-y)));
-}
-
-template <class T> inline T rotrFixed(T x, unsigned int y)
-{
-	assert(y < sizeof(T)*8);
-	return T((x>>y) | (x<<(sizeof(T)*8-y)));
-}
-
-template <class T> inline T rotlVariable(T x, unsigned int y)
-{
-	assert(y < sizeof(T)*8);
-	return T((x<<y) | (x>>(sizeof(T)*8-y)));
-}
-
-template <class T> inline T rotrVariable(T x, unsigned int y)
-{
-	assert(y < sizeof(T)*8);
-	return T((x>>y) | (x<<(sizeof(T)*8-y)));
-}
-
-template <class T> inline T rotlMod(T x, unsigned int y)
-{
-	y %= sizeof(T)*8;
-	return T((x<<y) | (x>>(sizeof(T)*8-y)));
-}
-
-template <class T> inline T rotrMod(T x, unsigned int y)
-{
-	y %= sizeof(T)*8;
-	return T((x>>y) | (x<<(sizeof(T)*8-y)));
-}
-
-#ifdef _MSC_VER
-
-template<> inline word32 rotlFixed<word32>(word32 x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return y ? _lrotl(x, y) : x;
-}
-
-template<> inline word32 rotrFixed<word32>(word32 x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return y ? _lrotr(x, y) : x;
-}
-
-template<> inline word32 rotlVariable<word32>(word32 x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return _lrotl(x, y);
-}
-
-template<> inline word32 rotrVariable<word32>(word32 x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return _lrotr(x, y);
-}
-
-template<> inline word32 rotlMod<word32>(word32 x, unsigned int y)
-{
-	return _lrotl(x, y);
-}
-
-template<> inline word32 rotrMod<word32>(word32 x, unsigned int y)
-{
-	return _lrotr(x, y);
-}
-
-#endif // #ifdef _MSC_VER
-
-#if _MSC_VER >= 1300 && !defined(__INTEL_COMPILER)
-// Intel C++ Compiler 10.0 calls a function instead of using the rotate instruction when using these instructions
-
-template<> inline word64 rotlFixed<word64>(word64 x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return y ? _rotl64(x, y) : x;
-}
-
-template<> inline word64 rotrFixed<word64>(word64 x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return y ? _rotr64(x, y) : x;
-}
-
-template<> inline word64 rotlVariable<word64>(word64 x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return _rotl64(x, y);
-}
-
-template<> inline word64 rotrVariable<word64>(word64 x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return _rotr64(x, y);
-}
-
-template<> inline word64 rotlMod<word64>(word64 x, unsigned int y)
-{
-	return _rotl64(x, y);
-}
-
-template<> inline word64 rotrMod<word64>(word64 x, unsigned int y)
-{
-	return _rotr64(x, y);
-}
-
-#endif // #if _MSC_VER >= 1310
-
-#if _MSC_VER >= 1400 && !defined(__INTEL_COMPILER)
-// Intel C++ Compiler 10.0 gives undefined externals with these
-
-template<> inline word16 rotlFixed<word16>(word16 x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return y ? _rotl16(x, y) : x;
-}
-
-template<> inline word16 rotrFixed<word16>(word16 x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return y ? _rotr16(x, y) : x;
-}
-
-template<> inline word16 rotlVariable<word16>(word16 x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return _rotl16(x, y);
-}
-
-template<> inline word16 rotrVariable<word16>(word16 x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return _rotr16(x, y);
-}
-
-template<> inline word16 rotlMod<word16>(word16 x, unsigned int y)
-{
-	return _rotl16(x, y);
-}
-
-template<> inline word16 rotrMod<word16>(word16 x, unsigned int y)
-{
-	return _rotr16(x, y);
-}
-
-template<> inline byte rotlFixed<byte>(byte x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return y ? _rotl8(x, y) : x;
-}
-
-template<> inline byte rotrFixed<byte>(byte x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return y ? _rotr8(x, y) : x;
-}
-
-template<> inline byte rotlVariable<byte>(byte x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return _rotl8(x, y);
-}
-
-template<> inline byte rotrVariable<byte>(byte x, unsigned int y)
-{
-	assert(y < 8*sizeof(x));
-	return _rotr8(x, y);
-}
-
-template<> inline byte rotlMod<byte>(byte x, unsigned int y)
-{
-	return _rotl8(x, y);
-}
-
-template<> inline byte rotrMod<byte>(byte x, unsigned int y)
-{
-	return _rotr8(x, y);
-}
-
-#endif // #if _MSC_VER >= 1400
-
-#if (defined(__MWERKS__) && TARGET_CPU_PPC)
-
-template<> inline word32 rotlFixed<word32>(word32 x, unsigned int y)
-{
-	assert(y < 32);
-	return y ? __rlwinm(x,y,0,31) : x;
-}
-
-template<> inline word32 rotrFixed<word32>(word32 x, unsigned int y)
-{
-	assert(y < 32);
-	return y ? __rlwinm(x,32-y,0,31) : x;
-}
-
-template<> inline word32 rotlVariable<word32>(word32 x, unsigned int y)
-{
-	assert(y < 32);
-	return (__rlwnm(x,y,0,31));
-}
-
-template<> inline word32 rotrVariable<word32>(word32 x, unsigned int y)
-{
-	assert(y < 32);
-	return (__rlwnm(x,32-y,0,31));
-}
-
-template<> inline word32 rotlMod<word32>(word32 x, unsigned int y)
-{
-	return (__rlwnm(x,y,0,31));
-}
-
-template<> inline word32 rotrMod<word32>(word32 x, unsigned int y)
-{
-	return (__rlwnm(x,32-y,0,31));
-}
-
-#endif // #if (defined(__MWERKS__) && TARGET_CPU_PPC)
-
-// ************** endian reversal ***************
-
-template <class T>
-inline unsigned int GetByte(ByteOrder order, T value, unsigned int index)
-{
-	if (order == LITTLE_ENDIAN_ORDER)
-		return GETBYTE(value, index);
-	else
-		return GETBYTE(value, sizeof(T)-index-1);
-}
-
-inline byte ByteReverse(byte value)
-{
-	return value;
-}
-
-inline word16 ByteReverse(word16 value)
-{
-#ifdef CRYPTOPP_BYTESWAP_AVAILABLE
-	return bswap_16(value);
-#elif defined(_MSC_VER) && _MSC_VER >= 1300
-	return _byteswap_ushort(value);
-#else
-	return rotlFixed(value, 8U);
-#endif
-}
-
-inline word32 ByteReverse(word32 value)
-{
-#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE)
-	__asm__ ("bswap %0" : "=r" (value) : "0" (value));
-	return value;
-#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)
-	return bswap_32(value);
-#elif defined(__MWERKS__) && TARGET_CPU_PPC
-	return (word32)__lwbrx(&value,0);
-#elif _MSC_VER >= 1400 || (_MSC_VER >= 1300 && !defined(_DLL))
-	return _byteswap_ulong(value);
-#elif CRYPTOPP_FAST_ROTATE(32)
-	// 5 instructions with rotate instruction, 9 without
-	return (rotrFixed(value, 8U) & 0xff00ff00) | (rotlFixed(value, 8U) & 0x00ff00ff);
-#else
-	// 6 instructions with rotate instruction, 8 without
-	value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
-	return rotlFixed(value, 16U);
-#endif
-}
-
-inline word64 ByteReverse(word64 value)
-{
-#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)
-	__asm__ ("bswap %0" : "=r" (value) : "0" (value));
-	return value;
-#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)
-	return bswap_64(value);
-#elif defined(_MSC_VER) && _MSC_VER >= 1300
-	return _byteswap_uint64(value);
-#elif CRYPTOPP_BOOL_SLOW_WORD64
-	return (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));
-#else
-	value = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);
-	value = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);
-	return rotlFixed(value, 32U);
-#endif
-}
-
-inline byte BitReverse(byte value)
-{
-	value = ((value & 0xAA) >> 1) | ((value & 0x55) << 1);
-	value = ((value & 0xCC) >> 2) | ((value & 0x33) << 2);
-	return rotlFixed(value, 4U);
-}
-
-inline word16 BitReverse(word16 value)
-{
-	value = ((value & 0xAAAA) >> 1) | ((value & 0x5555) << 1);
-	value = ((value & 0xCCCC) >> 2) | ((value & 0x3333) << 2);
-	value = ((value & 0xF0F0) >> 4) | ((value & 0x0F0F) << 4);
-	return ByteReverse(value);
-}
-
-inline word32 BitReverse(word32 value)
-{
-	value = ((value & 0xAAAAAAAA) >> 1) | ((value & 0x55555555) << 1);
-	value = ((value & 0xCCCCCCCC) >> 2) | ((value & 0x33333333) << 2);
-	value = ((value & 0xF0F0F0F0) >> 4) | ((value & 0x0F0F0F0F) << 4);
-	return ByteReverse(value);
-}
-
-inline word64 BitReverse(word64 value)
-{
-#if CRYPTOPP_BOOL_SLOW_WORD64
-	return (word64(BitReverse(word32(value))) << 32) | BitReverse(word32(value>>32));
-#else
-	value = ((value & W64LIT(0xAAAAAAAAAAAAAAAA)) >> 1) | ((value & W64LIT(0x5555555555555555)) << 1);
-	value = ((value & W64LIT(0xCCCCCCCCCCCCCCCC)) >> 2) | ((value & W64LIT(0x3333333333333333)) << 2);
-	value = ((value & W64LIT(0xF0F0F0F0F0F0F0F0)) >> 4) | ((value & W64LIT(0x0F0F0F0F0F0F0F0F)) << 4);
-	return ByteReverse(value);
-#endif
-}
-
-template <class T>
-inline T BitReverse(T value)
-{
-	if (sizeof(T) == 1)
-		return (T)BitReverse((byte)value);
-	else if (sizeof(T) == 2)
-		return (T)BitReverse((word16)value);
-	else if (sizeof(T) == 4)
-		return (T)BitReverse((word32)value);
-	else
-	{
-		assert(sizeof(T) == 8);
-		return (T)BitReverse((word64)value);
-	}
-}
-
-template <class T>
-inline T ConditionalByteReverse(ByteOrder order, T value)
-{
-	return NativeByteOrderIs(order) ? value : ByteReverse(value);
-}
-
-template <class T>
-void ByteReverse(T *out, const T *in, size_t byteCount)
-{
-	assert(byteCount % sizeof(T) == 0);
-	size_t count = byteCount/sizeof(T);
-	for (size_t i=0; i<count; i++)
-		out[i] = ByteReverse(in[i]);
-}
-
-template <class T>
-inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)
-{
-	if (!NativeByteOrderIs(order))
-		ByteReverse(out, in, byteCount);
-	else if (in != out)
-		memcpy_s(out, byteCount, in, byteCount);
-}
-
-template <class T>
-inline void GetUserKey(ByteOrder order, T *out, size_t outlen, const byte *in, size_t inlen)
-{
-	const size_t U = sizeof(T);
-	assert(inlen <= outlen*U);
-	memcpy_s(out, outlen*U, in, inlen);
-	memset_z((byte *)out+inlen, 0, outlen*U-inlen);
-	ConditionalByteReverse(order, out, out, RoundUpToMultipleOf(inlen, U));
-}
-
-#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
-inline byte UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const byte *)
-{
-	return block[0];
-}
-
-inline word16 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word16 *)
-{
-	return (order == BIG_ENDIAN_ORDER)
-		? block[1] | (block[0] << 8)
-		: block[0] | (block[1] << 8);
-}
-
-inline word32 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word32 *)
-{
-	return (order == BIG_ENDIAN_ORDER)
-		? word32(block[3]) | (word32(block[2]) << 8) | (word32(block[1]) << 16) | (word32(block[0]) << 24)
-		: word32(block[0]) | (word32(block[1]) << 8) | (word32(block[2]) << 16) | (word32(block[3]) << 24);
-}
-
-inline word64 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word64 *)
-{
-	return (order == BIG_ENDIAN_ORDER)
-		?
-		(word64(block[7]) |
-		(word64(block[6]) <<  8) |
-		(word64(block[5]) << 16) |
-		(word64(block[4]) << 24) |
-		(word64(block[3]) << 32) |
-		(word64(block[2]) << 40) |
-		(word64(block[1]) << 48) |
-		(word64(block[0]) << 56))
-		:
-		(word64(block[0]) |
-		(word64(block[1]) <<  8) |
-		(word64(block[2]) << 16) |
-		(word64(block[3]) << 24) |
-		(word64(block[4]) << 32) |
-		(word64(block[5]) << 40) |
-		(word64(block[6]) << 48) |
-		(word64(block[7]) << 56));
-}
-
-inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, byte value, const byte *xorBlock)
-{
-	block[0] = xorBlock ? (value ^ xorBlock[0]) : value;
-}
-
-inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word16 value, const byte *xorBlock)
-{
-	if (order == BIG_ENDIAN_ORDER)
-	{
-		if (xorBlock)
-		{
-			block[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
-			block[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
-		}
-		else
-		{
-			block[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
-			block[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
-		}
-	}
-	else
-	{
-		if (xorBlock)
-		{
-			block[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
-			block[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
-		}
-		else
-		{
-			block[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
-			block[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
-		}
-	}
-}
-
-inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word32 value, const byte *xorBlock)
-{
-	if (order == BIG_ENDIAN_ORDER)
-	{
-		if (xorBlock)
-		{
-			block[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
-			block[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
-			block[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
-			block[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
-		}
-		else
-		{
-			block[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
-			block[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
-			block[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
-			block[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
-		}
-	}
-	else
-	{
-		if (xorBlock)
-		{
-			block[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
-			block[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
-			block[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
-			block[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
-		}
-		else
-		{
-			block[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
-			block[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
-			block[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
-			block[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
-		}
-	}
-}
-
-inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word64 value, const byte *xorBlock)
-{
-	if (order == BIG_ENDIAN_ORDER)
-	{
-		if (xorBlock)
-		{
-			block[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);
-			block[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);
-			block[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);
-			block[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);
-			block[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
-			block[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
-			block[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
-			block[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
-		}
-		else
-		{
-			block[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);
-			block[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);
-			block[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);
-			block[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);
-			block[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
-			block[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
-			block[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
-			block[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
-		}
-	}
-	else
-	{
-		if (xorBlock)
-		{
-			block[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
-			block[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
-			block[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
-			block[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
-			block[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);
-			block[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);
-			block[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);
-			block[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);
-		}
-		else
-		{
-			block[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
-			block[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
-			block[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
-			block[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
-			block[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);
-			block[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);
-			block[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);
-			block[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);
-		}
-	}
-}
-#endif	// #ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
-
-template <class T>
-inline T GetWord(bool assumeAligned, ByteOrder order, const byte *block)
-{
-#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
-	if (!assumeAligned)
-		return UnalignedGetWordNonTemplate(order, block, (T*)NULL);
-	assert(IsAligned<T>(block));
-#endif
-	return ConditionalByteReverse(order, *reinterpret_cast<const T *>(block));
-}
-
-template <class T>
-inline void GetWord(bool assumeAligned, ByteOrder order, T &result, const byte *block)
-{
-	result = GetWord<T>(assumeAligned, order, block);
-}
-
-template <class T>
-inline void PutWord(bool assumeAligned, ByteOrder order, byte *block, T value, const byte *xorBlock = NULL)
-{
-#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
-	if (!assumeAligned)
-		return UnalignedPutWordNonTemplate(order, block, value, xorBlock);
-	assert(IsAligned<T>(block));
-	assert(IsAligned<T>(xorBlock));
-#endif
-	*reinterpret_cast<T *>(block) = ConditionalByteReverse(order, value) ^ (xorBlock ? *reinterpret_cast<const T *>(xorBlock) : 0);
-}
-
-template <class T, class B, bool A=false>
-class GetBlock
-{
-public:
-	GetBlock(const void *block)
-		: m_block((const byte *)block) {}
-
-	template <class U>
-	inline GetBlock<T, B, A> & operator()(U &x)
-	{
-		CRYPTOPP_COMPILE_ASSERT(sizeof(U) >= sizeof(T));
-		x = GetWord<T>(A, B::ToEnum(), m_block);
-		m_block += sizeof(T);
-		return *this;
-	}
-
-private:
-	const byte *m_block;
-};
-
-template <class T, class B, bool A=false>
-class PutBlock
-{
-public:
-	PutBlock(const void *xorBlock, void *block)
-		: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}
-
-	template <class U>
-	inline PutBlock<T, B, A> & operator()(U x)
-	{
-		PutWord(A, B::ToEnum(), m_block, (T)x, m_xorBlock);
-		m_block += sizeof(T);
-		if (m_xorBlock)
-			m_xorBlock += sizeof(T);
-		return *this;
-	}
-
-private:
-	const byte *m_xorBlock;
-	byte *m_block;
-};
-
-template <class T, class B, bool GA=false, bool PA=false>
-struct BlockGetAndPut
-{
-	// function needed because of C++ grammatical ambiguity between expression-statements and declarations
-	static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}
-	typedef PutBlock<T, B, PA> Put;
-};
-
-template <class T>
-std::string WordToString(T value, ByteOrder order = BIG_ENDIAN_ORDER)
-{
-	if (!NativeByteOrderIs(order))
-		value = ByteReverse(value);
-
-	return std::string((char *)&value, sizeof(value));
-}
-
-template <class T>
-T StringToWord(const std::string &str, ByteOrder order = BIG_ENDIAN_ORDER)
-{
-	T value = 0;
-	memcpy_s(&value, sizeof(value), str.data(), UnsignedMin(str.size(), sizeof(value)));
-	return NativeByteOrderIs(order) ? value : ByteReverse(value);
-}
-
-// ************** help remove warning on g++ ***************
-
-template <bool overflow> struct SafeShifter;
-
-template<> struct SafeShifter<true>
-{
-	template <class T>
-	static inline T RightShift(T value, unsigned int bits)
-	{
-		return 0;
-	}
-
-	template <class T>
-	static inline T LeftShift(T value, unsigned int bits)
-	{
-		return 0;
-	}
-};
-
-template<> struct SafeShifter<false>
-{
-	template <class T>
-	static inline T RightShift(T value, unsigned int bits)
-	{
-		return value >> bits;
-	}
-
-	template <class T>
-	static inline T LeftShift(T value, unsigned int bits)
-	{
-		return value << bits;
-	}
-};
-
-template <unsigned int bits, class T>
-inline T SafeRightShift(T value)
-{
-	return SafeShifter<(bits>=(8*sizeof(T)))>::RightShift(value, bits);
-}
-
-template <unsigned int bits, class T>
-inline T SafeLeftShift(T value)
-{
-	return SafeShifter<(bits>=(8*sizeof(T)))>::LeftShift(value, bits);
-}
-
-// ************** use one buffer for multiple data members ***************
-
-#define CRYPTOPP_BLOCK_1(n, t, s) t* m_##n() {return (t *)(m_aggregate+0);}     size_t SS1() {return       sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
-#define CRYPTOPP_BLOCK_2(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS1());} size_t SS2() {return SS1()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
-#define CRYPTOPP_BLOCK_3(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS2());} size_t SS3() {return SS2()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
-#define CRYPTOPP_BLOCK_4(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS3());} size_t SS4() {return SS3()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
-#define CRYPTOPP_BLOCK_5(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS4());} size_t SS5() {return SS4()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
-#define CRYPTOPP_BLOCK_6(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS5());} size_t SS6() {return SS5()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
-#define CRYPTOPP_BLOCK_7(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS6());} size_t SS7() {return SS6()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
-#define CRYPTOPP_BLOCK_8(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS7());} size_t SS8() {return SS7()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
-#define CRYPTOPP_BLOCKS_END(i) size_t SST() {return SS##i();} void AllocateBlocks() {m_aggregate.New(SST());} AlignedSecByteBlock m_aggregate;
-
-NAMESPACE_END
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/obj/cpu.o bitcoin-0.3.20/src/cryptopp/obj/cpu.o
--- bitcoin-0.3.20.orig/src/cryptopp/obj/cpu.o	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/obj/cpu.o	1970-01-01 01:00:00.000000000 +0100
@@ -1,71 +0,0 @@
-ELF                      t      4     (               US1D$p  $   Et$$    E$   D$[]UD$  }1]$   Et%$   1t$E$   D$]}]t& ES[Ex   HPUH]]u}\$$    u]u}]t& ED$$   tU         1=     t	E	              E       UEEUEu?EE            u
-            /u      u\$$  E    t& ut$$   }   Ot$$  E    ,t& U    &    '    UD$   $        UD$   $                         %  $ >   :;I  $ >  9:;   :;  9 :;   <  	 <  
- :;  <  :;   I8
-2   :;I8
-  .?:;<   I4   I  .?:;<  4 :;@I?<  $ >  9:;  .?:;@I<  .?:;@I<  : :;   G:;      I  &   G:;  .?:;@I<  .?:;@<   .?:;@<  !& I  " I  #.?:;<  $:;  % I  & :;I  ':;  (:;  ) :;I  * :;I8
-  +I  ,! I/  -.?:;I<  .   /. ?:;I<  0.?:;I<  1:;  2 :;  3.?:;<  4. ?:;I<  5G:;  64 :;@I?<  7 :;I8
-2  8.?:;@I2<  9.?:;@2<  :. ?:;@I2<  ;.?:;@I<  <.?:;@I<  =.?:;@<  >.?:;@I2<  ?.?:;@I<  @. ?:;@I<  A<  B:;  C(   D. :;I<  E. ?:;@<  F.:;<  G4 :;I<  H4 :;I<  I4 :;I<  J :;I8
-  KI  L   M.?:;I<  N  OG:;  PG:;  Q.?L4<  RG:;  S.?4<  T :;I8
-2  U.?:;L<  V.?:;@ILM
-<  W.G   X :;I  Y4 :;I  Z.G@  [4 :;I
-  \4 :;I  ] :;I
-  ^1UXY  _4 1  `  a I
-  b4 :;I?<  c4 G  d4 G  e4 G
-  f4 :;@I?<  g4 :;@I?<  h4 :;@I?<  i4 :;@I?<   <<       4#  `'  (            |    7   int   I   7'  std &   8  9    6  	  H	  	  	  	  	   
-  =
-  Z
-  w
-  
-  
-  
-  
-    (  K  x            -  O  v            ,  H  d    X  o             F  j            *  K  l              /  
-Q  
-u  
-  dc  es  g~  h  i  j  k  l  m  n1  oR  pn  s  t  v  w  x  z6  {N  |[  }r  ~              <  Y  f  }            <@  =  >          #     #       /     	  	  k/  l./  p/  q/  r/  s/  t0  v90  yV0  {n0  ~0  0  0  0  1  1  01  R1  s1  1  1  1  W/      1  2  `2  2  ?2  |2  		$    P  8  %  	pI   8   J  IG  ];     
-J  	  	F  	y   abs   /    /   div %  W/  /  /    e    x!    '  0  :$    =I  >i    p   G_    7  &  E     &  G       .  L    7      O             R{$              W        I   Y     a  =      I    g  e  >   Y        k  {            v          {    !  "  "  `  "  !`    v   T)  `  #   b  )     d  )  /   #(  j)  7       "5  !  @  -  M  !@  !7   !\    6  1n  $
-  /	    7   # "    #    #q    #Q    #    #    #    #    #     #$"    #(     #,  "A  #0&  $G  #4q   &7   #8s$  *7   #<#  ,  #@!  0  #D'  1  #F  2M  #G  6]  #H  ?  #LV  HW  #T  IW  #X]  JW  #\d  KW  #`k  L>   #dK  N7   #hJ   Pc  #l   An    +E	  %    &j  cI   '  O	  (  R	  )h  TI   )I  X	   *  P7   # *  Yg	  # +  	  ,	     e[	  -  OO	  	  7    -I#  O	  	  	   /	  -#  :   
-  :  7   	   -k  O	  =
-  @  	   -  7   Z
-  G  	   -   7   w
-  	  7    -  X7   
-  	  G  . -g
-  G7   
-  	  G  . -G  O	  
-  	   /  O	  -
-  Z>   
-    >   
-   	  -!  :>   (  :    >   
-   -  47   @  @   F  !	  -  >   r  :  r  >   
-     -k  O	    @  	   -9  O	    @   -  7     :  >   G  . -  R7     G  G  . -x%  O	    O	  	   -  l7   -  	  G  :	   -a  ~7   O  	  G  :	   -5  :7   v  :  >   G  :	   -  7     G  G  :	   -A  e7     G  :	   -R  7     G  :	   -  >       @  
-   06  :    :  G   0s  7   ,  G  G   0$  7   H  G  G   0&  :  d  :  G   0  >     G  G   -v
-  $>     :  >   G       !  1tm ,X  *   7   # *)  7   #*  7   #*=  7   #*  7   #*m  7   #*  7   #*  7   #*  7   # *"  (  #$*"
-    #( 0  >   o  G   -"  :    :  G  >    0z  7     G  G  >    0  :    :  G  >    -$  >         >   
-   G  0  >     G  G   -P  9  9  G  @     :  -W  c  c  G  @     0^  :    :  G  @   -e  (    G  @  7    -i      G  @  7    0  >     :  G  >    -  U7     O	   -  7   *  G  G  >    0!  (:  K  :  G  >    0b  F:  l  :  G  >    0  :    :  @  >    -!  R7     G  . -  M7     G  . 0s  :    G  @   01   :    G  G   0*$  :    G  @   0  :  /  G  G   -2  :  Q  G  @  >    -  n  n  G  @     -@  /    G  @  7    -      G  @  7    ((  8/    (      '    *    # *&  [	  # 2  'R  A  *  A  # *  G  #*  7   # 
-  n  +  ]  ,	      +  s  ,	  ' _  [  3       c  0v  7        -  7        -  7        0Y'  7        -4  7        -9  7   +    +   s  0J    R    7      0"    n       0*  `7         . -  >     W  >   >      -l             -  7       (  7    -  7            !s  -  (  6     -  7   N     4$  -7   0    r     34  /     0  g7       . 0  P7     7    0  7        0  7          3>       3	  3       -   87   <      7   >    0	   7   Y      . 4    0    }     -  7     7      0  ~7         :	   0B"  s7       :	   0  ,7         :	   0t  >7       >     . 0  K7   @    >     :	   '9   87  *  :  # *   ;  #*  A  #*  G  #*  H  #*Y  I  #*  J  #*  K  #*u   L  # *  M  #$*  N  #(*  O  #)*6  Q  #**  S  #+*%  U  #,*  W  #-*$  ^  #.*  _  #/*'  b  #0*4  d  #1*-  f  #2*"  h  #3*]  o  #4*  p  #5 0  }    7      4&    @  '    *    #  +    ,	   '  "  +7     ,	     %7   L  5B  8$+  6'  2  $+  7c  L  # r    8`  A    {  )+   8`  K      4+     8  b  :+    )+   8  #T      )+   8  '      )+   9G  +7    4+   8&	  2$  >   :  )+  I      9  :  c  )+  I   I      8  B!  >     )+  I   I    8&  J  \    )+     9  S	        I    9i   \        I    9  e\      I      9K'  x	  :         9K'  |"  ]         9K'             9K'  !           8E  "  7     I   I    9#      4+  I   I   I    9'  S     4+   :m    @+  3#  0  4+   #  I  4+  /   #  b  4+  F+   #    4+  F+  I   I    #    4+  F+  I   I   /   #    4+    I   /   #    4+    /   #    4+  I     /   3(  ,  4+  7    ;  '#  L+  N  4+  F+   ;  o  L+  p  4+     ;    L+    4+     ;'         4+   ;'  V      )+   <end '.      4+   <end 2      )+   ;  ;p    #  4+   ;  D    @  )+   ;y	  M    ]  4+   ;y	  VJ    z  )+   ;  ^[$  >     )+   ;  d  >     )+   ;g  iz  >     )+   =  g'    4+  I      =      4+  I    ;  M  >   /  )+   =    M  4+  I    =    f  4+   ;   
-  \    )+   ;        )+  I    ;        4+  I    <at 
-      )+  I    <at     	  4+  I    ;  E  L+  +  4+  F+   ;    L+  M  4+     ;    L+  o  4+     ;  C  L+    4+  F+   ;  T
-  L+    4+  F+  I   I    ;  (4  L+    4+    I    ;  C  L+     4+     ;  $  L+  -   4+  I      =  f  K   4+     /	  '  L+  l   4+  F+   ;/	  q  L+     4+  F+  I   I    ;/	  z  L+     4+    I    ;/	  &  L+     4+     ;/	    L+  !  4+  I      =  g  0!  4+    I      ;  O	  L+  W!  4+  I   F+   ;     L+  !  4+  I   F+  I   I    ;  fF  L+  !  4+  I     I    ;  +  L+  !  4+  I      ;  B  L+  "  4+  I   I      ;  Sn    ."  4+       ;  k"  L+  U"  4+  I   I    ;  {;    w"  4+     ;      "  4+       ;Z    L+  "  4+  I   I   F+   ;Z    L+   #  4+  I   I   F+  I   I    ;Z    L+  1#  4+  I   I     I    ;Z    L+  ]#  4+  I   I      ;Z  H$  L+  #  4+  I   I   I      ;Z    L+  #  4+      F+   ;Z  &  L+  #  4+        I    ;Z  ;%  L+  $  4+         ;Z  P"  L+  H$  4+      I      ;Z  t*
-  L+  y$  4+           ;Z  2  L+  $  4+           ;Z    L+  $  4+           ;Z  
-  L+  %  4+           8  	  L+  >%  4+  I   I   I      8&  %  L+  p%  4+  I   I     I    >k  \    %  I     /   ;  .  >   %  )+    I   I    =
-    %  4+  L+   ;P      %  )+   ;  =    &  )+   ;      7&  )+   ;z  $  >   c&  )+    I   I    ;z  +  >   &  )+  F+  I    ;z  9  >   &  )+    I    ;z  #  >   &  )+    I    ;D  WU%  >   &  )+  F+  I    ;D    >   +'  )+    I   I    ;D  s  >   R'  )+    I    ;D  q  >   y'  )+    I    ;1(  #  >   '  )+  F+  I    ;1(    >   '  )+    I   I    ;1(    >   '  )+    I    ;1(    >   (  )+    I    ;%    >   A(  )+  F+  I    ;%  &  >   m(  )+    I   I    ;%    >   (  )+    I    ;%    >   (  )+    I    ;%    >   (  )+  F+  I    ;%  ;  >   )  )+    I   I    ;%  (  >   5)  )+    I    ;%  Gn  >   \)  )+    I    ;P  F%  >   )  )+  F+  I    ;P  R  >   )  )+    I   I    ;P  c  >   )  )+    I    ;P  g
-  >   )  )+    I    ;  |  #  $*  )+  I   I    ;2$    7   F*  )+  F+   ;2$  {  7   r*  )+  I   I   F+   ;2$  !  7   *  )+  I   I   F+  I   I    ;2$  	  7   *  )+     ;2$    7   *  )+  I   I      ?2$  $  7   )+  I   I     I     !>   /+  !#  #  W  "W  "/+  "#  5Q  +  *  >   # *P#  >   #*    # 5W  J-  R+  # =  8h"  $+    =$      I:  J-  @m  !  @+  '  T   \  +  Z-     M  \  ,  Z-   4"  \!  2,  :+     J"  J,  :+       g,  :+  I    q  $    ,  :+     Q    ,  :+  /  /   ;R  
-H  :+  ,  I   I   /   !  r  ,  :+  /   =    
--  :+  /   o  ~	    &-  :+   ?  WB    :+  /  I     +>   Z-  ,	   `-  !+    	m/  AJ   -  B   rCh%   C  C    Cz  C  C  C    	K&  	  D  g\    "  \  -    u9   E&    F=	  U.  7    F  .  7    G:  	|:  H  	:  H  	:        \  i$    \  =    \    b	  \    x  \  x    \    #    G%   `;  	>  6r   H6  ;  6     J7  I  2  I  T2   '  !c./  *  !d7   # Jrem !e7   # '  !kW/  *  !l(  # Jrem !m(  # '  !w/  *  !x/  # Jrem !y/  # &!  !/  /  K7   /  Y  Y   -  !7   /  /   /  L-/  !9  /     -  !7   /     -  !!(  0     -Z  !W  90  Y  Y  >   >   /   Mdiv !/  V0  7   7    -B#  !!  n0     -  !./  0  (  (   -  !7   0    >    0  "r>   0  :    >    - !  !7   0  :    >    3  !1  W  >   >   /   /#  !|7   30  !~01  I    0x  !9  L1    L1     0  !(  s1    L1  7    0}  !  1    L1  7    -O  !7   1     0  ">   1    G  >    0o
-  "T7   1    @   -}  !W/  2  /  /   -  !*/  2     0  !/  ?2    L1  7    0&  !  `2    L1  7    0  !c  |2    L1   0  !n  2    L1   2  N2  7    '?  #$2  *  #)  # *  #*7   #*   #+  #   #12  +2  2  ,	    "3  !  O  $4  7m  $  # 3#  $83  4   3#  $R3  4  2   ;  $&    o3  4   ;  $     3  4   ;  $X  4  3  4   ;  $  3  3  4  7    ;  $  4  3  4   ;  $  3  
-4  4  7    ;  $D    ,4  4  4   ;  $?  4  N4  4  4   ;  $&  3  p4  4  4   ;  $   4  4  4  4   ;  $  3  4  4  4   ?p   $  2  4    3  4  !3  "3  "4  !,   O  $6  7m  $  # 3#  $"5  6   3#  $<5  6  6   ;  $_    Y5  6   ;  $?    v5  6   ;  $  6  5  6   ;  $  4  5  6  7    ;  $ &  6  5  6   ;  $%  4  5  6  7    ;  $X&    6  6  4   ;  $!  6  86  6  4   ;  $  4  Z6  6  4   ;  $  6  |6  6  4   ;  $  4  6  6  4   ?p   $\  6  6    4  "6  !  6  !4  "4  P-   ho  >7  -  # 3K&   j	7  >7   3K&   k#7    <#   Q  6  >7  7     6  "J7  !7  R-   o  7  p-  # S  7  7  7      7  7  D7   Q  O7  7  7     O7  "7  !O7  Rp-   oo  8  o  # T#   z-  #T   7  #SJ   8  8  8   J    28  8  z-  D7   U@   7  Q8  8  7    V       7  u8  8   
-     D7  8  8         8  8  D7      u  z-  8  8       f  8  z-    7  "8  !7  8  "  Wu  -9  X__a P-9  X__b P29  Y  U   !8  !8  Z-      Q       u9  $  2  [?   {L9  ux\o  \  ,      Z-  `      ?   9  ]  "   ]6	  "u9  [?   8L9  ut\o  <\  k    Z-     b     .:  [&  .:  \[!  .:  L^9      :  _!9      `  P  [(  .:    +  >:  ,	   Z-  p       \:  a7     Z.      
-  z:  a7     b  G  b  G  :  	{:  D'  	v  !:  c.  !I   d$.  d1.   e>.      eO.      e`.      eq.      e.      e.      e.      !  c.  !.  6r   H6  ;  6     J7  e.     e.      !I  J  IG  ];  f  %>*!  R  xg  %?  R  +'  %C  W    %D  R  h'  2  $+  g=  8h"  $+  ?i  =$       I:  J-  6'  q'  $+  =  8;  $+    =\#  M              cryptopp /usr/include/c++/4.3/bits /usr/lib/gcc/i486-linux-gnu/4.3.3/include /usr/include/c++/4.3 /usr/include/c++/4.3/debug /usr/include/c++/4.3/ext /usr/include /usr/include/bits /usr/include/c++/4.3/i486-linux-gnu/bits  cpu.cpp   stl_move.h   stddef.h   cstddef   cwchar   cstdio   clocale   cstdlib   config.h   cpp_type_traits.h   debug.h   new_allocator.h   allocator.h   basic_string.h   stdio.h   libio.h   stdarg.h   wchar.h   wchar2.h   time.h   types.h   _G_config.h   stdio2.h   stdio.h   locale.h   sigset.h   setjmp.h   atomic_word.h 	  new   basic_string.tcc   stringfwd.h   cryptlib.h   stdlib.h   stdlib.h   setjmp.h   stl_iterator.h   numeric_traits.h   <built-in>           Jk.<g\t<<ffj<i.<\ 1z 9i'<[ ieYh>dZgt <= << <Iuwo/tthEh GenuineIntel AuthenticAMD      |             Q   ABA        `      ABNE              ABFI       p     AB            AB        t       t   Q    u           O    S        `   a    ta   c    tc       u        s       W       W       W               t       t   b   u             R     R        p  q   tq  s   ts     u             t     t     u                @<  {9  CpuId 9  DetectX86Features :  g_x86DetectionDone :  g_hasSSE2 :  g_hasISSE :  g_hasMMX :  g_hasSSSE3 :  g_isP4 ;  g_cacheLineSize                                w  z                  CANNOT_FLUSH _ZN8CryptoPP9Exception7SetWhatERKSs wcspbrk lconv oldHandler _unused2 _ZNSs12_M_leak_hardEv _M_move _fileno __normal_iterator<const char*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > tm_sec allocate __saved_mask fwide _ZN8CryptoPP17DetectX86FeaturesEv new_allocator int_p_sep_by_space getwc _ZNKSs8capacityEv fpos_t _ZN8CryptoPP9Exception12SetErrorTypeENS0_9ErrorTypeE _ZNSs5clearEv nothrow_t _shortbuf __gnu_cxx _ZN9__gnu_cxx17__normal_iteratorIPKcSsEmmEv _ZN9__gnu_cxx13new_allocatorIcE10deallocateEPcj _ZNKSs4findEcj _ZNSs4nposE NullNameValuePairs _ZNSs4_Rep7_M_grabERKSaIcES2_ _M_refcopy wcsncmp capacity feof _ZNSs13_S_copy_charsEPcS_S_ _flags length _M_refcount __off_t substr _M_check_length deallocate tm_isdst grouping _lock allocator _ZN9__gnu_cxx13new_allocatorIcE8allocateEjPKv wcstoll _ZNSs4_Rep9_S_createEjjRKSaIcE max_size _ZNSs6rbeginEv bool atoi atol _M_p wcsncpy wcsspn __builtin_va_list __pos __jmpbuf __debug _ZN8CryptoPP15DEFAULT_CHANNELE setlocale _ZNSs6insertEjPKc _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_RKSs _ZNKSs7_M_dataEv vwscanf replace _ZNKSs6_M_repEv _Rep_base _ZNKSs6substrEjj _ZNSsaSEc _ZNKSs4findERKSsj IO_ERROR _ZNSs6insertEjjc _IO_write_end _ZNSs5eraseEN9__gnu_cxx17__normal_iteratorIPcSsEES2_ CryptoPP __mask_was_saved _ZNSs5beginEv _ZNKSs4copyEPcjj _ZN9__gnu_cxx17__normal_iteratorIPKcSsEpLERKi _S_empty_rep DATA_INTEGRITY_CHECK_FAILED rename _Alloc_hider wcsstr fread int_frac_digits ~InvalidArgument g_x86DetectionDone _M_destroy _ZN9__gnu_cxx13new_allocatorIcE7destroyEPc _ZNKSs8_M_limitEjj fgetc LWORD_MAX rfind fgets wcstod wcstof wcstok wcstol freopen snprintf lldiv ferror _ZNSs7replaceEjjPKc operator* operator+ operator- __gnu_debug vsnprintf _ZNSs4swapERSs wmemset operator= btowc DEFAULT_CHANNEL sprintf _ZNSs12_S_empty_repEv _ZNSs6assignERKSs putwchar _ZNSs4_Rep8_M_cloneERKSaIcEj _ZNK9__gnu_cxx17__normal_iteratorIPcSsEdeEv atexit currency_symbol putchar _ZNKSs7compareEjjPKc _ZNSs6appendEPKc _ZN9__gnu_cxx24__numeric_traits_integerIiE5__maxE _ZNSs7replaceEjjPKcj __gnuc_va_list _chain int_n_cs_precedes __jmp_buf_tag _ZNKSs4_Rep12_M_is_sharedEv wcstoul _M_refdata unsigned char s_jmpNoCPUID _M_set_sharable wcsxfrm _IO_lock_t wcslen _ZNKSs13find_first_ofEPKcj float _M_set_length_and_sharable _ZNSs4_Rep26_M_set_length_and_sharableEj _M_check assign output SigIllHandlerSSE2 _ZNSs6insertEjRKSs _ZN8CryptoPP8g_hasMMXE rend _ZNSs4_Rep10_M_refcopyEv setbuf _ZNSs7_M_copyEPcPKcj _ZNSs13_S_copy_charsEPcN9__gnu_cxx17__normal_iteratorIS_SsEES2_ _ZNKSs7compareEPKc _ZNKSs16find_last_not_ofEcj tm_zone _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_S1_S1_ fwscanf wctomb wcsftime swap _ZNKSs5emptyEv mbrlen _ZNKSs2atEj _ZNSs6appendERKSsjj GetWhat _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_NS0_IPKcSsEES5_ _M_iend _ZNK9__gnu_cxx17__normal_iteratorIPcSsEmiERKi rewind _ZNSspLERKSs _S_create _ZNSs9_M_assignEPcjc _ZNSs6assignERKSsjj strtold _ZNSs7reserveEj strtoll _ZNSspLEPKc _IO_write_ptr jmp_buf negative_sign _ZN9__gnu_cxx24__numeric_traits_integerIiE11__is_signedE _ZNKSs12find_last_ofEPKcj ~basic_string wcscat g_hasISSE _ZSt7nothrow _ZNKSs9_M_ibeginEv _ZNSs6insertEN9__gnu_cxx17__normal_iteratorIPcSsEEjc ftell _ZNSs7replaceEjjRKSs g_hasMMX int_curr_symbol _ZNKSs7compareERKSs _ZNK9__gnu_cxx13new_allocatorIcE7addressERc TrySSE2 size _M_clone _M_replace_safe FILE _ZNSbIwSt11char_traitsIwESaIwEE4_Rep11_S_max_sizeE _ZNKSs17find_first_not_ofEcj _ZNSs6appendERKSs _M_ibegin ldiv clear wcscspn _ZNSs9_M_mutateEjjj size_t __count quot destroy _ZNKSs17find_first_not_ofEPKcj _ZNSs14_M_replace_auxEjjjc _ZNSs6appendEjc perror _ZNSs5eraseEN9__gnu_cxx17__normal_iteratorIPcSsEE _M_current _ZN8CryptoPP10g_hasSSSE3E ~BERDecodeErr _M_grab _M_is_shared WORD_BITS _IO_save_base _S_empty_rep_storage wctob mon_thousands_sep fwprintf _M_assign _ZN9__gnu_cxx13new_allocatorIcE9constructEPcRKc _S_max_size __wchb find_last_not_of vfwscanf wint_t _ZNKSs5rfindEcj mblen vfwprintf _ZNKSs13get_allocatorEv __digits _ZNKSs6lengthEv __pad2 rbegin CpuId wcstoull INVALID_DATA_FORMAT OTHER_ERROR _M_copy _ZNKSs4findEPKcj _ZNKSs16find_last_not_ofEPKcj _ZN8CryptoPP20g_nullNameValuePairsE bsearch wmemmove fputwc _ZNSs4_Rep10_M_disposeERKSaIcE _ZN8CryptoPP9g_hasSSE2E _ZNKSs5c_strEv _ZNKSsixEj fputws _ZNSs4_Rep10_M_destroyERKSaIcE _ZNK8CryptoPP9Exception7GetWhatEv _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_PKcj __normal_iterator<char*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > _ZNSs2atEj _ZNKSs11_M_disjunctEPKc _ZNKSs6rbeginEv g_cacheLineSize SetWhat reverse_iterator<__gnu_cxx::__normal_iterator<char*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > wcschr find _next get_allocator _ZNSs4rendEv _ZNK8CryptoPP9Exception4whatEv _M_limit decimal_point address _Atomic_word SigIllHandlerCPUID _ZNK9__gnu_cxx13new_allocatorIcE8max_sizeEv fprintf _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_PKcS4_ result fclose strtoul _ZNKSs12find_last_ofEcj frac_digits m_what operator[] tmpfile allocator<char> _ZNKSs3endEv __val wcstombs <anonymous union> __tmp _ZNKSs13find_first_ofEcj thousands_sep _ZNSs3endEv _ZNSs4_Rep20_S_empty_rep_storageE _ZNK9__gnu_cxx17__normal_iteratorIPcSsE4baseEv _ZNKSs7_M_iendEv swscanf _ZNKSs12find_last_ofEPKcjj clearerr _ZNK9__gnu_cxx17__normal_iteratorIPKcSsE4baseEv n_sep_by_space _sbuf ungetc _IO_save_end wprintf tm_min srand p_cs_precedes _ZNK9__gnu_cxx17__normal_iteratorIPKcSsEixERKi wcscmp _ZNSs6assignEPKcj _ZNKSs5rfindEPKcjj stdout _ZN9__gnu_cxx17__normal_iteratorIPcSsEmIERKi mbsrtowcs _ZNSs6assignEjc mon_grouping _ZNKSs12find_last_ofERKSsj tm_yday mbsinit find_first_not_of _ZNSs7_M_leakEv _M_leak system _ZNKSs5beginEv short unsigned int g_isP4 signed char _ZNKSs5rfindEPKcj _ZNKSs17find_first_not_ofEPKcjj ptrdiff_t swprintf _M_replace_aux _ZN9__gnu_cxx17__normal_iteratorIPKcSsEmmEi vfprintf tm_wday __off64_t wcscpy wchar_t vswprintf _ZNK9__gnu_cxx17__normal_iteratorIPcSsEptEv putwc _IO_read_base _offset string _ZN9__gnu_cxx3absEx g_hasSSSE3 resize _IO_buf_end swap<CryptoPP::word32> mbstowcs _ZNSsixEj _ZN8CryptoPP5CpuIdEjPj mbstate_t n_sign_posn input _M_rep wcsrtombs ~new_allocator _ZNKSs4dataEv _mode _IO_write_base _M_data __wch _ZNSs6insertEN9__gnu_cxx17__normal_iteratorIPcSsEEc __max <anonymous struct> append vswscanf remove tm_mon copy _ZN8CryptoPP6g_isP4E _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_S2_S2_ long int fgetpos vwprintf nothrow _IO_marker int_p_sign_posn tm_year _ZNK8CryptoPP9Exception12GetErrorTypeEv _ZNKSs7compareEjjRKSs getc wscanf _ZNK9__gnu_cxx17__normal_iteratorIPcSsEplERKi _ZNK9__gnu_cxx17__normal_iteratorIPKcSsEmiERKi gets cpuid1 cpuid2 atof _ZNSs6appendEPKcj _ZNSs6insertEjPKcj mon_decimal_point _S_construct strtod strtof strtol long double reserve p_sep_by_space long unsigned int _ZN8CryptoPP9g_hasISSEE _ZNKSs13find_first_ofEPKcjj SetErrorType operator+= reverse_iterator<__gnu_cxx::__normal_iterator<const char*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > WORD_SIZE tmpnam _ZN9__gnu_cxx17__normal_iteratorIPcSsEppEi operator++ _ZN9__gnu_cxx17__normal_iteratorIPcSsEppEv _ZNSs6resizeEj GetErrorType _ZNSs13_S_copy_charsEPcN9__gnu_cxx17__normal_iteratorIPKcSsEES4_ _M_dataplus _ZNSsaSEPKc char push_back wcstold _S_terminal stdin insert _Rep _IO_buf_base operator-- _ZNSspLEc _ZNSs7_M_moveEPcPKcj operator-= operator-> _IO_read_end _IO_FILE _ZNKSs16find_last_not_ofEPKcjj wmemchr lword ~Exception _ZNSs7_M_dataEPc _ZNSs12_S_constructEjcRKSaIcE _ZNKSs8max_sizeEv tm_hour s_jmpNoSSE2 atoll fseek __min _ZNSs7replaceEjjRKSsjj basic_string<char, std::char_traits<char>, std::allocator<char> > getwchar int_n_sign_posn _ZNSs4_Rep11_S_terminalE tm_mday _S_compare c_str __pad1 __pad3 __pad4 __pad5 g_nullNameValuePairs new_allocator<char> fsetpos _markers _pos _M_length what vsprintf erase double INVALID_ARGUMENT _ZNKSs17find_first_not_ofERKSsj __FILE InvalidArgument _ZN9__gnu_cxx17__normal_iteratorIPKcSsEppEi _ZNKSs4rendEv _ZN9__gnu_cxx17__normal_iteratorIPKcSsEppEv qsort printf data ErrorType wmemcmp wcrtomb __value _ZNKSs15_M_check_lengthEjjPKc _ZNSs9push_backEc _ZN9__gnu_cxx24__numeric_traits_integerIiE8__digitsE _ZNK9__gnu_cxx17__normal_iteratorIPKcSsEptEv Exception _ZNKSs4_Rep12_M_is_leakedEv base positive_sign setvbuf _ZN9__gnu_cxx17__normal_iteratorIPKcSsEmIERKi _ZN8CryptoPP18g_x86DetectionDoneE empty construct _ZNSs6insertEjRKSsjj mbtowc _ZNKSs7compareEjjRKSsjj _M_dispose _ZN9__gnu_cxx24__numeric_traits_integerIiE5__minE _ZNSs4_Rep13_M_set_leakedEv long long unsigned int mbrtowc _cur_column _ZNSs4_Rep12_S_empty_repEv wmemcpy __compar_fn_t _ZNSs13_S_copy_charsEPcPKcS1_ _ZN9__gnu_cxx17__normal_iteratorIPcSsEpLERKi _ZNSs10_S_compareEjj _M_set_leaked vprintf _ZNSs4_Rep15_M_set_sharableEv _ZNSs4_Rep11_S_max_sizeE wcsncat fopen tm_gmtoff _ZNSs5eraseEjj _IO_backup_base int_n_sep_by_space _IO_read_ptr _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_jc m_errorType _M_mutate _ZNSsaSERKSs GNU C++ 4.3.3 getenv fgetwc _M_capacity _ZNSbIwSt11char_traitsIwESaIwEE4_Rep11_S_terminalE _ZN8CryptoPP15g_cacheLineSizeE fgetws rand basic_string _ZNKSs13find_first_ofERKSsj __normal_iterator _old_offset wcscoll exception SigHandler p_sign_posn wcsrchr compare long long int _ZNSs7replaceEjjjc _ZNKSs4sizeEv g_hasSSE2 _flags2 _ZNK9__gnu_cxx13new_allocatorIcE7addressERKc _ZNKSs8_M_checkEjPKc getchar _ZNKSs4findEPKcjj _ZNSs4_Rep10_M_refdataEv _ZNKSs7compareEjjPKcj word32 INFINITE_TIME _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_PKc _ZNKSs5rfindERKSsj NOT_IMPLEMENTED ungetwc find_last_of _ZN9__gnu_cxx3divExx n_cs_precedes _ZNSs15_M_replace_safeEjjPKcj _ZN9__gnu_cxx17__normal_iteratorIPcSsEmmEi _ZNKSs16find_last_not_ofERKSsj __state _ZN9__gnu_cxx17__normal_iteratorIPcSsEmmEv BERDecodeErr _ZNK9__gnu_cxx17__normal_iteratorIPcSsEixERKi localeconv _ZNSs6assignEPKc cpuid strtoull DetectX86Features _ZNK9__gnu_cxx17__normal_iteratorIPKcSsEplERKi _M_disjunct _ZNK9__gnu_cxx17__normal_iteratorIPKcSsEdeEv __is_signed unsigned int word64 _S_copy_chars fflush cryptopp/cpu.cpp _ZNSbIwSt11char_traitsIwESaIwEE4nposE short int begin int_p_cs_precedes __jmp_buf _vtable_offset _M_is_leaked _ZNSs6resizeEjc _M_leak_hard npos /home/bitcoin/bitcoin/trunk ~allocator __quad_t find_first_of  GCC: (Ubuntu 4.3.3-5ubuntu4) 4.3.3  .symtab .strtab .shstrtab .rel.text .data .bss .debug_abbrev .rel.debug_info .rel.debug_line .rodata.str1.1 .rel.debug_frame .debug_loc .rel.debug_pubnames .rel.debug_aranges .debug_ranges .debug_str .comment .note.GNU-stack                                                       @                       	           |                %                                 +                \                  0                                  B              	  @<                 >   	           }                 R              BE                   N   	                            ^      2       H                   q              H                    m   	             P               ~              I  6                               J                       	                                           jK                        	           (                               K                           0       K  ?(                              s  $                                t                                   t                                  x                 	              z                                                                                                                                   	       Q     !   p       D            `                                  
-                                                                                                                                                `                                                  2          J          _           ~                         cpu.cpp _ZN8CryptoPPL7TrySSE2Ev _ZN8CryptoPPL17SigIllHandlerSSE2Ei _ZN8CryptoPPL11s_jmpNoSSE2E _ZN8CryptoPPL18SigIllHandlerCPUIDEi _ZN8CryptoPPL12s_jmpNoCPUIDE signal _setjmp _ZN8CryptoPP5CpuIdEjPj _ZN8CryptoPP17DetectX86FeaturesEv _ZN8CryptoPP8g_hasMMXE _ZN8CryptoPP9g_hasSSE2E _ZN8CryptoPP10g_hasSSSE3E _ZN8CryptoPP9g_hasISSEE _ZN8CryptoPP6g_isP4E _ZN8CryptoPP15g_cacheLineSizeE _ZN8CryptoPP18g_x86DetectionDoneE longjmp           (     -     E     j     ~                         '    A    O    f    r    {                                         4    B    Y          !        !                                !     (     -     ?     L     j     q     w     C    M    _    o            p    w                                                        $    +    2    7    n                                        #    ?    E    [    a    }                        C    _    d    o    |                                            !    0    ?    N    ]    l    {                                    	    	     	    0	    ;	    G	    P	    \	    h	    t	    	    	    	    	    	    	     
-    "
-    ?
-    \
-    y
-    
-    
-    
-    
-        *    M    z                        /    Q    x                        .    J    f                                         .    <    J    Z    q                        <    H    f    l                    
-    ,    M    n                            1    S    q    w                                            %    3    t                                3    T    p                         8    P    ]    t                                >    [    h                            A    M    [    i    w                                                    -    ;    I    W    e    s                                    0    7    B    R    X    _    f    }                                                <    C    e    l                                             <    C    _    f                                    
-            2    K    d                        .    5    P    W    r    y                                    %    ,    B    I    _    f    |                                                1    8    O    V    h    o                                    -    4    O    V    q    x                                      /     6     M     S     n     u                                   
-!    !    2!    9!    Y!    `!    !    !    !    !    !    !    	"    "    0"    7"    W"    ^"    y"    "    "    "    "    "    #    	#    3#    :#    _#    f#    #    #    #    #    #    #    $     $    J$    Q$    {$    $    $    $    $    $    %    %    @%    G%    r%    x%    %    %    %    %    %    %    %    &    &    #&    9&    @&    e&    l&    &    &    &    &    &    &    '    '    -'    4'    T'    ['    {'    '    '    '    '    '    '    '    (    #(    C(    J(    o(    v(    (    (    (    (    (    (    )    )    7)    >)    ^)    e)    )    )    )    )    )    )    )    *    &*    -*    H*    O*    t*    {*    *    *    *    *    *    *    _+    m+    {+    +    +    +    +    +    +    +    +    +    +     ,    ,    ,    ",    4,    :,    L,    R,    i,    o,    ,    ,    ,    ,    ,    ,    ,    ,    -    -    (-    /-    f-    q-    {-    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    .    .    %.    2.    ?.    E.    P.    V.    a.    g.    r.    x.    .    .    .    .    .    .    .    .    .    .    .    .    .    .    /    /    //    ;/    X/    d/    /    /    /    /    /    0    X0    p0    0    0    0    0    1    1    21    T1    u1    1    1    1    1    2     2    A2    b2    ~2    2    2    2    2    2    3    %3    :3    T3    [3    q3    x3    3    3    3    3    3    3    3    3    4    4    .4    54    P4    W4    r4    y4    4    4    4    4    4    5    $5    >5    E5    [5    b5    x5    5    5    5    5    5    5    5    5    5    6    6    :6    A6    \6    c6    ~6    6    6    6    6    7    7    %7    j7    7    7    7    7    7    8    48    S8    Y8    w8    }8    8    8    8    8    8    8    "9    <9    @9    D9    M9    X9    f9    p9    9    9    9    9    9    9    9    9    9    9    9    9    9     :    :    :    :    :    C:    G:    K:    a:    e:    i:    {:    :    :    :    :     :    :    :    :    ;    ;    $;    +;    6;    =;    N;    Y;    c;    i;    t;    z;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    <    <    <    <    $<    /<    5<                  4     8     T     X     t     x                              
\ No newline at end of file
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/obj/sha.o bitcoin-0.3.20/src/cryptopp/obj/sha.o
--- bitcoin-0.3.20.orig/src/cryptopp/obj/sha.o	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/obj/sha.o	1970-01-01 01:00:00.000000000 +0100
@@ -1,150 +0,0 @@
-ELF                      <     4     ( ' $                       UE #Eg@@@vT2@]    U  E  P  P  P  P  P  P  P   P   P$  P(  P,  P0  P4  P8  P<]&    U   E$  P(  P,  P0  P4  P8  P<  P@  P D  P$H  P(L  P,P  P0T  P4X  P8\  P<]&    U  U  B  B  B  B  B  B  B]&    U  U  B  B  B  B  B  B  B]&    U=     ]]u}uE   UHL    )SUpSL$hT$l|$pt$d|$   t$d    \$`Z\$\Z\$XZ\$TZ\$PZ\$LZ\$HZ\$DZ \$@Z$\$<Z(\$8Z,\$4Z0\$0Z4\$,Z8\$(Z<\$$|$D$3D$L$T$3T$!3T$T$`T$ 113L$!3D$T$T$11D$ |$3|$!3|$~|$\|$113D$!3L$|$|$11L$T$3T$!3T$VT$XT$113L$ !3D$ T$T$11D$|$3|$!3|$~|$T|$113D$!3L$|$|$11L$T$3T$!3T$VT$PT$113L$!3D$T$ T$ 11D$|$3|$!3|$~|$L|$113D$!3L$|$|$11L$T$ 3T$!3T$VT$HT$113L$!3D$T$T$11D$|$3|$ !3|$ ~|$D|$113D$!3L$|$|$11L$T$3T$!3T$V T$@T$ 113L$!3D$T$T$11D$ |$3|$!3|$~$|$<|$113D$!3L$|$|$11L$T$3T$!3T$V(T$8T$113L$ !3D$ T$T$11D$|$3|$!3|$~,|$4|$113D$!3L$|$|$11L$T$3T$!3T$V0T$0T$113L$!3D$T$ T$ 11D$|$3|$!3|$~4|$,|$113D$!3L$|$|$11L$T$ 3T$!3T$V8T$(T$113L$!3D$T$T$11D$|$3|$ !3|$ ~<|$$|$113D$!3L$|$|$11L$@T$3T$!3T$11l$(|$\
-11\$<\$`1T$ 1l$`3L$!3D$T$T$11D$ |$3|$!3|$11l$$T$X
-11\$8\$\1~|$1l$\3D$!3L$|$|$11L$T$3T$!3T$11l$`|$T
-11\$4\$X1VT$1l$X3L$ !3D$ T$T$11D$|$3|$!3|$11l$\T$P
-11\$0\$T1~|$1l$T3D$!3L$|$|$11L$T$3T$!3T$11l$X|$L
-11\$,\$P1VT$1l$P3L$!3D$T$ T$ 11D$|$3|$!3|$11l$TT$H
-11\$(\$L1~|$1l$L3D$!3L$|$|$11L$T$ 3T$!3T$11l$P|$D
-11\$$\$H1VT$1l$H3L$!3D$T$T$11D$|$3|$ !3|$ 11l$LT$@
-11\$`\$D1~|$1l$D3D$!3L$|$|$11L$T$3T$!3T$11l$H|$<
-11\$\\$@1V T$ 1l$@3L$!3D$T$T$11D$ |$3|$!3|$11l$DT$8
-11\$X\$<1~$|$1l$<3D$!3L$|$|$11L$T$3T$!3T$11l$@|$4
-11\$T\$81V(T$1l$83L$ !3D$ T$T$11D$|$3|$!3|$11l$<T$0
-11\$P\$41~,|$1l$43D$!3L$|$|$11L$T$3T$!3T$11l$8|$,
-11\$L\$01V0T$1l$03L$!3D$T$ T$ 11D$|$3|$!3|$11l$4T$(
-11\$H\$,1~4|$1l$,3D$!3L$|$|$11L$T$ 3T$!3T$11l$0|$$
-11\$D\$(1V8T$1l$(3L$!3D$T$T$11D$|$3|$ !3|$ 11l$,T$`
-11\$@\$$1~<|$1l$$3D$!3L$|$|$11L$;t$dT$l@l$hT$lM }D$\$L$E]MD$\$L$ E]M;T$p2\][?u}]]&    '    U=     ]]u}uE   UHL    )SUpSL$hT$l|$pt$d|$   t$d    \$`Z\$\Z\$XZ\$TZ\$PZ\$LZ\$HZ\$DZ \$@Z$\$<Z(\$8Z,\$4Z0\$0Z4\$,Z8\$(Z<\$$|$D$3D$L$T$3T$!3T$T$`T$ 113L$!3D$T$T$11D$ |$3|$!3|$~|$\|$113D$!3L$|$|$11L$T$3T$!3T$VT$XT$113L$ !3D$ T$T$11D$|$3|$!3|$~|$T|$113D$!3L$|$|$11L$T$3T$!3T$VT$PT$113L$!3D$T$ T$ 11D$|$3|$!3|$~|$L|$113D$!3L$|$|$11L$T$ 3T$!3T$VT$HT$113L$!3D$T$T$11D$|$3|$ !3|$ ~|$D|$113D$!3L$|$|$11L$T$3T$!3T$V T$@T$ 113L$!3D$T$T$11D$ |$3|$!3|$~$|$<|$113D$!3L$|$|$11L$T$3T$!3T$V(T$8T$113L$ !3D$ T$T$11D$|$3|$!3|$~,|$4|$113D$!3L$|$|$11L$T$3T$!3T$V0T$0T$113L$!3D$T$ T$ 11D$|$3|$!3|$~4|$,|$113D$!3L$|$|$11L$T$ 3T$!3T$V8T$(T$113L$!3D$T$T$11D$|$3|$ !3|$ ~<|$$|$113D$!3L$|$|$11L$@T$3T$!3T$11l$(|$\
-11\$<\$`1T$ 1l$`3L$!3D$T$T$11D$ |$3|$!3|$11l$$T$X
-11\$8\$\1~|$1l$\3D$!3L$|$|$11L$T$3T$!3T$11l$`|$T
-11\$4\$X1VT$1l$X3L$ !3D$ T$T$11D$|$3|$!3|$11l$\T$P
-11\$0\$T1~|$1l$T3D$!3L$|$|$11L$T$3T$!3T$11l$X|$L
-11\$,\$P1VT$1l$P3L$!3D$T$ T$ 11D$|$3|$!3|$11l$TT$H
-11\$(\$L1~|$1l$L3D$!3L$|$|$11L$T$ 3T$!3T$11l$P|$D
-11\$$\$H1VT$1l$H3L$!3D$T$T$11D$|$3|$ !3|$ 11l$LT$@
-11\$`\$D1~|$1l$D3D$!3L$|$|$11L$T$3T$!3T$11l$H|$<
-11\$\\$@1V T$ 1l$@3L$!3D$T$T$11D$ |$3|$!3|$11l$DT$8
-11\$X\$<1~$|$1l$<3D$!3L$|$|$11L$T$3T$!3T$11l$@|$4
-11\$T\$81V(T$1l$83L$ !3D$ T$T$11D$|$3|$!3|$11l$<T$0
-11\$P\$41~,|$1l$43D$!3L$|$|$11L$T$3T$!3T$11l$8|$,
-11\$L\$01V0T$1l$03L$!3D$T$ T$ 11D$|$3|$!3|$11l$4T$(
-11\$H\$,1~4|$1l$,3D$!3L$|$|$11L$T$ 3T$!3T$11l$0|$$
-11\$D\$(1V8T$1l$(3L$!3D$T$T$11D$|$3|$ !3|$ 11l$,T$`
-11\$@\$$1~<|$1l$$3D$!3L$|$|$11L$;t$dT$l@l$hT$lM }D$\$L$E]MD$\$L$ E]M;T$p2\][?u}]]&    '    UWV@UEBEBEBEBEBEBEBEB EB$EB(EB,EB0EB4EB8EB<=     Eu    @      UM)SUpSL$hT$l|$pt$d|$   t$d    \$`Z\$\Z\$XZ\$TZ\$PZ\$LZ\$HZ\$DZ \$@Z$\$<Z(\$8Z,\$4Z0\$0Z4\$,Z8\$(Z<\$$|$D$3D$L$T$3T$!3T$T$`T$ 113L$!3D$T$T$11D$ |$3|$!3|$~|$\|$113D$!3L$|$|$11L$T$3T$!3T$VT$XT$113L$ !3D$ T$T$11D$|$3|$!3|$~|$T|$113D$!3L$|$|$11L$T$3T$!3T$VT$PT$113L$!3D$T$ T$ 11D$|$3|$!3|$~|$L|$113D$!3L$|$|$11L$T$ 3T$!3T$VT$HT$113L$!3D$T$T$11D$|$3|$ !3|$ ~|$D|$113D$!3L$|$|$11L$T$3T$!3T$V T$@T$ 113L$!3D$T$T$11D$ |$3|$!3|$~$|$<|$113D$!3L$|$|$11L$T$3T$!3T$V(T$8T$113L$ !3D$ T$T$11D$|$3|$!3|$~,|$4|$113D$!3L$|$|$11L$T$3T$!3T$V0T$0T$113L$!3D$T$ T$ 11D$|$3|$!3|$~4|$,|$113D$!3L$|$|$11L$T$ 3T$!3T$V8T$(T$113L$!3D$T$T$11D$|$3|$ !3|$ ~<|$$|$113D$!3L$|$|$11L$@T$3T$!3T$11l$(|$\
-11\$<\$`1T$ 1l$`3L$!3D$T$T$11D$ |$3|$!3|$11l$$T$X
-11\$8\$\1~|$1l$\3D$!3L$|$|$11L$T$3T$!3T$11l$`|$T
-11\$4\$X1VT$1l$X3L$ !3D$ T$T$11D$|$3|$!3|$11l$\T$P
-11\$0\$T1~|$1l$T3D$!3L$|$|$11L$T$3T$!3T$11l$X|$L
-11\$,\$P1VT$1l$P3L$!3D$T$ T$ 11D$|$3|$!3|$11l$TT$H
-11\$(\$L1~|$1l$L3D$!3L$|$|$11L$T$ 3T$!3T$11l$P|$D
-11\$$\$H1VT$1l$H3L$!3D$T$T$11D$|$3|$ !3|$ 11l$LT$@
-11\$`\$D1~|$1l$D3D$!3L$|$|$11L$T$3T$!3T$11l$H|$<
-11\$\\$@1V T$ 1l$@3L$!3D$T$T$11D$ |$3|$!3|$11l$DT$8
-11\$X\$<1~$|$1l$<3D$!3L$|$|$11L$T$3T$!3T$11l$@|$4
-11\$T\$81V(T$1l$83L$ !3D$ T$T$11D$|$3|$!3|$11l$<T$0
-11\$P\$41~,|$1l$43D$!3L$|$|$11L$T$3T$!3T$11l$8|$,
-11\$L\$01V0T$1l$03L$!3D$T$ T$ 11D$|$3|$!3|$11l$4T$(
-11\$H\$,1~4|$1l$,3D$!3L$|$|$11L$T$ 3T$!3T$11l$0|$$
-11\$D\$(1V8T$1l$(3L$!3D$T$T$11D$|$3|$ !3|$ 11l$,T$`
-11\$@\$$1~<|$1l$$3D$!3L$|$|$11L$;t$dT$l@l$hT$lM }D$\$L$E]MD$\$L$ E]M;T$p2\][@^_]t& UWVS  UEBEBEBEBEBEBEBEB EB$EB(EB,EJ0MR4UC8EC<DUuPMEE}LU    8<HX\  &    ][ $M]pt $t8<p(,(,1t1p1D1PPD3d#p3T#t11M]MM]]u}  $$111E3E1U3UEU1!1!3E3UM]M]]u  l  h(,x,  ]K[M](,HL11  1T1ddT3l#3h#11M]MM]]u}111E3E1U3UEU1!1!3E3UMM]]u]    x|04)  ]K[(,04X\111h1llh3|#3x#11(,MM]]u}  111E3E1U3UEU1!1!3E3UMM]]u]    8<&  ]K[048<pt111x1||x3#3#1104MM]]u}111E3E1U3UEU1!1!3E3UMM]]u]   $  @D#  ]K [$8<@D11113#3#118<MM]]u}111E3E1U3UEU1!1!3E3UMM]]8u<](  ,  HL   ]K([,@D8<HL<81<18113#83#<11@DMM]]u}111E3E1U3UEU1!1!3E3UMM]]HuL]0  4  40PT  ]K0[4HLHLPTLH1L1H1134#H30#L11HLMM]]u}111E3E1U3U|ExU1!|1|!x3Ex3UMM]]Xu\]8  <  PDX\  ]K8[<PTX\X\\X1t\1pXpt1014403P#X3D#\11PTMM]]u}11lhlh1E3E1U3UdE`U1!d1d!`3E`3UMM]]put]@  D  dT`d  ]K@[DX\pt`dt8<p1\t1XpX\1D1PPD3d#p3T#t11X\MM]]u}11TPTP1E3E1U3ULEHU1!L1L!H3EH3UMM]]u]H  L  lhhl  ]KH[L`dhlHL1D1@@D1T1ddT3l#3h#11`dMM]]u}11<8<81E3E1U3U4E0U1!414!03E03UMM]]u]P  T  x|pt  ]KP[ThlptX\1,1((,1h1llh3|#3x#11hlMM]]u}11$ $ 1E3E1U3UEU1!1!3E3UMM]]u]X  \  x|z  ]KX[\ptx|ptx|x|111x1||x3#3#11ptMM]]u}pptt111E3E1U3UE U1!1! 3E 3UM]M]]u`  d  u  ]K`[dx|hlhl11113#3#11x|MM]]u}``dd111E3E1U3UEU1!1!3E3UMM]]8<u]h  l    ]Kh[lM]8<<8X\X\1<18113#83#<11M]MM]]UM11}3}u1E133uU3!E!U1u1}M]]Lp  ut  H04  ]Kp[tM]HLLHPTPT1L1H1134#H30#L11M]MM]]UM11}3}u1E133uU3!E!U1u1}M]]x  \u|  XDP  ]Kx[| M]X\HXL\HL1X1\1014403P#X3D#\11u}u}UMUEM@UD@D1E1U1E3E1U3UE3EU!3U!3E3UEPU  u]MTt]     pd $ $M]1111EU1111EUMU$ @     $$  $111 1]M]u1111EUMU :t&    1111]M]u1111EUMUut& 1111]M]u1111EUMUt& 1111|xx|1111x||xt& 1111tppt1111pttpt& 1111lhhl1111hllht& 1111d``d1111`dd`t& 1111\XX\1111X\\Xt& 11$11T PPT1111PTTPt&  HL1111HL1111HLLH@D1111@D1111@DD@8<11118<11118<<80411110411110440(,111 1$(, $ $1111(,,(M ]  1111EU1111EUMUM]uQYqAQYqEUA XQ$\A(HQ,LY08q4<A8Q<  [^_]fUWVS  EU  EXpHPEx yZ1!1BTyZ1# 1 EBXyZE1!1B\yZE1!3EJE`yZLJ1!1LyZhddE1#1EBlyZ1#E1EEBpyZE1!1B tyZE1!3EJ$ExyZJ(H1!1HyZ||E1#1EB,yZ1#E1EEB0yZE1!1B4yZE1!3EJ8ER<yZD1!1DyZX3tE1#1EP111yZU#E1\3Tx11yZ1!1`3X11yZ1!1h3\11yZ1!1l3`33E11nEp3h11n13EEEt3l11nE11x3p11nE113t11En@11@3xE1113nE311n13EEE311nE11311nE11311En<11<3E1113nE311n13EEE311nE11311nE11111En81183E31113nE1113En3U11n113 1 1   n11311n11E311	!!	E31 1EU	!!	UU311UE!	!	311!	#E	311U4	!!	4E311!	!	 E311U E!	!	EE311E$U	!!	311	#E(!	31 1E,0	!!	0E31$1	0!!	E31(1E4U	!!	UU 31,1U8E	!!	3101!<	#E	 3 141U@,	!!	,$E3181!D	!	(E31<1UHE!	!	EE,31@1ELU	!!	031D1	#EP!	431H1ET(!	!	( 3X81XL1XXXb11$3\<1\P1\\\b11(3 `@1`T1```b11,3$dD1dX1dddb1103(hH1h\1hhhb1143,lL1l`1lllb11830pP1pd1pppb11<34tT1th1tttb11@38xX1xl1xxxb11D3<|\1|p1|||b11H3@E`1Et1EMEb11L3DEd1Ex1EMEb11UPE3H3h3|11bT3LEl1EE1EMEbE11Xp3P1E1EMb\$11$3TEt111`3bME3X3x3U13EbEEd1\|1\E1\\\bE11`1hE1hE1hhhbE11d1lE1l1ll lb1U1UJZrz  [^_]   %RU   :;I  $ >  $ >  9:;   :;  9 :;   <  	 <  
- :;  <  :;   I8
-2   :;I8
-  .?:;<   I4   I  4 :;@I?<  $ >  9:;  .?:;@I<  .?:;@I<  : :;   G:;      I  &   G:;  .?:;<  .?:;@I<  .?:;@<   .?:;@<  !& I  " I  #.?:;<  $:;  % I  & :;I  ':;  (:;  ) :;I  * :;I8
-  +I  ,! I/  -.?:;I<  .   /. ?:;I<  0.?:;I<  1:;  2 :;  3.?:;<  4. ?:;I<  5G:;  64 :;@I?<  7 :;I8
-2  8.?:;@I2<  9.?:;@2<  :. ?:;@I2<  ;.?:;@I<  <.?:;@I<  =.?:;@<  >.?:;@I2<  ?.?:;@I<  @. ?:;@I<  A<  B:;  C(   D.:;<  E4 :;I<  F4 :;I<  G4 :;I<  H :;I8
-  II  J   K.?:;I<  L.?:;@2<  M.?:;@I<  N.?:;@I2<  OG:;  P.?:;@<  Q.?:;@<  R :;I8
-2  S.?:;2<  T.?:;@2<  U.?:;@I2<  VG:;  W.?L4<  XG:;  Y.?4<  Z.?:;L<  [.?:;@ILM
-<  \.?:;I 4  ] :;I  ^.G   _ :;I  `. G   a :;I  b I4  c.G:;@  d :;I
-  e.G:;@  f :;I
-  g4 :;I
-  h4 :;I
-  i :;I  j4 
-  k.1@  l 1  m4 :;I  n  o4 :;I  p  q 1  r4 1  s  t1XY  u I4
-  v :;I  w 1UXY  x1UXY  y4 1  zU  {1UXY  | 1XY  }4 :;I  ~4 :;I  1XY  1UXY  1XY  4 :;I?<  4 G  4 G  4 G
-  4 :;@I?<  4 :;@I?<  4 :;@I?<  4 :;@I?<   k       b  -Z  n          `	      N  k4     ?>  F   int &  X   j  std (   8  9  8  6)  	E6  H	  	  	  	  	  
-  )
-  F
-  c
-  
-  
-  
-  
-  
-    7  d              ;  b              4  P  l  D  [  }          2  V  w            7  X  y              
-=  
-a  
-  	dO  	e_  	gj  	h  	i  	j  	k  	l  	m  	n  	o>  	pZ  	sw  	t  	v  	w  	x
-  	z"  	{:  	|G  	}^  	~r  	  	  	  	  	  	  	(  	E  	R  	i  	  	  	  	  	  
-<,  
-=  
->  T        # r    #            	{L  	0  k/  l/  p*0  qI0  ra0  sy0  t0  v0  y0  {0  ~1  ,1  M1  o1  1  1  1  1  1  2  02  Q2  /      m2  2  2  2  2   3  	d  iF  Ia"  i   =  J  	QV  	0  	/  abs `A         div g  /        7<  J  H]  Q<  k  E  Re  e  =5  >x       GK    7  Y  El     Y  G       +C  L    F    3  O%%           3  Rf             W;
-        X   E   4	  as  )      X    9  e3  M   E     z\  kA+  g          '  vf          6O    !  "  "  L  "  !L       T  L  # %
-  b     %
-  d       #9o  j  F       "!  !  ,  ?  9  !,  !F   !H  c  o%  1Z  $ER  	  '  F   # `    #P    #u@    #C    #!    #Y    #O    #A    # q*    #$`    #(9     #,mV  "-  #0i  $3  #4h  &F   #8e  *F   #<Md  ,  #@]  0  #Dl  1  #F3  29  #G
-  6I  #H@  ?  #LAU  HC  #T+  IC  #XHU  JC  #\OU  KC  #`VU  LM   #dC  NF   #h  PO  #l X  AZ    +1	  %    &+  cX   'E  O	  (k6  Rv	  )xD  TX   )}+  X	   *'  PF   # *%Z  YS	  # +  	  ,	   vB  eG	  -.  O;	  	  F    -b  ;	  	  	   	  -c  &  
-  &  F   	   --  ;	  )
-  ,  	   -.  F   F
-  3  	   -S  F   c
-  	  F    -.+  XF   
-  	  3  . -  GF   
-  	  3  . -z  ;	  
-  	   /T  ;	  -3  ZM   
-    M   
-   	  -~]  :M     &    M   
-   -;  4F   ,  ,   2  !	  -6;  M   ^  &  ^  M   
-     -o@  ;	    ,  	   -~  ;	    ,   -I>  F     &  M   3  . -8  RF     3  3  . -g  ;	    ;	  	   -+  lF     	  3  &	   -+  ~F   ;  	  3  &	   -?  :F   b  &  M   3  &	   -.E  F     3  3  &	   -`F  eF     3  &	   -:  F     3  &	   -Z  M       ,  
-   0P"  &    &  3   0e:  F     3  3   0d  F   4  3  3   0f?  &  P  &  3   0}&  M   l  3  3   -  $M     &  M   3       !  1tm ,D  *  F   # *9  F   #*AS  F   #*(U  F   #*EE  F   #*F  F   #*T?  F   #*;  F   #*
-  F   # *_    #$*R    #( 0K  M   [  3   -_  &  }  &  3  M    0  F     3  3  M    0  &    &  3  M    -B  M         M   
-   3  0  M     3  3   -  %  %  3  ,   ~W  &  -  O  O  3  ,   m  0  &  w  &  3  ,   -      3  ,  F    -O      3  ,  F    08  M     &  3  M    -+  UF     ;	   -Y  F     3  3  M    0]  (&  7  &  3  M    0-  F&  X  &  3  M    0  &  y  &  ,  M    -9  RF     3  . -F  MF     3  . 021  &    3  ,   01   &    3  3   0Be  &    3  ,   0  &    3  3   -mR  &  =  3  ,  M    -EO  Z  Z  3  ,   MI  -i
-      3  ,  F    -,      3  ,  F    o  8  	    \?    'E    **    # *h  G	  # 2@  'qF  -  *1  -  # *9  3  #*vV  F   #   Z  +  I  ,	      +  _  ,	  '   [  3f9  ~  ~   O  04  F     ~   -  F     ~   -  F     ~   0k  F     ~   -  F     ~   -E  F     ~     _  0    >    F   ~   0_  ~  Z       04  `F   w  ~    . -!  M     C  M   M   ~   -D  ~        ~   -S  F     ~    F    -eV  F     ~       !_  -#    "  ~   -F  F   :  ~   4Pf  -F   0]G    ^     3d(  /r     0Y  gF       . 0  PF     F    07E  F        0  F          3    ~   3c  3  ~     -[  8F   (  ~    F   M    0D   F   E      . 4=6  ~  0M    i     -9  F     F   ~   0K?  ~F     ~    &	   0^  sF       &	   0	W  ,F         &	   0w  >F       M     . 0q  KF   ,    M     &	   '   87  *2  :  # *6  ;  #*
-  A  #*#  G  #*  H  #*H  I  #*+  J  #*P;  K  #*[  L  # *!  M  #$*'  N  #(*55  O  #)*(:  Q  #**J  S  #+*g  U  #,*9  W  #-*6e  ^  #.*B  _  #/*k  b  #0*g  d  #1*p  f  #2*`  h  #3*|F  o  #4*T  p  #5 0  }    F      4	i    ,  
-3  %F   [  5Q  8*  6zn    *  7O  [  #   qO  8C  )    !  *   8C  R    D  *     8B    *  b  *   8%  #n"      *   8  '8      *   9;  +;    *   8  2;f  M     *  X      9	  :>Z  	  *  X   X      8Z2  B  M   1  *  X   X    8nj  Jr0  H  T  *     9-,  S  w      X    9`  \dP        X    97+  e      X      9k  x           9k  |N           9k    &         9k  .^  I         80U  ^  F   k  X   X    9a  &    *  X   X   X    9n  J    *   :5  L  *  3d    *   d    *     d    *  *   d  +  *  *  X   X    d  S  *  *  X   X      d  v  *    X      d    *       d    *  X        3B"    *  F    ;  |b  *    *  *   ;  *O  *    *     ;  #  *  8  *     ;k  S    U  *   ;k  (<    r  *   <end '7      *   <end 2U6      *   ;+  ;B      *   ;+  D0      *   ;  M1      *   ;  VX       *   ;Q%  ^se  M   =  *   ;  d+  M   Z  *   ;9  i/S  M   w  *   =A  gm    *  X      =A  [N    *  X    ;F    M     *   =I  s     *  X    =w&      *   ;t\    H  )  *   ;q5  .    K  *  X    ;q5  lB    m  *  X    <at :      *  X    <at g0      *  X    ;pL    *    *  *   ;pL  
-!  *    *     ;pL  O  *    *     ;'E  C%  *  7  *  *   ;'E  TF  *  c  *  *  X   X    ;'E  (/H  *    *    X    ;'E  C   *    *     ;'E  T(  *    *  X      =;O  fZ    *       b  *     *  *   ;    *  >   *  *  X   X    ;  :  *  e   *    X    ;  pi  *     *     ;  @;  *     *  X      =jO  "     *    X      ;jO    *     *  X   *   ;jO  \  *  .!  *  X   *  X   X    ;jO  fH  *  Z!  *  X     X    ;jO  +  *  !  *  X      ;jO  BH  *  !  *  X   X      ;jO  SD    !  *       ;xW  k`  *  !  *  X   X    ;xW  {k(    "  *     ;xW  ~    D"  *       ;   #  *  p"  *  X   X   *   ;  S  *  "  *  X   X   *  X   X    ;  c  *  "  *  X   X     X    ;    *  #  *  X   X      ;  `e  *  4#  *  X   X   X      ;    *  `#  *      *   ;  &/  *  #  *        X    ;  ;f  *  #  *         ;  Pa  *  #  *      X      ;  tZ  *  $  *           ;  4  *  P$  *           ;  yE  *  $  *           ;  b  *  $  *           8>  9(  *  $  *  X   X   X      8_%  g  *  %  *  X   X     X    >H  S    <%  X        ;LE  a  M   h%  *    X   X    =    %  *  *   ;;U  .    %  *   ;Y  :C    %  *   ;1  +    %  *   ;91  Xf  M   	&  *    X   X    ;91  +-  M   0&  *  *  X    ;91  9,  M   W&  *    X    ;91    M   ~&  *    X    ;  Wf  M   &  *  *  X    ;  :  M   &  *    X   X    ;  s]<  M   &  *    X    ;  +  M   '  *    X    ;o  d  M   F'  *  *  X    ;o  K  M   r'  *    X   X    ;o  R  M   '  *    X    ;o  }6  M   '  *    X    ;g  e;  M   '  *  *  X    ;g  &/9  M   (  *    X   X    ;g  ("  M   :(  *    X    ;g  4  M   a(  *    X    ;;  UX  M   (  *  *  X    ;;  ;>  M   (  *    X   X    ;;  ((  M   (  *    X    ;;  G%  M   )  *    X    ;+  Fg  M   ))  *  *  X    ;+  RNR  M   U)  *    X   X    ;+  cY-  M   |)  *    X    ;+  g6  M   )  *    X    ;	      )  *  X   X    ;Je  $  F   )  *  *   ;Je  {F  F   *  *  X   X   *   ;Je  \  F   N*  *  X   X   *  X   X    ;Je  #  F   p*  *     ;Je    F   *  *  X   X      ?Je  f  F   *  X   X     X     !M   *  !      "  "*  "  5  /+  *V  M   # *c  M   #*    # 5  ,  *  # q+  8_  *  MO  =U    +  I7  ,  @5  ]  *  m  b[  H  +   -   Z*  .  H  +   -   ^  ,]  +  *     ^  +  *   s    ,  *  X    W  jf    ),  *   R*      O,  *       ;  
-y
-  *  u,  X   X      \  -  ,  *     =[  ".  ,  *       J    ,  *   ?V%  W    *    X     +M    -  ,	   -  !/+    m/  AX[  T-  BY   rCf   CW  C    Cm  C,  C?  C!,    	  	uX  	J9  	(  	5,  	W  	B  	C  	$  	1  	a  	%/  	  	Kh  	J  	)a  	yg  	  	M  	R>  	cU  	x  	Yd  	  	
-  	  	h  	X  -/
-  B<  .  B<   4];  +H  D/  =.  e<  k<  M    -'    Z.    X    3  x.  e<  k<  X    -F  X   .  X   X    E  |h  FM  3  Fg*  3   Ef   `i  	  6V   Hw-  i  64     Q  H  R\  H  e  -  H  W"  J  H  5#    H  tA  )  H  J<  [E  H  0   {c  B<  +	  f-  i  GpE  pi   'E  !c/  *'  !dF   # Hrem !eF   # 'E  !k/  *'  !l  # Hrem !m  # 'E  !w0  *'  !x  # Hrem !y  # &]  !0  0  IF   *0  E  E   -  !F   B0  B0   H0  J-G  !%  a0     -h  !F   y0     -m  !!  0     --  !C  0  E  E  M   M   0   Kdiv !/  0  F   F    -b  !!  0     -%  !/  1       -+  !F   ,1    M    0A  "rM   M1  &    M    -\  !F   o1  &    M    3Y  !1  C  M   M   0   /d  !|F   3":  !~1  X    08I  !%  1    1     0FI  !  1    1  F    04  !  2    1  F    -;  !F   02     0b6  "M   Q2    3  M    0  "TF   m2    ,   -  !/  2       -gS  !*  2     0   !  2    1  F    0i  !  2    1  F    0?I  !O   3    1   0k   !Z  3    1   T-  #3  3  #$  3  I3  3  3   3  #%C  3  j3  3  3   z\  #&1F  3  4  3  3   '  #'   3  4  3   9  #(
-  M   3  3   L  #+9  X     X   3  !X   "X   "3  3  !3  3  Z-  #4  3  #$d  4  54  4  4   3  #%%V  4  V4  4  4   z\  #&pT  x4  4  4  4   '  #')  4  4  4   9  #(  M   4  4   L  #+I  X       4  !  "  "4  4  !4  4  `-  #j5  3  #   #	e  3  /5  j5  X   E   4	  #W  Q5  j5  C  X    M9  #L  M   p5    4  v5  !4  f-  H#6  3  # 7q
-  #6  # 7  #4  #@7T  #H  #AIS  #5  6     #p  3  5  6  X      #i  3  6  6  X   E   4	  #7  =6  6  C  X      #?  3  m6  6  3  X   X   H   ;9  #9   M   6  6   Nd  #
-bG  3  6    +X   6  ,	   {5  6  !{5  Ol-  P#:  0  #{5  # c  #M   #HB  #3  #L3x7  #7  :  X    3x7  #47  :  :   3x7  #S7  :  3  X    3,;  #)n7  :  F    ;O  #0b  E  7  :   ;L  #2  C  7  :   ;*  #5R  3  7  :   ;g  #7c  3  7  :   ;k  #G_  3  7  :   ;k  #Il:  3  8  :   <end #KB  3  98  :   <end #Mc  3  V8  :   ;Y  #P*  3  s8  :   ;Y  #Q  3  8  :   ;Q%  #S  M   8  :   ;t\  #T;  H  8  :   ;3  #V  :  8  :   ;3  #W%  :  9  :   ;O  #X/k  M   !9  :   =  #[m  D9  :  3  X    =  #b]  b9  :  :   ;  #h@  :  9  :  :   ;pL  #o  :  9  :  :   ;\  #xt<  6  9  :  :   ;j  #A  H  9  :  :   ;'  #I  H  :  :  :   PNew #`  *:  :  X    =K  #L  H:  :  X    =J  #.  f:  :  X    =X  #YJ  :  :  X    =A  #[  :  :  X    Q  #'  :  :    6  ":  !6  :  )   :  !)   "6  Or-  P#;  6  # Q  #;    :  Ox-  P#0;  :  #  ~-  P$;  k  $n  >  t  $e  >  R'  $;  # X  $&  X   ;  ;   S:  $;  ;   T?  $5  ;  ;  3   T^  $  ;  ;   UU  $.  3  ;    ;  !0;  0;  -  P%
-e<  0;  # F  %_]  ,<  3   ^  %l  S<  e<  f  pX   k<   @{R  %H5     B<  q<  !B<  -  H#=  3  # 7q
-  #6  # 7  #4  #@7T  #H  #AIS  #<  =     #$!  3  <  =  X      #<  3  =  =  X   E   4	  #h)  8=  =  C  X      #$  3  h=  =  3  X   X   H   ;9  #   M   =  =   Nd  #
-&  3  =    v<  =  !v<  O-  P#A  0  #v<  # c  #M   #HB  #3  #L3x7  #>  A  X    3x7  #>  A  A   3x7  #>>  A  3  X    3,;  #)Y>  A  F    ;O  #0YI  E  v>  A   ;L  #27  C  >  A   ;*  #58  3  >  A   ;g  #7"  3  >  A   ;k  #G	  3  >  A   ;k  #I  3  ?  A   <end #Ki  3  $?  A   <end #M#  3  A?  A   ;Y  #P>#  3  ^?  A   ;Y  #Q  3  {?  A   ;Q%  #S-Y  M   ?  A   ;t\  #TG  H  ?  A   ;3  #V?	  :  ?  A   ;3  #WW$  :  ?  A   ;O  #XT  M   @  A   =  #[54  /@  A  3  X    =  #b=  M@  A  A   ;  #hY  A  o@  A  A   ;pL  #o  A  @  A  A   ;\  #xW  =  @  A  A   ;j  #\Z  H  @  A  A   ;'  #3  H  @  A  A   PNew #}!  A  A  X    =K  #A.  3A  A  X    =J  #L^  QA  A  X    =X  #r  oA  A  X    =A  #  A  A  X    Q  #  A  A    =  "A  !=  A  "=  O-  P#A  =  # Q  #A    A  O-  P#
-B  A  #  -  P$B  k  $P  >  t  $>1  >  R'  $A  # X  $B  X   cB  B   S:  $xB  B   T?  $c2  B  B  3   T^  $68  B  B   UU  $   3  B    B  !
-B  
-B  -  P%ZC  
-B  # &  %w  M   C  ZC  k<  M    F  %  ,C  3   ^  %S  HC  e<  k<   @{R  %     B  -  P$D  k  $  >  t  $6=  >  R'  $A  # X  $F  X   C  D   S:  $C  *D   T?  $,  C  *D  3   T^  $  D  *D   UU  $  3  *D    %D  !`C  `C  -  P%!D  `C  # &  %$mS  M   kD  D  k<  M    F  %&S  D  3   ^  %'5  D  e<  k<   @{R  %(     0D  -  #,E  4  #   #  4  D  ,E  X   E   4	  #  E  ,E  C  X    M9  #  M   2E    D  8E  !D  -  #iF  4  # 7q
-  #iF  # 7  #D  #7T  #H  #IS  #E  yF     #Q  4  E  yF  X      #~D  4  E  yF  X   E   4	  #l  F  yF  C  X      #AH  4  1F  yF  4  X   X   H   ;9  #
-P  M   NF  F   Nd  #
-)  4  yF    +  yF  ,	   =E  F  !=E  O-  #J  0  #=E  # c  #M   #B  #4  #3x7  #F  J  X    3x7  #F  J  J   3x7  #G  J  4  X    3,;  #)4G  J  F    ;O  #0vO  E  QG  J   ;L  #2j  C  nG  J   ;f  #5  4  G  J   ;b  #7m?  4  G  J   ;k  #GDo  4  G  J   ;k  #I{  4  G  J   <end #K)  4  G  J   <end #M  4  H  J   ;Y  #P@  4  9H  J   ;Y  #Q  4  VH  J   ;Q%  #SHC  M   sH  J   ;t\  #T  H  H  J   ;3  #Vj  :  H  J   ;3  #WuQ  :  H  J   ;O  #X,K  M   H  J   =  #[6  
-I  J  4  X    =  #bn  (I  J  J   ;  #hg  J  JI  J  J   ;pL  #o"m  J  lI  J  J   ;\  #xjN  F  I  J  J   ;j  #Q  H  I  J  J   ;'  #i'  H  I  J  J   PNew #K  I  J  X    =K  #  J  J  X    =J  #H  ,J  J  X    =X  #E  JJ  J  X    =A  #.`  hJ  J  X    Q  #@  J  J    F  "J  !F  J  "F  O-  #J  F  # Q  #J    J  O-  #J  J  #  -  $K  k  $l  >  t  $	_  >  R'  $J  # X  $4  X   >K  K   S:  $SK  K   T?  $  qK  K  4   T^  $  K  K   UU  ${V  4  K    K  !J  J  -  %-L  J  # F  %/o  K  4   ^  %0j  L  L  (k  v   L   @{R  %1,$     K  &L  !K  -  $L  k  $=M  >  t  $  >  R'  $J  # X  $3  X   L  L   S:  $L  L   T?  $%  L  L  4   T^  $u  L  L   UU  $   4  L    L  !+L  +L  -  %6UM  +L  # F  %8Z  'M  4   ^  %9.\  CM  L   L   @{R  %:B     "[M  !  O  &(O  7(  &  # 3;d  &M  (O   3;d  &M  (O  UM   ;B  &zj    M  .O   ;P  &+[    M  .O   ;_O  &Y  9O  N  (O   ;_O  &X  `M  %N  (O  F    ;O  &G  9O  BN  (O   ;O  &?  `M  dN  (O  F    ;q5  &6:    N  .O  ?O   ;pL  &  9O  N  (O  ?O   ;\  &?j  `M  N  .O  ?O   ;yP  & \  9O  N  (O  ?O   ;[  &.G  `M  O  .O  ?O   ?~[  &o9  UM  .O    `M  4O  !`M  "`M  "EO  !;   O  &Q  7(  &  # 3;d  &|O  Q   3;d  &O  Q  Q   ;B  &    O  #Q   ;P  &C@    O  #Q   ;_O  &0N  .Q  O  Q   ;_O  &M  JO  P  Q  F    ;O  & h  .Q  ,P  Q   ;O  &g  JO  NP  Q  F    ;q5  &h    pP  #Q  ?O   ;pL  &\  .Q  P  Q  ?O   ;\  & G  JO  P  #Q  ?O   ;yP  &:  .Q  P  Q  ?O   ;[  &  JO  P  #Q  ?O   ?~[  &8  Q  #Q    JO  "Q  !  )Q  !JO  "JO  V-   h~  Q  -  # 3h   jcQ  Q   3h   k}Q  YA  <   W)  4Q  Q  F     4Q  "Q  !qQ  X-   ~  R  -  # YX  Q  R  R   X   Q  R  Q   W7  Q  R  F     Q  "R  !Q  X-   o~  >S  ~  # Ra    -  #RA5   qQ  #YX[  nR  >S  DS   X[   R  >S   -  Q   ZR   R  R  >S  F    [W   1    R  R  OS   Z   i  Q  R  OS   0      S  >S  Q   N   F   -  $S  OS    K     >S   -    R  "JS  !R  JS  \"  1C  S  ]>E  1C  ]4  1E  ]]U  1M    ^-  S  _  B<   `.  ^!.  S  ]A  e<  ]Y  k<  alen M    ^>  S  bo<  S   !A  c<      *       T  dA  3    eK  c0      ,   JT  fA  c4   gs eh     eM  Y   g  X   T  fA  Y4   gs [h      cC  ]p       T  dA  ]3   hs _h     ckD  W       T  dA  W3   hs Yh     ^=.  U  ix   iy X   j   kT            :U  lT    l U  v   ^Z.  U  iout e<  iin k<  _QE  M   m ?  M   nU  oi M   pqS    j`   k:U      Z     U  lDU    lPU  %  l[U  [  rgU    s   /   rxU    tS      %   qS     ^x.  V  ix X   iy X   j    kU      9     CV  lU    l	V  %   eED    R  P  V  uo<  V   fB  k<  v  M   |  wS      tS  0  C  qS  qS  qS    !D  eB  `       *W  uo<  *W   fB  k<  v  M     wS     tS       qS  qS  qS    !ZC  e,C     \0    W  fA  e<   vY  k<    gW W  x:U  0   W  qU  qU  qU  ygU  zH   yxU  {S  `   qS     wS     tS  H!  U0  qS  qS  qS    +B<  W  ,	   eK  W`0  `  =  lX  vA  WL  i  vY  W L    oW ilX  gT j|X  |US  l0  (1  ls(1  x`  gj nX   u}  +K  |X  ,	   +K  X  ,	   c,<  - a  Qw    h  dA  -e<   dY  -k<  }W /W  ~a 1B<    ~b 2B<    ~c 3B<    ~d 4B<    ~e 5B<  E	  U  Sa  Va  7'Y  q9V  q0V   U  xa  a  7EY  q9V  q0V   U  a  a  7cY  q9V  q0V   U  a  a  7Y  q9V  q0V   U     8Y  q9V  q0V   U  (b  +b  8Y  q9V  q0V   U  ib  rb  8Y  q9V  q0V   U  b  b  8Y  q9V  q0V   U  b  b  9Z  q9V  q0V   U  
-c  c  92Z  q9V  q0V   U    9MZ  q9V  q0V   U  Wc  `c  9kZ  q9V  q0V   U  c  c  :Z  q9V  q0V   U  c  c  :Z  q9V  q0V   U  0  :Z  q9V  q0V   U  c  c  :Z  q9V  q0V   U  H  ;Z  q9V  q0V   U  p  ;[  q9V  q0V   U    ;1[  q9V  q0V   U    ;L[  q9V  q0V   U  d  d  ;j[  q9V  q0V   U    ;[  q9V  q0V   U  e  e  ;[  q9V  q0V   U    <[  q9V  q0V   U  se  ve  ;[  q9V  q0V   U  e  e  <[  q9V  q0V   U  e  e  <\  q9V  q0V   U  e  e  <6\  q9V  q0V   U  e  f  <T\  q9V  q0V   U    <o\  q9V  q0V   U  Gf  Jf  <\  q9V  q0V   U     =\  q9V  q0V   U  f  f  <\  q9V  q0V   U  (  =\  q9V  q0V   U  f  f  =\  q9V  q0V   U  X  =]  q9V  q0V   U  p  =5]  q9V  q0V   U  g  g  =S]  q9V  q0V   U  g  g  =q]  q9V  q0V   U    >]  q9V  q0V   U  g  g  =]  q9V  q0V   U    >]  q9V  q0V   U  .h  1h  >]  q9V  q0V   U    >]  q9V  q0V   U  xh  {h  >^  q9V  q0V   U    >7^  q9V  q0V   U    >R^  q9V  q0V   U  i  'i  >p^  q9V  q0V   U  'i  Xi  ?^  q9V  q0V   U     ?^  q9V  q0V   U  i  i  ?^  q9V  q0V   U  8  ?^  q9V  q0V   U  i  i  ? _  q9V  q0V   U  `  ?_  q9V  q0V   U  .j  1j  ?9_  q9V  q0V   U    @T_  q9V  q0V   U    ?o_  q9V  q0V   U    @_  q9V  q0V   U     @_  q9V  q0V   U    @_  q9V  q0V   U   k  k  @_  q9V  q0V   U  0  @_  q9V  q0V   U  Vk  Yk  @`  q9V  q0V   U  H  A2`  q9V  q0V   U  k  k  @P`  q9V  q0V   U  x  Ak`  q9V  q0V   U  k  k  A`  q9V  q0V   U    A`  q9V  q0V   U    A`  q9V  q0V   U    A`  q9V  q0V   U  l  l  A`  q9V  q0V   U     Ba  q9V  q0V   U  l  l  A1a  q9V  q0V   U  m  m  BOa  q9V  q0V   U  (  Bja  q9V  q0V   U  P  Ba  q9V  q0V   U  Wm  Zm  Ba  q9V  q0V   U  m  m  Ba  q9V  q0V   U  p  Ba  q9V  q0V   U    Ca  q9V  q0V   U  m  m  Bb  q9V  q0V   U    C0b  q9V  q0V   U  ?n  Bn  CNb  q9V  q0V   U  wn  zn  Clb  q9V  q0V   U    Cb  q9V  q0V   U    Cb  q9V  q0V   U  n  n  Cb  q9V  q0V   U  0  Cb  q9V  q0V   U  H  Db  q9V  q0V   U  `  Dc  q9V  q0V   U  mo  po  D/c  q9V  q0V   U  o  o  DMc  q9V  q0V   U    Dhc  q9V  q0V   U  o  o  Dc  q9V  q0V   U    Dc  q9V  q0V   U    Ec  q9V  q0V   U  =p  @p  Dc  q9V  q0V   U  p  p  Ec  q9V  q0V   U    Ed  q9V  q0V   U    E.d  q9V  q0V   U  p  p  ELd  q9V  q0V   U  @  Egd  q9V  q0V   U  %q  (q  Ed  q9V  q0V   U  ]q  `q  Ed  q9V  q0V   U  iq  q  Fd  q9V  q0V   U  h  Fd  q9V  q0V   U  q  q  Fd  q9V  q0V   U    Fe  q9V  q0V   U  r  r  F3e  q9V  q0V   U    FNe  q9V  q0V   U  br  er  Fle  q9V  q0V   U    Ge  q9V  q0V   U  r  r  Fe  q9V  q0V   U    Ge  q9V  q0V   U  s  s  Ge  q9V  q0V   U    Ge  q9V  q0V   U  Rs  Us  Gf  q9V  q0V   U    G2f  q9V  q0V   U  s  s  GPf  q9V  q0V   U    Hkf  q9V  q0V   U  s  s  Gf  q9V  q0V   U  (  Hf  q9V  q0V   U  Bt  Et  Hf  q9V  q0V   U  @  Hf  q9V  q0V   U  t  t  Hf  q9V  q0V   U  X  Hg  q9V  q0V   U  t  t  H4g  q9V  q0V   U  p  HOg  q9V  q0V   U    Ijg  q9V  q0V   U    Ig  q9V  q0V   U  Lu  Ou  Ig  q9V  q0V   U    Ig  q9V  q0V   U  u  u  Ig  q9V  q0V   U    Ig  q9V  q0V   U  u  u  Ih  q9V  q0V   U   	  J0h  q9V  q0V   U  H	  IKh  q9V  q0V   U  Nv  Wv  Jih  q9V  q0V   U  v  v  Jh  q9V  q0V   U  v  v  Jq9V  q0V    +B<  h  ,	   !h  !h  !|X  !|X  YO  3  :  3  uR  {K  !h  .  .  .   !  .  !.  6V   Hw-  i  64     Q  H  R\  H  e  -  H  W"  J  H  5#    H  tA  )  H  J<  [E  H  0   {c  B<  +B<  i  ,	  ? !i  j/      +K  i  ,	  O !i  {/     !5  iF  Ia"  i  S  '>\  >  xE  '?1  >  j  'C!  C  +  'DZ  >  zn    *  q+  8_  *  ?MO  =U     +  I7  ,  6zn  k  *  q+  8t%  *  MO  =|5  9  k  $n  >  t  $e  >  k  $P  >  t  $>1  >  @k  $  >  t  $6=  >  @k  $l  >  t  $	_  >  k  $=M  >  t  $  >              cryptopp /usr/include/bits /usr/lib/gcc/i486-linux-gnu/4.3.3/include /usr/include/c++/4.3 /usr/include/c++/4.3/bits /usr/include/c++/4.3/debug /usr/include/c++/4.3/ext /usr/include /usr/include/c++/4.3/i486-linux-gnu/bits  sha.cpp   string3.h   misc.h   cpu.h   config.h   stddef.h   cstddef   cwchar   cstdio   clocale   cstdlib   cpp_type_traits.h   debug.h   new_allocator.h   allocator.h   basic_string.h   stdio.h   libio.h   stdarg.h   wchar.h   wchar2.h   time.h   types.h   _G_config.h   stdio2.h   stdio.h   locale.h   atomic_word.h 	  new   basic_string.tcc   stringfwd.h   cryptlib.h   stdlib.h   stdlib.h   secblock.h   iterhash.h   sha.h   stl_iterator.h   numeric_traits.h   <built-in>          <>guuuu{ f.{<n{ f.{<{W )X.W<-:v] #X.]<':|ft|/Xv|ft|/X!< J< X< X< X< X< X< X< X< X< X< X< X< X< X< X<zXtz</X y;=;=7h=eZege=e=e=e=y8@==:A-}<"}%}<f}<;g4}fJ}f;}"<}<f}<V}<}f}<'}%}<f}<&}f<}<.}<f}"}.}<.}ft}<}4}4}4}=.}<}<X}1}:}.}ff}<}t}f }t}}<}X}4}:}*$}<}t}f }t}}<}X}4}:}4}ff}J<}%}f}<}X}<}X}.t}<}=}4}4}f<}.}<.}f}fX}X}<} }<}"<} }f}.}<.}f}f}<}}<}f<}X.}<.}f}fX}<X}X<}}%<} }f}.}<X}f}f}<}}<}f<}X.}<.}f}fX}X}<} }<}"<} }f}.}<.}f}<.}f}X<}}<}f<}X.}<.}f}fX}<X}X<}}%<} }f}.}<X}f}f}<}}<}1}4}4}4}4}4}4}4}4}4}(}(f}<.}<} J}<}%}ff}X<}ft}f }t}.}..}ff}<t}<.}f<} Yt}<}T}<B}<&,h,>0:===83      J>>:0:0r$      KYf X;vp$      fhv,$ cryptopp/misc.h y < sizeof(T)*8 byteCount % sizeof(T) == 0          U(}}]EuU?wJ t1@   )]u t1EU}	]	u]D$  D$  D$    $        UVSEu]u!t19w[^]D$`  D$  D$    $          UMEwD$   D$  D$    $                          /BD7q[V9Y?^[1$}Ut]rtiG$o,-tJ\vRQ>m1'YGQcg))
-'8!.m,M8STs
-e
-jv.,rKfpKQl$5pjl7LwH'49JNO[o.htocxxlPxq"(/Be#D7q/;M8H[V9YO?m^BopE[N1$}Uo{t]r;5%&itJi%O8Gew$u+Yo,-ntJA\SvfRQ>2-m1?!'Y=%
-GoQcpn
-g))/F
-'&&\8!.*Zm,M8ScTs
-ew<
-jvG.;5,rdL0BKfpK0TQlReU$* qW52pjSAQl7LwH'H4cZ9AJNscwO[o.h]t`/Cocxrx9d(c#lPy+Srxqa&>'!}xnO}org}c
-?G5q}#w($@{2
-<LgCB>L*~e)Y:o_XGJDlT CryptoPP::rotrFixed(T, unsigned int) [with T = long long unsigned int]                        g	j;g+rn<6_:ORQl>+hkAy!~[]|6*)bp0ZY9Y/1g&3gXhJd.OHGvoid CryptoPP::ByteReverse(T*, const T*, size_t) [with T = CryptoPP::word32]                    g	jgrn<:ORQh[|6p09Y1XhdOT CryptoPP::rotlFixed(T, unsigned int) [with T = unsigned int]      |             *   AB       0      AH             AH       p  G   AG         G   AG              ABFL           Z   ABE              9   AB         B  ABMI       `  B  ABMI            ABE          `0  0  ABI         a  Q  ABI        zP |                 B   ABMI       D   `  B   ABMI      h         ABE          t       t   *    u        0   1    t1   9    t9       u               t       t   g   u        p  q   tq  x   tx     u             t     t     u                t       t       u                        Pu   S    PRS   V    uRV   g    ug       PR       u                       W   L    uL   Y    WY   g    ug       W                t       t   Z    u                    4    V4   6    u6   Z    V                   3    S3   6    u6   Z    S                   #    P#   6    u6   Z    PZ   Z    u           6    Q            6    R                t       t   9    u                        P   9    P9   9    u                   9    Q9   9    u             t     t  R   u          +   +  N   S        `  a   ta  c   tc      u        `  {   {      S               t       t   \0   u           C!   C!  H!   RH!  \0   u        `0  a0   ta0  c0   tc0  `   u        `0  !1    !1  `   u        `0  B1   B1   3   u 3  ;3   ;3  P   uP  R   R  _   u_  w`   w`  `   u         a  a   ta  a   ta  Qw   u        a  a   u|a  1b   uD1b  rb   urb  c   uHc  `c   u`c  d   uLd  sd   usd  Ie   Rye  e   ue  f   uPf  g   ug  h   uTh  'i   u'i  4j   uX4j  j   uj  k   Rk  2l   u2l  m   u\m  m   um  n   u`n  o   uo   p   ud p  p   up  iq   uhiq  r   Rr  wt   Rt  u   Ru  u   ulu  Wv   u@Wv  Qw   up        &a  a   Qa  .b   u|.b  b   Qb  0c   u|0c  c   Qc  c   u|c  d   Qd  e   u|e  vf   Qf  Ag   u|Ag  h   Q(h  h   u|h  i   Qi  }j   u|}j  ;k   QJk  l   Ql  n   Q3n  o   Qo  q   Qq  r   Qr  't   Q6t  ou   Qu  ,v   u|,v  v   Qv  Qw   Q         a  a   Sa  b   Sb  pc   Sc  d   Sd  +f   S;f  g   Sg  ei   Sui  j   Sj  al   S{l  m   Sm  Go   Sao  p   Sp  Gr   SVr  s   Ss  7u   S@u  v   Sv  Mw   S        #a  ca   Vxa  Wb   Vib  Ec   VWc  Sd   Vdd  e   Ve  sg   Vg  i   Vi  j   Vj  l   V,l  m   Vm  n   Vo  np   Vp  q   Vr  s   Vs  t   Vu  Ev   VNv  Nw   V        Pa  b   WGb  b   W5c  c   W/d  e   We  g   W2g  h   Wh  ^j   Wtj  k   Wk  Dm   W_m  n   Wn  *p   WEp  q   Wq  7s   WFs  t   Wt  v   W4v  Ow   W               k  S  CryptoPP::SHA1::InitState T  CryptoPP::SHA512::InitState JT  CryptoPP::SHA384::InitState T  CryptoPP::SHA256::InitState T  CryptoPP::SHA224::InitState U  rotrFixed<long long unsigned int> U  ByteReverse<CryptoPP::word32> V  rotlFixed<unsigned int> CV  CryptoPP::SHA224::HashMultipleBlocks V  CryptoPP::SHA256::HashMultipleBlocks /W  CryptoPP::SHA256::Transform W  CryptoPP::SHA512::Transform X  CryptoPP::SHA1::Transform i  SHA256_K     4                 Qw             Z       9               )  0          f  m  y               7!  >!  A!             7!  >!  A!                2!  7!  *!  /!  "!  '!  !  !  !  !  
-!  !  !  !                                                          7!  >!  A!  H!          b  b  +b  .b          c   c  -c  0c          c  c  c  c          d  d  Fd  Ld  Ad  Dd  /d  ?d          Sd  Vd  pd  sd          dd  pd  sd  d          d  d  d  d          e  e  e  <e          [e  se  {e  ~e          ;f  Gf  Jf  if          f  f  f  f  f  f  f  f          f  f  !g  'g  g  g  f  g  f  f          'g  -g  >g  Ag          2g  >g  Ag  fg          g  g  g  h          (h  .h  Jh  Sh  1h  Gh          Zh  `h  h  h  h  h  h  h  rh  xh          h  h  h  h          h  h  h  i          ui  i  i  i          i  i  i  i  i  i  i  i          j  j  cj  ij  Tj  Wj  @j  Jj  4j  :j  (j  .j          :j  @j  j  j  j  j  }j  j  tj  zj          ij  oj  zj  }j          j  j  j  j  j  j          j  j  j  j          j   k  k  .k          Jk  Vk  Yk  ~k          k  k  k  k  k  k  k  k  k  k          k  k  l  l  k  l  k  k           l  #l  ,l  2l          2l  Nl  Ql  Zl          ll  rl  l  l  l  l  l  l  {l  l          l  l  l  l  l  l  l  l          m  m  7m  =m  2m  5m  m  0m          Lm  Rm  xm  m  _m  um          m  m  m  m          m  m  n  n  	n  n  m  n  m  m          $n  *n  On  Xn  Bn  Ln  3n  ?n          n  n  n  n  n  n  n  n          n  n  n  n  n  n  n  n          o  	o  o  o          o  4o  7o  @o          Ro  Xo  o  o  |o  o  po  zo  ao  mo          o  o  o  o  o  o          o  o  p  #p  p  p   p  p          2p  8p  ^p  gp  Ep  [p          p  p  p  p          p  p  p  p  p  p  p  p  p  p          
-q  q  5q  >q  (q  2q  q  %q          q  q  q  q          r  r  r  :r          Vr  br  er  r          r  r  r  r          r  s  s  *s          Fs  Rs  Us  zs          s  s  s  s          s  s  s  t          6t  Bt  Et  jt          t  t  t  t          t  t  t  t          u  	u  u  u          u  u  -u  0u  u  )u          @u  Lu  Ou  eu          u  u  u  u  u  u  u  u          u  u  v  v  v  v  u  u  u  u  u  u          u  u  ;v  >v  ,v  /v  v  )v          v  v  )v  ,v              Qw      *   0         g  p                   Z       9     R  `        \0  `0  `   a  Qw          CANNOT_FLUSH _ZN8CryptoPP9Exception7SetWhatERKSs wcspbrk _ZNK8CryptoPP29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EE8max_sizeEv lconv _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj32ENS_6SHA256ELj32ELb1EE8StateBufEv _unused2 _ZN8CryptoPP13AllocatorBaseIjE7destroyEPj _ZNSs12_M_leak_hardEv _M_move _fileno _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EE8allocateEj _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE4sizeEv __normal_iterator<const char*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > tm_sec Assign allocate _ZN8CryptoPP31IteratedHashWithStaticTransformIyNS_10EnumToTypeINS_9ByteOrderELi1EEELj128ELj64ENS_6SHA512ELj64ELb1EE4InitEv _ZN8CryptoPP13AllocatorBaseIyE7destroyEPy fwide new_allocator int_p_sep_by_space getwc _ZNKSs8capacityEv _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE4dataEv fpos_t _ZN8CryptoPP9Exception12SetErrorTypeENS0_9ErrorTypeE _ZNK8CryptoPP31IteratedHashWithStaticTransformIyNS_10EnumToTypeINS_9ByteOrderELi1EEELj128ELj64ENS_6SHA512ELj64ELb1EE10DigestSizeEv _ZNSs5clearEv _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEEcvPvEv nothrow_t _shortbuf __gnu_cxx _ZN9__gnu_cxx17__normal_iteratorIPKcSsEmmEv _ZN9__gnu_cxx13new_allocatorIcE10deallocateEPcj _ZNK8CryptoPP13AllocatorBaseIjE7addressERj _ZNKSs4findEcj _ZNSs4nposE NullNameValuePairs _ZNSs4_Rep7_M_grabERKSaIcES2_ _M_refcopy _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE7BytePtrEv wcsncmp _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj32ENS_6SHA224ELj28ELb1EE8StateBufEv FixedSizeAlignedSecBlock<unsigned int, 16u, true> capacity operator const void* _ZNK8CryptoPP13AllocatorBaseIyE7addressERy feof _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj20ENS_4SHA1ELj0ELb0EE4InitEv _ZNSs13_S_copy_charsEPcS_S_ _flags _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE4GrowEj length _M_refcount _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEEpLERKS5_ __off_t substr _M_check_length SHA256_K deallocate _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE7BytePtrEv _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE5beginEv tm_isdst grouping _lock allocator ByteReverse _ZN9__gnu_cxx13new_allocatorIcE8allocateEjPKv wcstoll m_array _ZNSs4_Rep9_S_createEjjRKSaIcE IteratedHashWithStaticTransform<long long unsigned int, CryptoPP::EnumToType<CryptoPP::ByteOrder, 1>, 128u, 64u, CryptoPP::SHA384, 48u, true> HashMultipleBlocks max_size _ZNSs6rbeginEv FixedSizeSecBlock bool atoi atol _M_p _ZN8CryptoPP6SHA25618HashMultipleBlocksEPKjj wcsncpy wcsspn __builtin_va_list _ZNK8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE3endEv __pos m_alloc __debug _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE4dataEv SHA384 _ZN8CryptoPP15DEFAULT_CHANNELE setlocale _ZNSs6insertEjPKc _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_RKSs memcpy _ZNKSs7_M_dataEv vwscanf FixedSizeAlignedSecBlock<unsigned int, 16u, false> _ZN8CryptoPP31IteratedHashWithStaticTransformIyNS_10EnumToTypeINS_9ByteOrderELi1EEELj128ELj64ENS_6SHA384ELj48ELb1EE4InitEv replace _ZNKSs6_M_repEv _Rep_base _ZNKSs6substrEjj _ZNSsaSEc _ZNKSs4findERKSsj IO_ERROR _ZNSs6insertEjjc _IO_write_end operator unsigned int* _ZNSs5eraseEN9__gnu_cxx17__normal_iteratorIPcSsEES2_ CryptoPP _ZN8CryptoPP31IteratedHashWithStaticTransformIyNS_10EnumToTypeINS_9ByteOrderELi1EEELj128ELj64ENS_6SHA512ELj64ELb1EE24HashEndianCorrectedBlockEPKy byte _ZNSs5beginEv _ZNKSs4copyEPcjj _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE9CleanGrowEj _ZN9__gnu_cxx17__normal_iteratorIPKcSsEpLERKi _ZNK8CryptoPP13AllocatorBaseIjE8max_sizeEv _S_empty_rep _ZN8CryptoPP6SHA38419StaticAlgorithmNameEv DATA_INTEGRITY_CHECK_FAILED rename _ZNK8CryptoPP13AllocatorBaseIyE8max_sizeEv reallocate NullAllocator<long long unsigned int> _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj32ENS_6SHA224ELj28ELb1EE4InitEv operator const long long unsigned int* _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj32ENS_6SHA224ELj28ELb1EE10DIGESTSIZEE _Alloc_hider wcsstr fread int_frac_digits ~InvalidArgument g_x86DetectionDone _M_destroy _ZN9__gnu_cxx13new_allocatorIcE7destroyEPc _ZNKSs8_M_limitEjj fgetc LWORD_MAX rfind fgets wcstod wcstof wcstok wcstol _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE4swapERS5_ freopen _ZNK8CryptoPP13NullAllocatorIjE8max_sizeEv snprintf lldiv ferror value _ZNK8CryptoPP13NullAllocatorIyE8max_sizeEv _ZNSs7replaceEjjPKc SHA512 _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE8CleanNewEj operator* operator void* operator- __gnu_debug vsnprintf _ZNK8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE5beginEv _ZNSs4swapERSs wmemset operator= _ZN8CryptoPP6SHA22419StaticAlgorithmNameEv btowc DEFAULT_CHANNEL sprintf _ZNSs12_S_empty_repEv _ZNSs6assignERKSs BLOCKSIZE putwchar _ZNSs4_Rep8_M_cloneERKSaIcEj _ZNK9__gnu_cxx17__normal_iteratorIPcSsEdeEv AllocatorBase<unsigned int> atexit currency_symbol putchar _ZNKSs7compareEjjPKc _ZNSs6appendEPKc _ZN9__gnu_cxx24__numeric_traits_integerIiE5__maxE _ZNSs7replaceEjjPKcj FixedSizeAlignedSecBlock<long long unsigned int, 16u, true> __gnuc_va_list m_fallbackAllocator _ZN8CryptoPP6SHA25619StaticAlgorithmNameEv _ZNK8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE5emptyEv _chain int_n_cs_precedes _ZN8CryptoPP31IteratedHashWithStaticTransformIyNS_10EnumToTypeINS_9ByteOrderELi1EEELj128ELj64ENS_6SHA384ELj48ELb1EE9BLOCKSIZEE _ZN8CryptoPP13NullAllocatorIyE8allocateEjPKv _ZNKSs4_Rep12_M_is_sharedEv Grow wcstoul _M_refdata operator long long unsigned int* unsigned char _ZN8CryptoPP13NullAllocatorIyE10deallocateEPvj _M_set_sharable _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE7BytePtrEv wcsxfrm _IO_lock_t wcslen _ZNKSs13find_first_ofEPKcj float _M_set_length_and_sharable _ZNSs4_Rep26_M_set_length_and_sharableEj _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE4dataEv _M_check _ZNK8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj20ENS_4SHA1ELj0ELb0EE10DigestSizeEv assign _ZN8CryptoPP6SHA2569InitStateEPj _ZNSs6insertEjRKSs _ZNK8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE4dataEv _ZNK8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj32ENS_6SHA224ELj28ELb1EE10DigestSizeEv _ZN8CryptoPP8g_hasMMXE rend _ZNK8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEEcvPKyEv _ZNSs4_Rep10_M_refcopyEv setbuf _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEEcvPvEv _ZNSs7_M_copyEPcPKcj _ZNSs13_S_copy_charsEPcN9__gnu_cxx17__normal_iteratorIS_SsEES2_ _ZNKSs7compareEPKc _ZNKSs16find_last_not_ofEcj tm_zone _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_S1_S1_ fwscanf wctomb CheckSize wcsftime swap _ZNKSs5emptyEv _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEEpLERKS5_ mbrlen _ZNKSs2atEj _ZNSs6appendERKSsjj GetWhat _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_NS0_IPKcSsEES5_ _M_iend _ZNK9__gnu_cxx17__normal_iteratorIPcSsEmiERKi rewind _ZNSspLERKSs ByteReverse<CryptoPP::word32> _S_create _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE6resizeEj _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE5beginEv _ZNSs9_M_assignEPcjc _ZNSs6assignERKSsjj _ZNK8CryptoPP29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EE8max_sizeEv strtold _ZNSs7reserveEj strtoll _ZN8CryptoPP31IteratedHashWithStaticTransformIyNS_10EnumToTypeINS_9ByteOrderELi1EEELj128ELj64ENS_6SHA384ELj48ELb1EE8StateBufEv _ZNSspLEPKc _IO_write_ptr _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EE8allocateEj _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE3NewEj negative_sign _ZN9__gnu_cxx24__numeric_traits_integerIiE11__is_signedE _ZNKSs12find_last_ofEPKcj ~basic_string wcscat g_hasISSE _ZSt7nothrow _ZNKSs9_M_ibeginEv _ZNSs6insertEN9__gnu_cxx17__normal_iteratorIPcSsEEjc _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEEcvPjEv ftell _ZNSs7replaceEjjRKSs g_hasMMX _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE4dataEv int_curr_symbol _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE3endEv _ZNKSs7compareERKSs _ZN8CryptoPP6SHA51219StaticAlgorithmNameEv _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE7BytePtrEv SHA1 _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EE10reallocateEPjjjb _ZNK9__gnu_cxx13new_allocatorIcE7addressERc size _M_clone _M_replace_safe FILE _ZNSbIwSt11char_traitsIwESaIwEE4_Rep11_S_max_sizeE _ZNKSs17find_first_not_ofEcj _ZNSs6appendERKSs _M_ibegin ldiv _ZN8CryptoPP31IteratedHashWithStaticTransformIyNS_10EnumToTypeINS_9ByteOrderELi1EEELj128ELj64ENS_6SHA384ELj48ELb1EE24HashEndianCorrectedBlockEPKy clear wcscspn _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EE15GetAlignedArrayEv _ZNSs9_M_mutateEjjj size_t _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE4swapERS5_ _ZNK8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEEneERKS5_ operator!= __count quot m_state destroy rotrFixed<long long unsigned int> _ZNKSs17find_first_not_ofEPKcj _ZNSs14_M_replace_auxEjjjc _ZNSs6appendEjc perror _ZNSs5eraseEN9__gnu_cxx17__normal_iteratorIPcSsEE _M_current FixedSizeAllocatorWithCleanup<unsigned int, 16u, CryptoPP::NullAllocator<unsigned int>, false> _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EE15GetAlignedArrayEv _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EE10deallocateEPvj _ZN8CryptoPP10g_hasSSSE3E ~BERDecodeErr _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE3endEv _M_grab _M_is_shared WORD_BITS _IO_save_base operator const unsigned int* _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE4dataEv _S_empty_rep_storage wctob mon_thousands_sep fwprintf _M_assign _ZN9__gnu_cxx13new_allocatorIcE9constructEPcRKc _S_max_size __wchb find_last_not_of vfwscanf wint_t _ZNKSs5rfindEcj mblen vfwprintf _ZNKSs13get_allocatorEv __digits _ZNKSs6lengthEv __pad2 rbegin wcstoull INVALID_DATA_FORMAT OTHER_ERROR _M_copy SecBlock<unsigned int, CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int, 16u, CryptoPP::NullAllocator<unsigned int>, false> > _ZNKSs4findEPKcj _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj32ENS_6SHA224ELj28ELb1EE24HashEndianCorrectedBlockEPKj _ZNKSs16find_last_not_ofEPKcj _ZN8CryptoPP20g_nullNameValuePairsE bsearch wmemmove _ZN8CryptoPP8SHA256_KE fputwc _ZNSs4_Rep10_M_disposeERKSaIcE _ZN8CryptoPP9g_hasSSE2E _ZNKSs5c_strEv _ZNKSsixEj fputws _ZNSs4_Rep10_M_destroyERKSaIcE _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE8CleanNewEj _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj20ENS_4SHA1ELj0ELb0EE8StateBufEv FixedSizeSecBlock<unsigned int, 16u, CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int, 16u, CryptoPP::NullAllocator<unsigned int>, true> > X86_SHA256_HashBlocks _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_PKcj __normal_iterator<char*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > _ZNSs2atEj _ZNKSs11_M_disjunctEPKc _ZNKSs6rbeginEv g_cacheLineSize SetWhat reverse_iterator<__gnu_cxx::__normal_iterator<char*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > wcschr find _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj32ENS_6SHA256ELj32ELb1EE9BLOCKSIZEE _next get_allocator _ZNSs4rendEv _ZNK8CryptoPP9Exception4whatEv FixedSizeAllocatorWithCleanup<unsigned int, 16u, CryptoPP::NullAllocator<unsigned int>, true> _M_limit _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj32ENS_6SHA256ELj32ELb1EE24HashEndianCorrectedBlockEPKj decimal_point address _Atomic_word _ZNK8CryptoPP31IteratedHashWithStaticTransformIyNS_10EnumToTypeINS_9ByteOrderELi1EEELj128ELj64ENS_6SHA384ELj48ELb1EE10DigestSizeEv _ZNK9__gnu_cxx13new_allocatorIcE8max_sizeEv BytePtr _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEEneERKS5_ _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE6AssignEPKjj fprintf _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_PKcS4_ fclose __src strtoul _ZNKSs12find_last_ofEcj _ZN8CryptoPP6SHA2249TransformEPjPKj frac_digits m_what _ZN8CryptoPP4SHA119StaticAlgorithmNameEv operator[] _ZNSbIwSt11char_traitsIwESaIwEE4_Rep11_S_terminalE _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj20ENS_4SHA1ELj0ELb0EE24HashEndianCorrectedBlockEPKj tmpfile allocator<char> _ZNKSs3endEv wcstombs <anonymous union> _ZNKSs13find_first_ofEcj thousands_sep _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE6AssignEPKyj _ZNSs3endEv _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EE10deallocateEPvj SecBlock _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEEcvPvEv _ZNSs4_Rep20_S_empty_rep_storageE _ZNK9__gnu_cxx17__normal_iteratorIPcSsE4baseEv _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj32ENS_6SHA256ELj32ELb1EE4InitEv _ZNKSs7_M_iendEv swscanf _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEEcvPKjEv _ZNKSs12find_last_ofEPKcjj NullAllocator<unsigned int> clearerr _ZNK9__gnu_cxx17__normal_iteratorIPKcSsE4baseEv _ZN8CryptoPP13AllocatorBaseIjE9CheckSizeEj n_sep_by_space _sbuf ungetc _IO_save_end wprintf tm_min IteratedHashWithStaticTransform srand p_cs_precedes _ZNK9__gnu_cxx17__normal_iteratorIPKcSsEixERKi wcscmp _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE5beginEv _ZNSs6assignEPKcj _ZNKSs5rfindEPKcjj stdout _ZN9__gnu_cxx17__normal_iteratorIPcSsEmIERKi ~SecBlock mbsrtowcs _ZNSs6assignEjc mon_grouping HasSSE2 _ZNKSs12find_last_ofERKSsj tm_yday mbsinit find_first_not_of _ZNSs7_M_leakEv _M_leak system _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE5emptyEv _ZNKSs5beginEv short unsigned int g_isP4 signed char _ZNKSs5rfindEPKcj this _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEEplERKS5_ _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EE8allocateEjPKv _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj32ENS_6SHA224ELj28ELb1EE9BLOCKSIZEE _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE6AssignERKS5_ _ZNKSs17find_first_not_ofEPKcjj ptrdiff_t swprintf SecBlock<long long unsigned int, CryptoPP::FixedSizeAllocatorWithCleanup<long long unsigned int, 16u, CryptoPP::NullAllocator<long long unsigned int>, true> > _M_replace_aux count HashEndianCorrectedBlock _ZN9__gnu_cxx17__normal_iteratorIPKcSsEmmEi vfprintf tm_wday __off64_t wcscpy _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEEcvPyEv wchar_t vswprintf _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EE10reallocateEPjjjb _ZNK9__gnu_cxx17__normal_iteratorIPcSsEptEv putwc _IO_read_base _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEEaSERKS5_ _offset _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE4swapERS5_ string _ZN9__gnu_cxx3absEx g_hasSSSE3 resize state _IO_buf_end _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEEeqERKS5_ mbstowcs _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE3endEv _ZNSsixEj mbstate_t n_sign_posn input _M_rep m_ptr wcsrtombs _ZNK8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj32ENS_6SHA256ELj32ELb1EE10DigestSizeEv ~new_allocator _ZNKSs4dataEv _ZNK8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE4sizeEv _mode _ZNK8CryptoPP13AllocatorBaseIjE7addressERKj _IO_write_base _M_data IteratedHashWithStaticTransform<unsigned int, CryptoPP::EnumToType<CryptoPP::ByteOrder, 1>, 64u, 20u, CryptoPP::SHA1, 0u, false> __wch _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EE8allocateEjPKv _ZNSs6insertEN9__gnu_cxx17__normal_iteratorIPcSsEEc __max <anonymous struct> append vswscanf remove __dest tm_mon copy byteCount _ZN8CryptoPP6g_isP4E SHA512_K _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_S2_S2_ long int fgetpos _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE9CleanGrowEj _ZN8CryptoPP13AllocatorBaseIjE9constructEPjRKj vwprintf nothrow _IO_marker int_p_sign_posn tm_year _ZNK8CryptoPP9Exception12GetErrorTypeEv _ZNKSs7compareEjjRKSs rotlFixed<unsigned int> getc wscanf InitState _ZNK9__gnu_cxx17__normal_iteratorIPcSsEplERKi _ZNK9__gnu_cxx17__normal_iteratorIPKcSsEmiERKi gets _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EE15GetAlignedArrayEv atof _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE5emptyEv _ZNSs6appendEPKcj _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EE10reallocateEPyjjb _ZNSs6insertEjPKcj mon_decimal_point _S_construct _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE4GrowEj strtod strtof strtol long double _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEEcvPKvEv reserve _ZN8CryptoPP13AllocatorBaseIyE9CheckSizeEj _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEEneERKS5_ _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE9CleanGrowEj p_sep_by_space long unsigned int _ZN8CryptoPP9g_hasISSEE SHA256 _ZNKSs13find_first_ofEPKcjj SetErrorType _ZNK8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE11SizeInBytesEv _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE3NewEj CleanNew _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE8CleanNewEj operator+= reverse_iterator<__gnu_cxx::__normal_iterator<const char*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > WORD_SIZE tmpnam _ZN9__gnu_cxx17__normal_iteratorIPcSsEppEi _ZN8CryptoPP31IteratedHashWithStaticTransformIyNS_10EnumToTypeINS_9ByteOrderELi1EEELj128ELj64ENS_6SHA384ELj48ELb1EE10DIGESTSIZEE FixedSizeAllocatorWithCleanup<long long unsigned int, 16u, CryptoPP::NullAllocator<long long unsigned int>, true> _ZN9__gnu_cxx17__normal_iteratorIPcSsEppEv _ZNSs6resizeEj _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEEplERKS5_ GetErrorType _ZNSs13_S_copy_charsEPcN9__gnu_cxx17__normal_iteratorIPKcSsEES4_ _M_dataplus _ZNSsaSEPKc char push_back wcstold _S_terminal stdin operator++ insert _Rep _ZNK8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEEcvPKvEv _IO_buf_base operator-- _ZNSspLEc SizeInBytes _ZNK8CryptoPP29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EE8max_sizeEv _ZNSs7_M_moveEPcPKcj operator-= operator-> _IO_read_end _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj32ENS_6SHA256ELj32ELb1EE10DIGESTSIZEE _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EE8allocateEj _ZNK8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE7BytePtrEv _ZNK8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEEeqERKS5_ _IO_FILE _ZNKSs16find_last_not_ofEPKcjj wmemchr lword StaticAlgorithmName ~Exception _ZNSs7_M_dataEPc _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEEcvPKjEv _ZNSs12_S_constructEjcRKSaIcE _ZNKSs8max_sizeEv tm_hour FixedSizeAllocatorWithCleanup atoll _ZN8CryptoPP6SHA22418HashMultipleBlocksEPKjj fseek __min _ZN8CryptoPP6SHA2249InitStateEPj _ZN8CryptoPP6SHA2569TransformEPjPKj _ZNSs7replaceEjjRKSsjj _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE11SizeInBytesEv _ZN8CryptoPP13AllocatorBaseIyE9constructEPyRKy basic_string<char, std::char_traits<char>, std::allocator<char> > getwchar int_n_sign_posn m_allocated _ZNSs4_Rep11_S_terminalE StateBuf tm_mday _S_compare c_str __pad1 __pad3 __pad4 __pad5 __len FixedSizeSecBlock<long long unsigned int, 16u, CryptoPP::FixedSizeAllocatorWithCleanup<long long unsigned int, 16u, CryptoPP::NullAllocator<long long unsigned int>, true> > g_nullNameValuePairs _ZNK8CryptoPP13AllocatorBaseIyE7addressERKy new_allocator<char> fsetpos _markers _pos _ZN8CryptoPP31IteratedHashWithStaticTransformIyNS_10EnumToTypeINS_9ByteOrderELi1EEELj128ELj64ENS_6SHA512ELj64ELb1EE8StateBufEv _M_length what vsprintf _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEEplERKS5_ erase double INVALID_ARGUMENT _ZN8CryptoPP13NullAllocatorIjE10deallocateEPvj FixedSizeSecBlock<unsigned int, 16u, CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int, 16u, CryptoPP::NullAllocator<unsigned int>, false> > _ZNKSs17find_first_not_ofERKSsj AllocatorBase<long long unsigned int> __FILE CleanGrow InvalidArgument _ZN9__gnu_cxx17__normal_iteratorIPKcSsEppEi _ZNKSs4rendEv DigestSize _ZN9__gnu_cxx17__normal_iteratorIPKcSsEppEv _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE4sizeEv qsort printf data ErrorType wmemcmp _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEEaSERKS5_ wcrtomb __value cryptopp/sha.cpp _ZNKSs15_M_check_lengthEjjPKc _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEEeqERKS5_ _ZN8CryptoPP6SHA3849InitStateEPy _ZNSs9push_backEc _ZN9__gnu_cxx24__numeric_traits_integerIiE8__digitsE _ZNK9__gnu_cxx17__normal_iteratorIPKcSsEptEv Exception _ZNKSs4_Rep12_M_is_leakedEv base positive_sign setvbuf _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE6resizeEj _ZN9__gnu_cxx17__normal_iteratorIPKcSsEmIERKi _ZN8CryptoPP6SHA3849TransformEPyPKy _ZN8CryptoPP18g_x86DetectionDoneE empty construct _ZNSs6insertEjRKSsjj mbtowc operator+ _ZN9__gnu_cxx17__normal_iteratorIPcSsEpLERKi _ZNKSs7compareEjjRKSsjj _M_dispose _ZN9__gnu_cxx24__numeric_traits_integerIiE5__minE _ZNSs4_Rep13_M_set_leakedEv long long unsigned int _ZN8CryptoPP4SHA19InitStateEPj mbrtowc _cur_column _ZNSs4_Rep12_S_empty_repEv wmemcpy __compar_fn_t _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE6AssignERKS5_ _ZNSs13_S_copy_charsEPcPKcS1_ _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE4GrowEj Transform _ZNSs10_S_compareEjj Init _M_set_leaked vprintf _ZNSs4_Rep15_M_set_sharableEv _ZN8CryptoPP31IteratedHashWithStaticTransformIyNS_10EnumToTypeINS_9ByteOrderELi1EEELj128ELj64ENS_6SHA512ELj64ELb1EE9BLOCKSIZEE _ZNSs4_Rep11_S_max_sizeE wcsncat fopen tm_gmtoff _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE5beginEv _ZNSs5eraseEjj _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE6resizeEj _IO_backup_base int_n_sep_by_space _IO_read_ptr _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE3NewEj IteratedHashWithStaticTransform<unsigned int, CryptoPP::EnumToType<CryptoPP::ByteOrder, 1>, 64u, 32u, CryptoPP::SHA224, 28u, true> _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_jc m_errorType _M_mutate SecBlock<unsigned int, CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int, 16u, CryptoPP::NullAllocator<unsigned int>, true> > _ZNSsaSERKSs GNU C++ 4.3.3 getenv fgetwc _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEEcvPKvEv _M_capacity _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEEcvPjEv _ZN8CryptoPP15g_cacheLineSizeE fgetws m_size _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE3endEv rand basic_string _ZNKSs13find_first_ofERKSsj __normal_iterator _old_offset IteratedHashWithStaticTransform<long long unsigned int, CryptoPP::EnumToType<CryptoPP::ByteOrder, 1>, 128u, 64u, CryptoPP::SHA512, 64u, true> wcscoll exception GetAlignedArray _ZN8CryptoPP13NullAllocatorIjE8allocateEjPKv p_sign_posn wcsrchr compare long long int _ZNSs7replaceEjjjc _ZNKSs4sizeEv g_hasSSE2 _flags2 _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj20ENS_4SHA1ELj0ELb0EE9BLOCKSIZEE _ZNK9__gnu_cxx13new_allocatorIcE7addressERKc _ZNKSs8_M_checkEjPKc getchar _ZNKSs4findEPKcjj _ZNSs4_Rep10_M_refdataEv _ZNKSs7compareEjjPKcj word32 INFINITE_TIME _ZNSs7replaceEN9__gnu_cxx17__normal_iteratorIPcSsEES2_PKc _ZNKSs5rfindERKSsj NOT_IMPLEMENTED ungetwc _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEEaSERKS5_ SHA224 find_last_of _ZN9__gnu_cxx3divExx n_cs_precedes _ZNSs15_M_replace_safeEjjPKcj _ZN9__gnu_cxx17__normal_iteratorIPcSsEmmEi _ZNKSs16find_last_not_ofERKSsj __state _ZN9__gnu_cxx17__normal_iteratorIPcSsEmmEv IteratedHashWithStaticTransform<unsigned int, CryptoPP::EnumToType<CryptoPP::ByteOrder, 1>, 64u, 32u, CryptoPP::SHA256, 32u, true> BERDecodeErr _ZNK9__gnu_cxx17__normal_iteratorIPcSsEixERKi localeconv _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EE8allocateEjPKv _ZNSs6assignEPKc strtoull _ZNK8CryptoPP9Exception7GetWhatEv _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb1EEEE3endEv operator== _ZN8CryptoPP6SHA5129TransformEPyPKy _ZNK9__gnu_cxx17__normal_iteratorIPKcSsEplERKi _M_disjunct _ZNK9__gnu_cxx17__normal_iteratorIPKcSsEdeEv __is_signed unsigned int _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE7BytePtrEv word64 _ZNK8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE11SizeInBytesEv _S_copy_chars fflush _ZNSbIwSt11char_traitsIwESaIwEE4nposE DIGESTSIZE short int begin int_p_cs_precedes _ZN8CryptoPP31IteratedHashWithStaticTransformIyNS_10EnumToTypeINS_9ByteOrderELi1EEELj128ELj64ENS_6SHA512ELj64ELb1EE10DIGESTSIZEE _ZN8CryptoPP29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EE10deallocateEPvj _vtable_offset _ZN8CryptoPP4SHA19TransformEPjPKj _M_is_leaked _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEEpLERKS5_ _ZN8CryptoPP8SecBlockIjNS_29FixedSizeAllocatorWithCleanupIjLj16ENS_13NullAllocatorIjEELb0EEEE6AssignEPKjj _ZNSs6resizeEjc _M_leak_hard _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE6AssignERKS5_ npos /home/bitcoin/bitcoin/trunk _ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi1EEELj64ELj20ENS_4SHA1ELj0ELb0EE10DIGESTSIZEE _ZN8CryptoPP6SHA5129InitStateEPy ~allocator _ZN8CryptoPP8SecBlockIyNS_29FixedSizeAllocatorWithCleanupIyLj16ENS_13NullAllocatorIyEELb1EEEE5beginEv __quad_t find_first_of  GCC: (Ubuntu 4.3.3-5ubuntu4) 4.3.3  .symtab .strtab .shstrtab .rel.text .data .bss .debug_abbrev .rel.debug_info .rel.debug_line .rodata.str1.1 .rel.text._ZN8CryptoPP9rotrFixedIyEET_S1_j .rel.text._ZN8CryptoPP11ByteReverseIjEEvPT_PKS1_j .rel.text._ZN8CryptoPP9rotlFixedIjEET_S1_j .rodata .rel.debug_frame .rel.eh_frame .rel.debug_loc .rel.debug_pubnames .rel.debug_aranges .rel.debug_ranges .debug_str .comment .note.GNU-stack .group                                                        4      %   &                      <      %   (                      D      %   )                      P   Qw                    	           `   %            %             w                     +             w                     0              w                   B                k                 >   	           @ 8.  %   	         R                
-                 N   	           x     %            ^      2         ;                 q            `                    m   	                %                          Z                     	                %                        P  9                     	                %                           ?                                                     	               %                        d                     	                %                           	                   	            @  %            /                               +  	           (    %            C              8                  ?  	           0 (   %            V              	                 R  	           X    %            d     0        o                o              $                  x                                                                               T @  &   !         	                                                                                                                                 	               	     @     .      @     S           x                                            I                      `  M                        ?     L                                                                                                                        !              #              "                                           d      *       0                    p  G         G              "  (             6      Z   "  ^      9   "      B                                                        `  B    L         p  `0  0       a  Q                  sha.cpp _ZZN8CryptoPP6SHA5129InitStateEPyE1s _ZZN8CryptoPP6SHA3849InitStateEPyE1s _ZZN8CryptoPP6SHA2569InitStateEPjE1s _ZZN8CryptoPP6SHA2249InitStateEPjE1s _ZZN8CryptoPP9rotrFixedIyEET_S1_jE19__PRETTY_FUNCTION__ _ZZN8CryptoPP11ByteReverseIjEEvPT_PKS1_jE19__PRETTY_FUNCTION__ _ZZN8CryptoPP9rotlFixedIjEET_S1_jE19__PRETTY_FUNCTION__ _ZN8CryptoPPL8SHA512_KE _ZN8CryptoPP4SHA19InitStateEPj _ZN8CryptoPP6SHA5129InitStateEPy _ZN8CryptoPP6SHA3849InitStateEPy _ZN8CryptoPP6SHA2569InitStateEPj _ZN8CryptoPP6SHA2249InitStateEPj _ZN8CryptoPP9rotrFixedIyEET_S1_j __assert_fail _ZN8CryptoPP11ByteReverseIjEEvPT_PKS1_j _ZN8CryptoPP9rotlFixedIjEET_S1_j _ZN8CryptoPP6SHA22418HashMultipleBlocksEPKjj _ZN8CryptoPP18g_x86DetectionDoneE _ZN8CryptoPP17DetectX86FeaturesEv _ZN8CryptoPP8SHA256_KE _ZN8CryptoPP9g_hasSSE2E _ZN8CryptoPP6SHA25618HashMultipleBlocksEPKjj _ZN8CryptoPP6SHA2569TransformEPjPKj _ZN8CryptoPP6SHA5129TransformEPyPKy _ZN8CryptoPP4SHA19TransformEPjPKj __gxx_personality_v0  3     @     I     R     [     d     m     v                                                                                      (    1    :    C    L    U    ^    r    ~                                                              +  ,  ,  6  -  F  .  h  +  |  ,    -    .  9!  +  D!  ,  K!  .  U!  -  2    3    4    4    6    6    8    8    :    :    <    =    ?    ?    A    A    C    C    E    E    !G    (G    I    -I    %K    ,K    L    L    N    N    P    P                        !     %     *     7     <     N     [     y               R    \    n    ~                                                            	                #    Z    n                                	        +    1    G    M    i    o                     /    K    P    [    h    w                                                +    :    I    X    g    v                                        	    	    '	    3	    <	    H	    T	    `	    k	    w	    	    	    	    	    	    
-    +
-    H
-    e
-    
-    
-    
-    
-    
-        9    f                            =    d                            6    R    n                                        (    6    F    ]                    
-    (    4    R    X    y                        9    Z    {                            ?    ]    c                                                    `    l                                @    \    y                    $    <    I    `    t                            *    G    T    k                        -    9    G    U    c    q                                                    '    5    C    Q    _    m    {                                            #    *    F    M    d    k                                            3    :    V    ]    y                                        (    /    K    R    m    t                                
-    -    U    x                                    :    A    W    ^    {                                        "    )    ?    F    \    c    y                                                +    2    M    T    u                                        9    @    e    l                                              @     G     g     n                                        !    0!    7!    \!    c!    !    !    !    !    !    !    !    "    "    &"    F"    M"    r"    y"    "    "    "    "    #    #    6#    =#    b#    i#    #    #    #    #    #    #    !$    ($    R$    Y$    $    $    $    $    $    $    %    %    >%    E%    j%    q%    %    %    %    %    %    %    %    %    &    &    2&    9&    Y&    `&    &    &    &    &    &    &    &    '    !'    ('    H'    O'    t'    {'    '    '    '    '    '    '    (    (    <(    C(    c(    j(    (    (    (    (    (    (    )    )    +)    2)    W)    ^)    ~)    )    )    )    )    )    )    )    *    !*    P*    W*    r*    y*    *    *    +    +    !+    E+    K+    V+    \+    g+    m+    y+    +    +    +    +    +    +    +    +    +    +    +    ,    ,    +,    1,    Q,    X,    w,    },    ,    ,    ,    ,    ,    ,    -    -    !-    )-    /-    5-    ;-    A-    G-    M-    U-    [-    a-    g-    m-    s-    y-    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    .    ".    ?.    \.    z.    .    .    .    .    .    .    .    .    .    .    .    /    /    /    /    '/    -/    8/    >/    I/    O/    Z/    `/    k/    q/    |/    /    /    /    /    /    /    0    ,0    K0    c0    {0    0    0    0    1    .1    O1    q1    1    1    1    1    1    2    22    S2    o2    2    2    2    2    3    *3    03    K3    Q3    l3    r3    3    3    3    3    3    3    4    4    74    =4    X4    ^4    z4    4    4    4    4    4    5    5    15    75    S5    Y5    5    5    5    5    5    5    5    5    6    #6    ?6    E6    o6    v6    6    6    6    6    6    7    7    67    U7    p7    w7    7    7    7    7    7    7    7    7    8    8    %8    B8    X8    _8    u8    |8    8    8    8    8    8    8    8    8    9    9    #9    *9    F9    M9    d9    k9    9    9    9    9    9    9    9    9    :    ,:    3:    J:    Q:    h:    o:    :    :    :    :    ;    =;    C;    N;    T;    _;    o;    u;    ;    ;    ;    ;    ;    ;    ;    <    <    .<    4<    C<    U<    [<    <    <    <    <    <    <    <    <    =    =    :=    @=    j=    q=    =    =    =    =    =    =    >    !>    @>    [>    b>    x>    >    >    >    >    >    >    >    >    >    ?    -?    C?    J?    `?    g?    }?    ?    ?    ?    ?    ?    ?    ?    ?    ?    @    @    1@    8@    O@    V@    q@    x@    @    @    @    @    @    @     A    A    A    5A    <A    SA    ZA    qA    xA    A    A    A    B    B    (B    .B    9B    IB    OB    eB    zB    B    B    B    B    B    B    B    C    C    .C    4C    JC    PC    mC    sC    ~C    C    C    C    C    C    C    C    C    C    D    D    GD    MD    mD    sD    D    D    D    D    D    D    D    D    E    E    SE    cE    tE    E    E    E    E    E    E    E    F    	F    3F    :F    PF    WF    F    F    F    F    F    F    G    6G    =G    SG    ZG    pG    wG    G    G    G    G    G    G    G    H    H    %H    ;H    BH    XH    _H    uH    |H    H    H    H    H    H    H    H    H    I    I    *I    1I    LI    SI    nI    uI    I    I    I    I    I    I    I    J    J    .J    5J    LJ    SJ    jJ    qJ    J    J    J    K    	K    K    $K    *K    @K    UK    [K    sK    yK    K    K    K    K    K    K    K    
-L    L    8L    >L    IL    OL    ZL    jL    pL    L    L    L    L    L    L    L    M    M    )M    /M    EM    KM    nM    M    M    M    M    M    M    M    M    N    N    'N    .N    DN    KN    fN    mN    N    N    N    N    N    N    N    N    O    O    XO    iO    ~O    O    O    O    O    O    O    O    O    P    P    .P    5P    PP    WP    rP    yP    P    P    P    P    P    P    P    Q    PQ    eQ    rQ    Q    Q    Q    Q    9R    HR    XR    pR    R    R    R    R    R    R    R    
-S    S    &S    ,S    WS    hS    sS    ~S    S    S    S    S    S    S    S    T    T    T    "T    +T    ET    RT    VT    ZT    cT    }T    T    T    T    T    T    T    T    T    T    T    U    U    U    U    ,U    5U    \U    hU    U    U    U    U    U    U    U    U    U    U    U    U    U    V     V    $V    (V    5V    >V    KV    OV    SV    \V    iV    xV    V    V    V    V    V    V    V    V    V    V    V    W    W    W    7W    ;W    ?W    HW    WW    bW    yW    W    W    W    W    W    W    W    X    X    X    X    'X    HX    LX    TX    XX    X    X    X    X    X    X    X    X    X    Y    Y    Y    ,Y    0Y    JY    NY    hY    lY    Y    Y    Y    Y    Y    Y    Y    Y    Y    Z    Z    8Z    RZ    VZ    pZ    tZ    Z    Z    Z    Z    Z    Z    [    [    7[    Q[    U[    p[    [    [    [    [    [    [    [    [    \    \    !\    ;\    ?\    Z\    t\    x\    \    \    \    \    \    \    ]     ]    :]    >]    X]    \]    w]    ]    ]    ]    ]    ]    ]    ^    ^    "^    =^    W^    [^    u^    y^    ^    ^    ^    ^    ^    ^    _     _    $_    ?_    Z_    u_    _    _    _    _    _    _    `    `    7`    ;`    V`    p`    t`    `    `    `    `    `    `    a    a    6a    :a    Ua    pa    a    a    a    a    a    a    a     b    b    5b    9b    Sb    Wb    rb    b    b    b    b    b    b    c    c    4c    8c    Sc    mc    qc    c    c    c    c    c    c    c    d    3d    7d    Rd    ld    pd    d    d    d    d    d    d    d     e    e    e    9e    Se    We    re    e    e    e    e    e    e    e    f    f    7f    ;f    Vf    pf    tf    f    f    f    f    f    f    g    g    g    :g    Ug    pg    g    g    g    g    g    g    g     h    h    6h    Ph    Th    nh    rh    h    h    h    h    h    i    !i    ,i    3i    >i    Di    Oi    Ui    `i    fi    qi    wi    i    i    i    i    i    i    i  -  i    i    j    j    j    %j    +j    :j    @j    Kj    Qj    ]j    dj    qj    wj    j    j    j    j    j    j    j    j    j    j    j    j    j    j     k    k    k    k    $k    *k    6k    <k    Hk    Nk    Yk    _k    jk    pk    {k    k                    k     {             '  :     J     Q     V   '       )     0     5   '            0     4     H     L     `     d     x     |                                                     (    ,    H    L    h    l       3  $     H     l                                    ,     0     8     <     D     H     X     \     d     h     p     t                                                                                                               %    )    5    9    F    J    R    V    b    f    v    z                                                                                        
-            %    )    1    5    <    @    H    L    [    _    g    k    r    v    ~                                                                            
-            %    )    1    5    <    @    P    T    \    `    h    l    |                                                                                            "    )    -    =    A    I    M    U    Y    i    m    u    y                                                                                    	            !    *    .    6    :    C    G    O    S    \    `    h    l    u    y                                                                                             	                "    &    .    2    ;    ?    G    K    R    V    ]    a    h    l    t    x                                                                                                            $    (    /    3    <    @    G    K    R    V    ]    a    h    l    s    w    ~                                                                                                                "    &    -    1    8    <    C    G    N    R    Y    ]    d    h    o    s                                                                                                    	    
-	    	    	    	     	    '	    +	    2	    6	    E	    I	    P	    T	    [	    _	    f	    j	    q	    u	    |	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	                              (                                          $     0     4     8     <     H     L     P     T     `     d     h     l     p     t     x     |                                                                                                                                                                               $    0    4    8    <    H    L    P    T    X    \    `    d    p    t    x    |                                                                                                                     (    ,    0    4    8    <    @    D    H    L    X    \    `    d    p    t    x    |                                                                                                                         $    (    ,    8    <    @    D    H    L    P    T    `    d    h    l    p    t    x    |                                                                                                                                  $    0    4    8    <    H    L    P    T    X    \    `    d    h    l    x    |                                                                                                                                     (    ,    0    4    8    <    @    D    P    T    X    \    `    d    p    t    x    |                                                                                                                                         $    0    4    8    <    H    L    P    T    `    d    h    l    p    t    x    |                                                                                                                                  $    (    ,    0    4    @    D    H    L    P    T    X    \    h    l    p    t                                                                                                                     (    ,    0    4    @    D    H    L    X    \    `    d    p    t    x    |                                                                                                     	    	    	    	    	    	     	    $	    (	    ,	    0	    4	    8	    <	    H	    L	    P	    T	    `	    d	    h	    l	    p	    t	    x	    |	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    
\ No newline at end of file
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/pch.h bitcoin-0.3.20/src/cryptopp/pch.h
--- bitcoin-0.3.20.orig/src/cryptopp/pch.h	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/pch.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-#ifndef CRYPTOPP_PCH_H
-#define CRYPTOPP_PCH_H
-
-#ifdef CRYPTOPP_GENERATE_X64_MASM
-
-	#include "cpu.h"
-
-#else
-
-	#include "config.h"
-
-	#ifdef USE_PRECOMPILED_HEADERS
-		#include "simple.h"
-		#include "secblock.h"
-		#include "misc.h"
-		#include "smartptr.h"
-	#endif
-
-#endif
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/Readme.txt bitcoin-0.3.20/src/cryptopp/Readme.txt
--- bitcoin-0.3.20.orig/src/cryptopp/Readme.txt	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/Readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,429 +0,0 @@
-Crypto++: a C++ Class Library of Cryptographic Schemes
-Version 5.6.0 (3/15/2009)
-
-Crypto++ Library is a free C++ class library of cryptographic schemes.
-Currently the library contains the following algorithms:
-
-                   algorithm type  name
-
- authenticated encryption schemes  GCM, CCM, EAX
- 
-        high speed stream ciphers  Panama, Sosemanuk, Salsa20, XSalsa20
-
-           AES and AES candidates  AES (Rijndael), RC6, MARS, Twofish, Serpent,
-                                   CAST-256
-
-                                   IDEA, Triple-DES (DES-EDE2 and DES-EDE3),
-              other block ciphers  Camellia, SEED, RC5, Blowfish, TEA, XTEA,
-                                   Skipjack, SHACAL-2
-
-  block cipher modes of operation  ECB, CBC, CBC ciphertext stealing (CTS),
-                                   CFB, OFB, counter mode (CTR)
-
-     message authentication codes  VMAC, HMAC, CMAC, CBC-MAC, DMAC, 
-                                   Two-Track-MAC
-
-                                   SHA-1, SHA-2 (SHA-224, SHA-256, SHA-384, and
-                   hash functions  SHA-512), Tiger, WHIRLPOOL, RIPEMD-128,
-                                   RIPEMD-256, RIPEMD-160, RIPEMD-320
-
-                                   RSA, DSA, ElGamal, Nyberg-Rueppel (NR),
-          public-key cryptography  Rabin, Rabin-Williams (RW), LUC, LUCELG,
-                                   DLIES (variants of DHAES), ESIGN
-
-   padding schemes for public-key  PKCS#1 v2.0, OAEP, PSS, PSSR, IEEE P1363
-                          systems  EMSA2 and EMSA5
-
-                                   Diffie-Hellman (DH), Unified Diffie-Hellman
-            key agreement schemes  (DH2), Menezes-Qu-Vanstone (MQV), LUCDIF,
-                                   XTR-DH
-
-      elliptic curve cryptography  ECDSA, ECNR, ECIES, ECDH, ECMQV
-
-          insecure or obsolescent  MD2, MD4, MD5, Panama Hash, DES, ARC4, SEAL
-algorithms retained for backwards  3.0, WAKE, WAKE-OFB, DESX (DES-XEX3), RC2,
-     compatibility and historical  SAFER, 3-WAY, GOST, SHARK, CAST-128, Square
-                            value
-
-Other features include:
-
-  * pseudo random number generators (PRNG): ANSI X9.17 appendix C, RandomPool
-  * password based key derivation functions: PBKDF1 and PBKDF2 from PKCS #5,
-    PBKDF from PKCS #12 appendix B
-  * Shamir's secret sharing scheme and Rabin's information dispersal algorithm
-    (IDA)
-  * fast multi-precision integer (bignum) and polynomial operations
-  * finite field arithmetics, including GF(p) and GF(2^n)
-  * prime number generation and verification
-  * useful non-cryptographic algorithms
-      + DEFLATE (RFC 1951) compression/decompression with gzip (RFC 1952) and
-        zlib (RFC 1950) format support
-      + hex, base-32, and base-64 coding/decoding
-      + 32-bit CRC and Adler32 checksum
-  * class wrappers for these operating system features (optional):
-      + high resolution timers on Windows, Unix, and Mac OS
-      + Berkeley and Windows style sockets
-      + Windows named pipes
-      + /dev/random, /dev/urandom, /dev/srandom
-      + Microsoft's CryptGenRandom on Windows
-  * A high level interface for most of the above, using a filter/pipeline
-    metaphor
-  * benchmarks and validation testing
-  * x86, x86-64 (x64), MMX, and SSE2 assembly code for the most commonly used
-    algorithms, with run-time CPU feature detection and code selection
-  * some versions are available in FIPS 140-2 validated form
-
-You are welcome to use it for any purpose without paying me, but see
-License.txt for the fine print.
-
-The following compilers are supported for this release. Please visit
-http://www.cryptopp.com the most up to date build instructions and porting notes.
-
-  * MSVC 6.0 - 2008
-  * GCC 3.3 - 4.3
-  * C++Builder 2009
-  * Intel C++ Compiler 9 - 11
-  * Sun Studio 12 (CC 5.9)
-
-*** Important Usage Notes ***
-
-1. If a constructor for A takes a pointer to an object B (except primitive
-types such as int and char), then A owns B and will delete B at A's
-destruction.  If a constructor for A takes a reference to an object B,
-then the caller retains ownership of B and should not destroy it until
-A no longer needs it. 
-
-2. Crypto++ is thread safe at the class level. This means you can use
-Crypto++ safely in a multithreaded application, but you must provide
-synchronization when multiple threads access a common Crypto++ object.
-
-*** MSVC-Specific Information ***
-
-On Windows, Crypto++ can be compiled into 3 forms: a static library
-including all algorithms, a DLL with only FIPS Approved algorithms, and
-a static library with only algorithms not in the DLL.
-(FIPS Approved means Approved according to the FIPS 140-2 standard.)
-The DLL may be used by itself, or it may be used together with the second
-form of the static library. MSVC project files are included to build
-all three forms, and sample applications using each of the three forms
-are also included.
-
-To compile Crypto++ with MSVC, open the "cryptest.dsw" (for MSVC 6 and MSVC .NET 
-2003) or "cryptest.sln" (for MSVC .NET 2005) workspace file and build one or 
-more of the following projects:
-
-cryptdll - This builds the DLL. Please note that if you wish to use Crypto++
-  as a FIPS validated module, you must use a pre-built DLL that has undergone
-  the FIPS validation process instead of building your own.
-dlltest - This builds a sample application that only uses the DLL.
-cryptest Non-DLL-Import Configuration - This builds the full static library
-  along with a full test driver.
-cryptest DLL-Import Configuration - This builds a static library containing
-  only algorithms not in the DLL, along with a full test driver that uses
-  both the DLL and the static library.
-
-To use the Crypto++ DLL in your application, #include "dll.h" before including
-any other Crypto++ header files, and place the DLL in the same directory as
-your .exe file. dll.h includes the line #pragma comment(lib, "cryptopp")
-so you don't have to explicitly list the import library in your project
-settings. To use a static library form of Crypto++, specify it as
-an additional library to link with in your project settings.
-In either case you should check the compiler options to
-make sure that the library and your application are using the same C++
-run-time libraries and calling conventions.
-
-*** DLL Memory Management ***
-
-Because it's possible for the Crypto++ DLL to delete objects allocated 
-by the calling application, they must use the same C++ memory heap. Three 
-methods are provided to achieve this.
-1.  The calling application can tell Crypto++ what heap to use. This method 
-    is required when the calling application uses a non-standard heap.
-2.  Crypto++ can tell the calling application what heap to use. This method 
-    is required when the calling application uses a statically linked C++ Run 
-    Time Library. (Method 1 does not work in this case because the Crypto++ DLL 
-    is initialized before the calling application's heap is initialized.)
-3.  Crypto++ can automatically use the heap provided by the calling application's 
-    dynamically linked C++ Run Time Library. The calling application must
-    make sure that the dynamically linked C++ Run Time Library is initialized
-    before Crypto++ is loaded. (At this time it is not clear if it is possible
-    to control the order in which DLLs are initialized on Windows 9x machines,
-    so it might be best to avoid using this method.)
-
-When Crypto++ attaches to a new process, it searches all modules loaded 
-into the process space for exported functions "GetNewAndDeleteForCryptoPP" 
-and "SetNewAndDeleteFromCryptoPP". If one of these functions is found, 
-Crypto++ uses methods 1 or 2, respectively, by calling the function. 
-Otherwise, method 3 is used. 
-
-*** GCC-Specific Information ***
-
-A makefile is included for you to compile Crypto++ with GCC. Make sure
-you are using GNU Make and GNU ld. The make process will produce two files,
-libcryptopp.a and cryptest.exe. Run "cryptest.exe v" for the validation
-suite.
-
-*** Documentation and Support ***
-
-Crypto++ is documented through inline comments in header files, which are
-processed through Doxygen to produce an HTML reference manual. You can find
-a link to the manual from http://www.cryptopp.com. Also at that site is
-the Crypto++ FAQ, which you should browse through before attempting to 
-use this library, because it will likely answer many of questions that
-may come up.
-
-If you run into any problems, please try the Crypto++ mailing list.
-The subscription information and the list archive are available on
-http://www.cryptopp.com. You can also email me directly by visiting
-http://www.weidai.com, but you will probably get a faster response through
-the mailing list.
-
-*** History ***
-
-1.0 - First public release.  Withdrawn at the request of RSA DSI.
-    - included Blowfish, BBS, DES, DH, Diamond, DSA, ElGamal, IDEA,
-      MD5, RC4, RC5, RSA, SHA, WAKE, secret sharing, DEFLATE compression
-    - had a serious bug in the RSA key generation code.
-
-1.1 - Removed RSA, RC4, RC5
-    - Disabled calls to RSAREF's non-public functions
-    - Minor bugs fixed
-
-2.0 - a completely new, faster multiprecision integer class
-    - added MD5-MAC, HAVAL, 3-WAY, TEA, SAFER, LUC, Rabin, BlumGoldwasser,
-      elliptic curve algorithms
-    - added the Lucas strong probable primality test
-    - ElGamal encryption and signature schemes modified to avoid weaknesses
-    - Diamond changed to Diamond2 because of key schedule weakness
-    - fixed bug in WAKE key setup
-    - SHS class renamed to SHA
-    - lots of miscellaneous optimizations
-
-2.1 - added Tiger, HMAC, GOST, RIPE-MD160, LUCELG, LUCDIF, XOR-MAC,
-      OAEP, PSSR, SHARK
-    - added precomputation to DH, ElGamal, DSA, and elliptic curve algorithms
-    - added back RC5 and a new RSA
-    - optimizations in elliptic curves over GF(p)
-    - changed Rabin to use OAEP and PSSR
-    - changed many classes to allow copy constructors to work correctly
-    - improved exception generation and handling
-
-2.2 - added SEAL, CAST-128, Square
-    - fixed bug in HAVAL (padding problem)
-    - fixed bug in triple-DES (decryption order was reversed)
-    - fixed bug in RC5 (couldn't handle key length not a multiple of 4)
-    - changed HMAC to conform to RFC-2104 (which is not compatible
-      with the original HMAC)
-    - changed secret sharing and information dispersal to use GF(2^32)
-      instead of GF(65521)
-    - removed zero knowledge prover/verifier for graph isomorphism
-    - removed several utility classes in favor of the C++ standard library
-
-2.3 - ported to EGCS
-    - fixed incomplete workaround of min/max conflict in MSVC
-
-3.0 - placed all names into the "CryptoPP" namespace
-    - added MD2, RC2, RC6, MARS, RW, DH2, MQV, ECDHC, CBC-CTS
-    - added abstract base classes PK_SimpleKeyAgreementDomain and
-      PK_AuthenticatedKeyAgreementDomain
-    - changed DH and LUCDIF to implement the PK_SimpleKeyAgreementDomain
-      interface and to perform domain parameter and key validation
-    - changed interfaces of PK_Signer and PK_Verifier to sign and verify
-      messages instead of message digests
-    - changed OAEP to conform to PKCS#1 v2.0
-    - changed benchmark code to produce HTML tables as output
-    - changed PSSR to track IEEE P1363a
-    - renamed ElGamalSignature to NR and changed it to track IEEE P1363
-    - renamed ECKEP to ECMQVC and changed it to track IEEE P1363
-    - renamed several other classes for clarity
-    - removed support for calling RSAREF
-    - removed option to compile old SHA (SHA-0)
-    - removed option not to throw exceptions
-
-3.1 - added ARC4, Rijndael, Twofish, Serpent, CBC-MAC, DMAC
-    - added interface for querying supported key lengths of symmetric ciphers
-      and MACs
-    - added sample code for RSA signature and verification
-    - changed CBC-CTS to be compatible with RFC 2040
-    - updated SEAL to version 3.0 of the cipher specification
-    - optimized multiprecision squaring and elliptic curves over GF(p)
-    - fixed bug in MARS key setup
-    - fixed bug with attaching objects to Deflator
-
-3.2 - added DES-XEX3, ECDSA, DefaultEncryptorWithMAC
-    - renamed DES-EDE to DES-EDE2 and TripleDES to DES-EDE3
-    - optimized ARC4
-    - generalized DSA to allow keys longer than 1024 bits
-    - fixed bugs in GF2N and ModularArithmetic that can cause calculation errors
-    - fixed crashing bug in Inflator when given invalid inputs
-    - fixed endian bug in Serpent
-    - fixed padding bug in Tiger
-
-4.0 - added Skipjack, CAST-256, Panama, SHA-2 (SHA-256, SHA-384, and SHA-512),
-      and XTR-DH
-    - added a faster variant of Rabin's Information Dispersal Algorithm (IDA)
-    - added class wrappers for these operating system features:
-      - high resolution timers on Windows, Unix, and MacOS
-      - Berkeley and Windows style sockets
-      - Windows named pipes
-      - /dev/random and /dev/urandom on Linux and FreeBSD
-      - Microsoft's CryptGenRandom on Windows
-    - added support for SEC 1 elliptic curve key format and compressed points
-    - added support for X.509 public key format (subjectPublicKeyInfo) for
-      RSA, DSA, and elliptic curve schemes
-    - added support for DER and OpenPGP signature format for DSA
-    - added support for ZLIB compressed data format (RFC 1950)
-    - changed elliptic curve encryption to use ECIES (as defined in SEC 1)
-    - changed MARS key schedule to reflect the latest specification
-    - changed BufferedTransformation interface to support multiple channels
-      and messages
-    - changed CAST and SHA-1 implementations to use public domain source code
-    - fixed bug in StringSource
-    - optmized multi-precision integer code for better performance
-
-4.1 - added more support for the recommended elliptic curve parameters in SEC 2
-    - added Panama MAC, MARC4
-    - added IV stealing feature to CTS mode
-    - added support for PKCS #8 private key format for RSA, DSA, and elliptic
-      curve schemes
-    - changed Deflate, MD5, Rijndael, and Twofish to use public domain code
-    - fixed a bug with flushing compressed streams
-    - fixed a bug with decompressing stored blocks
-    - fixed a bug with EC point decompression using non-trinomial basis
-    - fixed a bug in NetworkSource::GeneralPump()
-    - fixed a performance issue with EC over GF(p) decryption
-    - fixed syntax to allow GCC to compile without -fpermissive
-    - relaxed some restrictions in the license
-
-4.2 - added support for longer HMAC keys
-    - added MD4 (which is not secure so use for compatibility purposes only)
-    - added compatibility fixes/workarounds for STLport 4.5, GCC 3.0.2,
-      and MSVC 7.0
-    - changed MD2 to use public domain code
-    - fixed a bug with decompressing multiple messages with the same object
-    - fixed a bug in CBC-MAC with MACing multiple messages with the same object
-    - fixed a bug in RC5 and RC6 with zero-length keys
-    - fixed a bug in Adler32 where incorrect checksum may be generated
-
-5.0 - added ESIGN, DLIES, WAKE-OFB, PBKDF1 and PBKDF2 from PKCS #5
-    - added key validation for encryption and signature public/private keys
-    - renamed StreamCipher interface to SymmetricCipher, which is now implemented
-      by both stream ciphers and block cipher modes including ECB and CBC
-    - added keying interfaces to support resetting of keys and IVs without
-      having to destroy and recreate objects
-    - changed filter interface to support non-blocking input/output
-    - changed SocketSource and SocketSink to use overlapped I/O on Microsoft Windows
-    - grouped related classes inside structs to help templates, for example
-      AESEncryption and AESDecryption are now AES::Encryption and AES::Decryption
-    - where possible, typedefs have been added to improve backwards 
-      compatibility when the CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY macro is defined
-    - changed Serpent, HAVAL and IDEA to use public domain code
-    - implemented SSE2 optimizations for Integer operations
-    - fixed a bug in HMAC::TruncatedFinal()
-    - fixed SKIPJACK byte ordering following NIST clarification dated 5/9/02
-
-5.01 - added known answer test for X9.17 RNG in FIPS 140 power-up self test
-     - submitted to NIST/CSE, but not publicly released
-
-5.02 - changed EDC test to MAC integrity check using HMAC/SHA1
-     - improved performance of integrity check
-     - added blinding to defend against RSA timing attack
-
-5.03 - created DLL version of Crypto++ for FIPS 140-2 validation
-     - fixed vulnerabilities in GetNextIV for CTR and OFB modes
-
-5.0.4 - Removed DES, SHA-256, SHA-384, SHA-512 from DLL
-
-5.1 - added PSS padding and changed PSSR to track IEEE P1363a draft standard
-    - added blinding for RSA and Rabin to defend against timing attacks
-      on decryption operations
-    - changed signing and decryption APIs to support the above
-    - changed WaitObjectContainer to allow waiting for more than 64
-      objects at a time on Win32 platforms
-    - fixed a bug in CBC and ECB modes with processing non-aligned data
-    - fixed standard conformance bugs in DLIES (DHAES mode) and RW/EMSA2
-      signature scheme (these fixes are not backwards compatible)
-    - fixed a number of compiler warnings, minor bugs, and portability problems
-    - removed Sapphire
-
-5.2 - merged in changes for 5.01 - 5.0.4
-    - added support for using encoding parameters and key derivation parameters
-      with public key encryption (implemented by OAEP and DL/ECIES)
-    - added Camellia, SHACAL-2, Two-Track-MAC, Whirlpool, RIPEMD-320,
-      RIPEMD-128, RIPEMD-256, Base-32 coding, FIPS variant of CFB mode
-    - added ThreadUserTimer for timing thread CPU usage
-    - added option for password-based key derivation functions
-      to iterate until a mimimum elapsed thread CPU time is reached
-    - added option (on by default) for DEFLATE compression to detect
-      uncompressible files and process them more quickly
-    - improved compatibility and performance on 64-bit platforms,
-      including Alpha, IA-64, x86-64, PPC64, Sparc64, and MIPS64
-    - fixed ONE_AND_ZEROS_PADDING to use 0x80 instead 0x01 as padding.
-    - fixed encoding/decoding of PKCS #8 privateKeyInfo to properly
-      handle optional attributes
-
-5.2.1 - fixed bug in the "dlltest" DLL testing program
-      - fixed compiling with STLport using VC .NET
-      - fixed compiling with -fPIC using GCC
-      - fixed compiling with -msse2 on systems without memalign()
-      - fixed inability to instantiate PanamaMAC
-      - fixed problems with inline documentation
-
-5.2.2 - added SHA-224
-      - put SHA-256, SHA-384, SHA-512, RSASSA-PSS into DLL
-      
-5.2.3 - fixed issues with FIPS algorithm test vectors
-      - put RSASSA-ISO into DLL
-
-5.3 - ported to MSVC 2005 with support for x86-64
-    - added defense against AES timing attacks, and more AES test vectors
-    - changed StaticAlgorithmName() of Rijndael to "AES", CTR to "CTR"
-
-5.4 - added Salsa20
-    - updated Whirlpool to version 3.0
-    - ported to GCC 4.1, Sun C++ 5.8, and Borland C++Builder 2006
-
-5.5 - added VMAC and Sosemanuk (with x86-64 and SSE2 assembly)
-    - improved speed of integer arithmetic, AES, SHA-512, Tiger, Salsa20,
-      Whirlpool, and PANAMA cipher using assembly (x86-64, MMX, SSE2)
-    - optimized Camellia and added defense against timing attacks
-    - updated benchmarks code to show cycles per byte and to time key/IV setup
-    - started using OpenMP for increased multi-core speed
-    - enabled GCC optimization flags by default in GNUmakefile
-    - added blinding and computational error checking for RW signing
-    - changed RandomPool, X917RNG, GetNextIV, DSA/NR/ECDSA/ECNR to reduce
-      the risk of reusing random numbers and IVs after virtual machine state
-      rollback
-    - changed default FIPS mode RNG from AutoSeededX917RNG<DES_EDE3> to
-      AutoSeededX917RNG<AES>
-    - fixed PANAMA cipher interface to accept 256-bit key and 256-bit IV
-    - moved MD2, MD4, MD5, PanamaHash, ARC4, WAKE_CFB into the namespace "Weak"
-    - removed HAVAL, MD5-MAC, XMAC
-
-5.5.1 - fixed VMAC validation failure on 32-bit big-endian machines
-
-5.5.2 - ported x64 assembly language code for AES, Salsa20, Sosemanuk, and Panama
-        to MSVC 2005 (using MASM since MSVC doesn't support inline assembly on x64)
-      - fixed Salsa20 initialization crash on non-SSE2 machines
-      - fixed Whirlpool crash on Pentium 2 machines
-      - fixed possible branch prediction analysis (BPA) vulnerability in
-        MontgomeryReduce(), which may affect security of RSA, RW, LUC
-      - fixed link error with MSVC 2003 when using "debug DLL" form of runtime library
-      - fixed crash in SSE2_Add on P4 machines when compiled with 
-        MSVC 6.0 SP5 with Processor Pack
-      - ported to MSVC 2008, GCC 4.2, Sun CC 5.9, Intel C++ Compiler 10.0, 
-        and Borland C++Builder 2007
-
-5.6 - added AuthenticatedSymmetricCipher interface class and Filter wrappers
-    - added CCM, GCM (with SSE2 assembly), EAX, CMAC, XSalsa20, and SEED
-    - added support for variable length IVs
-    - improved AES and SHA-256 speed on x86 and x64
-    - fixed incorrect VMAC computation on message lengths 
-      that are >64 mod 128 (x86 assembly version is not affected)
-    - fixed compiler error in vmac.cpp on x86 with GCC -fPIC
-    - fixed run-time validation error on x86-64 with GCC 4.3.2 -O2
-    - fixed HashFilter bug when putMessage=true
-    - removed WORD64_AVAILABLE; compiler support for 64-bit int is now required
-    - ported to GCC 4.3, C++Builder 2009, Sun CC 5.10, Intel C++ Compiler 11
-
-Written by Wei Dai
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/secblock.h bitcoin-0.3.20/src/cryptopp/secblock.h
--- bitcoin-0.3.20.orig/src/cryptopp/secblock.h	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/secblock.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,501 +0,0 @@
-// secblock.h - written and placed in the public domain by Wei Dai
-
-#ifndef CRYPTOPP_SECBLOCK_H
-#define CRYPTOPP_SECBLOCK_H
-
-#include "config.h"
-#include "misc.h"
-#include <assert.h>
-
-#if defined(CRYPTOPP_MEMALIGN_AVAILABLE) || defined(CRYPTOPP_MM_MALLOC_AVAILABLE) || defined(QNX)
-	#include <malloc.h>
-#else
-	#include <stdlib.h>
-#endif
-
-NAMESPACE_BEGIN(CryptoPP)
-
-// ************** secure memory allocation ***************
-
-template<class T>
-class AllocatorBase
-{
-public:
-	typedef T value_type;
-	typedef size_t size_type;
-#ifdef CRYPTOPP_MSVCRT6
-	typedef ptrdiff_t difference_type;
-#else
-	typedef std::ptrdiff_t difference_type;
-#endif
-	typedef T * pointer;
-	typedef const T * const_pointer;
-	typedef T & reference;
-	typedef const T & const_reference;
-
-	pointer address(reference r) const {return (&r);}
-	const_pointer address(const_reference r) const {return (&r); }
-	void construct(pointer p, const T& val) {new (p) T(val);}
-	void destroy(pointer p) {p->~T();}
-	size_type max_size() const {return ~size_type(0)/sizeof(T);}	// switch to std::numeric_limits<T>::max later
-
-protected:
-	static void CheckSize(size_t n)
-	{
-		if (n > ~size_t(0) / sizeof(T))
-			throw InvalidArgument("AllocatorBase: requested size would cause integer overflow");
-	}
-};
-
-#define CRYPTOPP_INHERIT_ALLOCATOR_TYPES	\
-typedef typename AllocatorBase<T>::value_type value_type;\
-typedef typename AllocatorBase<T>::size_type size_type;\
-typedef typename AllocatorBase<T>::difference_type difference_type;\
-typedef typename AllocatorBase<T>::pointer pointer;\
-typedef typename AllocatorBase<T>::const_pointer const_pointer;\
-typedef typename AllocatorBase<T>::reference reference;\
-typedef typename AllocatorBase<T>::const_reference const_reference;
-
-#if defined(_MSC_VER) && (_MSC_VER < 1300)
-// this pragma causes an internal compiler error if placed immediately before std::swap(a, b)
-#pragma warning(push)
-#pragma warning(disable: 4700)	// VC60 workaround: don't know how to get rid of this warning
-#endif
-
-template <class T, class A>
-typename A::pointer StandardReallocate(A& a, T *p, typename A::size_type oldSize, typename A::size_type newSize, bool preserve)
-{
-	if (oldSize == newSize)
-		return p;
-
-	if (preserve)
-	{
-		typename A::pointer newPointer = a.allocate(newSize, NULL);
-		memcpy_s(newPointer, sizeof(T)*newSize, p, sizeof(T)*STDMIN(oldSize, newSize));
-		a.deallocate(p, oldSize);
-		return newPointer;
-	}
-	else
-	{
-		a.deallocate(p, oldSize);
-		return a.allocate(newSize, NULL);
-	}
-}
-
-#if defined(_MSC_VER) && (_MSC_VER < 1300)
-#pragma warning(pop)
-#endif
-
-template <class T, bool T_Align16 = false>
-class AllocatorWithCleanup : public AllocatorBase<T>
-{
-public:
-	CRYPTOPP_INHERIT_ALLOCATOR_TYPES
-
-	pointer allocate(size_type n, const void * = NULL)
-	{
-		CheckSize(n);
-		if (n == 0)
-			return NULL;
-
-		if (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16 && n*sizeof(T) >= 16)
-		{
-			byte *p;
-		#ifdef CRYPTOPP_MM_MALLOC_AVAILABLE
-			while (!(p = (byte *)_mm_malloc(sizeof(T)*n, 16)))
-		#elif defined(CRYPTOPP_MEMALIGN_AVAILABLE)
-			while (!(p = (byte *)memalign(16, sizeof(T)*n)))
-		#elif defined(CRYPTOPP_MALLOC_ALIGNMENT_IS_16)
-			while (!(p = (byte *)malloc(sizeof(T)*n)))
-		#else
-			while (!(p = (byte *)malloc(sizeof(T)*n + 16)))
-		#endif
-				CallNewHandler();
-
-		#ifdef CRYPTOPP_NO_ALIGNED_ALLOC
-			size_t adjustment = 16-((size_t)p%16);
-			p += adjustment;
-			p[-1] = (byte)adjustment;
-		#endif
-
-			assert(IsAlignedOn(p, 16));
-			return (pointer)p;
-		}
-
-		pointer p;
-		while (!(p = (pointer)malloc(sizeof(T)*n)))
-			CallNewHandler();
-		return p;
-	}
-
-	void deallocate(void *p, size_type n)
-	{
-		memset_z(p, 0, n*sizeof(T));
-
-		if (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16 && n*sizeof(T) >= 16)
-		{
-		#ifdef CRYPTOPP_MM_MALLOC_AVAILABLE
-			_mm_free(p);
-		#elif defined(CRYPTOPP_NO_ALIGNED_ALLOC)
-			p = (byte *)p - ((byte *)p)[-1];
-			free(p);
-		#else
-			free(p);
-		#endif
-			return;
-		}
-
-		free(p);
-	}
-
-	pointer reallocate(T *p, size_type oldSize, size_type newSize, bool preserve)
-	{
-		return StandardReallocate(*this, p, oldSize, newSize, preserve);
-	}
-
-	// VS.NET STL enforces the policy of "All STL-compliant allocators have to provide a
-	// template class member called rebind".
-    template <class U> struct rebind { typedef AllocatorWithCleanup<U, T_Align16> other; };
-#if _MSC_VER >= 1500
-	AllocatorWithCleanup() {}
-	template <class U, bool A> AllocatorWithCleanup(const AllocatorWithCleanup<U, A> &) {}
-#endif
-};
-
-CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<byte>;
-CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word16>;
-CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word32>;
-CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word64>;
-#if CRYPTOPP_BOOL_X86
-CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word, true>;	// for Integer
-#endif
-
-template <class T>
-class NullAllocator : public AllocatorBase<T>
-{
-public:
-	CRYPTOPP_INHERIT_ALLOCATOR_TYPES
-
-	pointer allocate(size_type n, const void * = NULL)
-	{
-		assert(false);
-		return NULL;
-	}
-
-	void deallocate(void *p, size_type n)
-	{
-		//// Bitcoin: don't know why this trips, probably a false alarm, depends on the compiler used. 
-		//assert(false);
-	}
-
-	size_type max_size() const {return 0;}
-};
-
-// This allocator can't be used with standard collections because
-// they require that all objects of the same allocator type are equivalent.
-// So this is for use with SecBlock only.
-template <class T, size_t S, class A = NullAllocator<T>, bool T_Align16 = false>
-class FixedSizeAllocatorWithCleanup : public AllocatorBase<T>
-{
-public:
-	CRYPTOPP_INHERIT_ALLOCATOR_TYPES
-
-	FixedSizeAllocatorWithCleanup() : m_allocated(false) {}
-
-	pointer allocate(size_type n)
-	{
-		assert(IsAlignedOn(m_array, 8));
-
-		if (n <= S && !m_allocated)
-		{
-			m_allocated = true;
-			return GetAlignedArray();
-		}
-		else
-			return m_fallbackAllocator.allocate(n);
-	}
-
-	pointer allocate(size_type n, const void *hint)
-	{
-		if (n <= S && !m_allocated)
-		{
-			m_allocated = true;
-			return GetAlignedArray();
-		}
-		else
-			return m_fallbackAllocator.allocate(n, hint);
-	}
-
-	void deallocate(void *p, size_type n)
-	{
-		if (p == GetAlignedArray())
-		{
-			assert(n <= S);
-			assert(m_allocated);
-			m_allocated = false;
-			memset(p, 0, n*sizeof(T));
-		}
-		else
-			m_fallbackAllocator.deallocate(p, n);
-	}
-
-	pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)
-	{
-		if (p == GetAlignedArray() && newSize <= S)
-		{
-			assert(oldSize <= S);
-			if (oldSize > newSize)
-				memset(p + newSize, 0, (oldSize-newSize)*sizeof(T));
-			return p;
-		}
-
-		pointer newPointer = allocate(newSize, NULL);
-		if (preserve)
-			memcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));
-		deallocate(p, oldSize);
-		return newPointer;
-	}
-
-	size_type max_size() const {return STDMAX(m_fallbackAllocator.max_size(), S);}
-
-private:
-#ifdef __BORLANDC__
-	T* GetAlignedArray() {return m_array;}
-	T m_array[S];
-#else
-	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}
-	CRYPTOPP_ALIGN_DATA(8) T m_array[(CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? S+8/sizeof(T) : S];
-#endif
-	A m_fallbackAllocator;
-	bool m_allocated;
-};
-
-//! a block of memory allocated using A
-template <class T, class A = AllocatorWithCleanup<T> >
-class SecBlock
-{
-public:
-	typedef typename A::value_type value_type;
-	typedef typename A::pointer iterator;
-	typedef typename A::const_pointer const_iterator;
-	typedef typename A::size_type size_type;
-
-	explicit SecBlock(size_type size=0)
-		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}
-	SecBlock(const SecBlock<T, A> &t)
-		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}
-	SecBlock(const T *t, size_type len)
-		: m_size(len)
-	{
-		m_ptr = m_alloc.allocate(len, NULL);
-		if (t == NULL)
-			memset_z(m_ptr, 0, len*sizeof(T));
-		else
-			memcpy(m_ptr, t, len*sizeof(T));
-	}
-
-	~SecBlock()
-		{m_alloc.deallocate(m_ptr, m_size);}
-
-#ifdef __BORLANDC__
-	operator T *() const
-		{return (T*)m_ptr;}
-#else
-	operator const void *() const
-		{return m_ptr;}
-	operator void *()
-		{return m_ptr;}
-
-	operator const T *() const
-		{return m_ptr;}
-	operator T *()
-		{return m_ptr;}
-#endif
-
-//	T *operator +(size_type offset)
-//		{return m_ptr+offset;}
-
-//	const T *operator +(size_type offset) const
-//		{return m_ptr+offset;}
-
-//	T& operator[](size_type index)
-//		{assert(index >= 0 && index < m_size); return m_ptr[index];}
-
-//	const T& operator[](size_type index) const
-//		{assert(index >= 0 && index < m_size); return m_ptr[index];}
-
-	iterator begin()
-		{return m_ptr;}
-	const_iterator begin() const
-		{return m_ptr;}
-	iterator end()
-		{return m_ptr+m_size;}
-	const_iterator end() const
-		{return m_ptr+m_size;}
-
-	typename A::pointer data() {return m_ptr;}
-	typename A::const_pointer data() const {return m_ptr;}
-
-	size_type size() const {return m_size;}
-	bool empty() const {return m_size == 0;}
-
-	byte * BytePtr() {return (byte *)m_ptr;}
-	const byte * BytePtr() const {return (const byte *)m_ptr;}
-	size_type SizeInBytes() const {return m_size*sizeof(T);}
-
-	//! set contents and size
-	void Assign(const T *t, size_type len)
-	{
-		New(len);
-		memcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));
-	}
-
-	//! copy contents and size from another SecBlock
-	void Assign(const SecBlock<T, A> &t)
-	{
-		New(t.m_size);
-		memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));
-	}
-
-	SecBlock<T, A>& operator=(const SecBlock<T, A> &t)
-	{
-		Assign(t);
-		return *this;
-	}
-
-	// append to this object
-	SecBlock<T, A>& operator+=(const SecBlock<T, A> &t)
-	{
-		size_type oldSize = m_size;
-		Grow(m_size+t.m_size);
-		memcpy_s(m_ptr+oldSize, m_size*sizeof(T), t.m_ptr, t.m_size*sizeof(T));
-		return *this;
-	}
-
-	// append operator
-	SecBlock<T, A> operator+(const SecBlock<T, A> &t)
-	{
-		SecBlock<T, A> result(m_size+t.m_size);
-		memcpy_s(result.m_ptr, result.m_size*sizeof(T), m_ptr, m_size*sizeof(T));
-		memcpy_s(result.m_ptr+m_size, t.m_size*sizeof(T), t.m_ptr, t.m_size*sizeof(T));
-		return result;
-	}
-
-	bool operator==(const SecBlock<T, A> &t) const
-	{
-		return m_size == t.m_size && VerifyBufsEqual(m_ptr, t.m_ptr, m_size*sizeof(T));
-	}
-
-	bool operator!=(const SecBlock<T, A> &t) const
-	{
-		return !operator==(t);
-	}
-
-	//! change size, without preserving contents
-	void New(size_type newSize)
-	{
-		m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);
-		m_size = newSize;
-	}
-
-	//! change size and set contents to 0
-	void CleanNew(size_type newSize)
-	{
-		New(newSize);
-		memset_z(m_ptr, 0, m_size*sizeof(T));
-	}
-
-	//! change size only if newSize > current size. contents are preserved
-	void Grow(size_type newSize)
-	{
-		if (newSize > m_size)
-		{
-			m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);
-			m_size = newSize;
-		}
-	}
-
-	//! change size only if newSize > current size. contents are preserved and additional area is set to 0
-	void CleanGrow(size_type newSize)
-	{
-		if (newSize > m_size)
-		{
-			m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);
-			memset(m_ptr+m_size, 0, (newSize-m_size)*sizeof(T));
-			m_size = newSize;
-		}
-	}
-
-	//! change size and preserve contents
-	void resize(size_type newSize)
-	{
-		m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);
-		m_size = newSize;
-	}
-
-	//! swap contents and size with another SecBlock
-	void swap(SecBlock<T, A> &b)
-	{
-		std::swap(m_alloc, b.m_alloc);
-		std::swap(m_size, b.m_size);
-		std::swap(m_ptr, b.m_ptr);
-	}
-
-//private:
-	A m_alloc;
-	size_type m_size;
-	T *m_ptr;
-};
-
-typedef SecBlock<byte> SecByteBlock;
-typedef SecBlock<byte, AllocatorWithCleanup<byte, true> > AlignedSecByteBlock;
-typedef SecBlock<word> SecWordBlock;
-
-//! a SecBlock with fixed size, allocated statically
-template <class T, unsigned int S, class A = FixedSizeAllocatorWithCleanup<T, S> >
-class FixedSizeSecBlock : public SecBlock<T, A>
-{
-public:
-	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}
-};
-
-template <class T, unsigned int S, bool T_Align16 = true>
-class FixedSizeAlignedSecBlock : public FixedSizeSecBlock<T, S, FixedSizeAllocatorWithCleanup<T, S, NullAllocator<T>, T_Align16> >
-{
-};
-
-//! a SecBlock that preallocates size S statically, and uses the heap when this size is exceeded
-template <class T, unsigned int S, class A = FixedSizeAllocatorWithCleanup<T, S, AllocatorWithCleanup<T> > >
-class SecBlockWithHint : public SecBlock<T, A>
-{
-public:
-	explicit SecBlockWithHint(size_t size) : SecBlock<T, A>(size) {}
-};
-
-template<class T, bool A, class U, bool B>
-inline bool operator==(const CryptoPP::AllocatorWithCleanup<T, A>&, const CryptoPP::AllocatorWithCleanup<U, B>&) {return (true);}
-template<class T, bool A, class U, bool B>
-inline bool operator!=(const CryptoPP::AllocatorWithCleanup<T, A>&, const CryptoPP::AllocatorWithCleanup<U, B>&) {return (false);}
-
-NAMESPACE_END
-
-NAMESPACE_BEGIN(std)
-template <class T, class A>
-inline void swap(CryptoPP::SecBlock<T, A> &a, CryptoPP::SecBlock<T, A> &b)
-{
-	a.swap(b);
-}
-
-#if defined(_STLP_DONT_SUPPORT_REBIND_MEMBER_TEMPLATE) || (defined(_STLPORT_VERSION) && !defined(_STLP_MEMBER_TEMPLATE_CLASSES))
-// working for STLport 5.1.3 and MSVC 6 SP5
-template <class _Tp1, class _Tp2>
-inline CryptoPP::AllocatorWithCleanup<_Tp2>&
-__stl_alloc_rebind(CryptoPP::AllocatorWithCleanup<_Tp1>& __a, const _Tp2*)
-{
-	return (CryptoPP::AllocatorWithCleanup<_Tp2>&)(__a);
-}
-#endif
-
-NAMESPACE_END
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/sha.cpp bitcoin-0.3.20/src/cryptopp/sha.cpp
--- bitcoin-0.3.20.orig/src/cryptopp/sha.cpp	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/sha.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,899 +0,0 @@
-// sha.cpp - modified by Wei Dai from Steve Reid's public domain sha1.c
-
-// Steve Reid implemented SHA-1. Wei Dai implemented SHA-2.
-// Both are in the public domain.
-
-// use "cl /EP /P /DCRYPTOPP_GENERATE_X64_MASM sha.cpp" to generate MASM code
-
-#include "pch.h"
-
-#ifndef CRYPTOPP_IMPORTS
-#ifndef CRYPTOPP_GENERATE_X64_MASM
-
-#include "sha.h"
-#include "misc.h"
-#include "cpu.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-// start of Steve Reid's code
-
-#define blk0(i) (W[i] = data[i])
-#define blk1(i) (W[i&15] = rotlFixed(W[(i+13)&15]^W[(i+8)&15]^W[(i+2)&15]^W[i&15],1))
-
-void SHA1::InitState(HashWordType *state)
-{
-	state[0] = 0x67452301L;
-	state[1] = 0xEFCDAB89L;
-	state[2] = 0x98BADCFEL;
-	state[3] = 0x10325476L;
-	state[4] = 0xC3D2E1F0L;
-}
-
-#define f1(x,y,z) (z^(x&(y^z)))
-#define f2(x,y,z) (x^y^z)
-#define f3(x,y,z) ((x&y)|(z&(x|y)))
-#define f4(x,y,z) (x^y^z)
-
-/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
-#define R0(v,w,x,y,z,i) z+=f1(w,x,y)+blk0(i)+0x5A827999+rotlFixed(v,5);w=rotlFixed(w,30);
-#define R1(v,w,x,y,z,i) z+=f1(w,x,y)+blk1(i)+0x5A827999+rotlFixed(v,5);w=rotlFixed(w,30);
-#define R2(v,w,x,y,z,i) z+=f2(w,x,y)+blk1(i)+0x6ED9EBA1+rotlFixed(v,5);w=rotlFixed(w,30);
-#define R3(v,w,x,y,z,i) z+=f3(w,x,y)+blk1(i)+0x8F1BBCDC+rotlFixed(v,5);w=rotlFixed(w,30);
-#define R4(v,w,x,y,z,i) z+=f4(w,x,y)+blk1(i)+0xCA62C1D6+rotlFixed(v,5);w=rotlFixed(w,30);
-
-void SHA1::Transform(word32 *state, const word32 *data)
-{
-	word32 W[16];
-    /* Copy context->state[] to working vars */
-    word32 a = state[0];
-    word32 b = state[1];
-    word32 c = state[2];
-    word32 d = state[3];
-    word32 e = state[4];
-    /* 4 rounds of 20 operations each. Loop unrolled. */
-    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
-    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
-    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
-    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
-    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
-    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
-    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
-    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
-    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
-    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
-    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
-    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
-    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
-    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
-    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
-    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
-    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
-    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
-    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
-    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
-    /* Add the working vars back into context.state[] */
-    state[0] += a;
-    state[1] += b;
-    state[2] += c;
-    state[3] += d;
-    state[4] += e;
-}
-
-// end of Steve Reid's code
-
-// *************************************************************
-
-void SHA224::InitState(HashWordType *state)
-{
-	static const word32 s[8] = {0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4};
-	memcpy(state, s, sizeof(s));
-}
-
-void SHA256::InitState(HashWordType *state)
-{
-	static const word32 s[8] = {0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};
-	memcpy(state, s, sizeof(s));
-}
-
-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
-CRYPTOPP_ALIGN_DATA(16) extern const word32 SHA256_K[64] CRYPTOPP_SECTION_ALIGN16 = {
-#else
-extern const word32 SHA256_K[64] = {
-#endif
-	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
-	0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
-	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
-	0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
-	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
-	0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
-	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
-	0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
-	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
-	0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
-	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
-	0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
-	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
-	0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
-	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
-	0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
-};
-
-#endif // #ifndef CRYPTOPP_GENERATE_X64_MASM
-
-#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_GENERATE_X64_MASM)
-
-#pragma warning(disable: 4731)	// frame pointer register 'ebp' modified by inline assembly code
-
-static void CRYPTOPP_FASTCALL X86_SHA256_HashBlocks(word32 *state, const word32 *data, size_t len
-#if defined(_MSC_VER) && (_MSC_VER == 1200)
-	, ...	// VC60 workaround: prevent VC 6 from inlining this function
-#endif
-	)
-{
-#if defined(_MSC_VER) && (_MSC_VER == 1200)
-	AS2(mov ecx, [state])
-	AS2(mov edx, [data])
-#endif
-
-	#define LOCALS_SIZE	8*4 + 16*4 + 4*WORD_SZ
-	#define H(i)		[BASE+ASM_MOD(1024+7-(i),8)*4]
-	#define G(i)		H(i+1)
-	#define F(i)		H(i+2)
-	#define E(i)		H(i+3)
-	#define D(i)		H(i+4)
-	#define C(i)		H(i+5)
-	#define B(i)		H(i+6)
-	#define A(i)		H(i+7)
-	#define Wt(i)		BASE+8*4+ASM_MOD(1024+15-(i),16)*4
-	#define Wt_2(i)		Wt((i)-2)
-	#define Wt_15(i)	Wt((i)-15)
-	#define Wt_7(i)		Wt((i)-7)
-	#define K_END		[BASE+8*4+16*4+0*WORD_SZ]
-	#define STATE_SAVE	[BASE+8*4+16*4+1*WORD_SZ]
-	#define DATA_SAVE	[BASE+8*4+16*4+2*WORD_SZ]
-	#define DATA_END	[BASE+8*4+16*4+3*WORD_SZ]
-	#define Kt(i)		WORD_REG(si)+(i)*4
-#if CRYPTOPP_BOOL_X86
-	#define BASE		esp+4
-#elif defined(__GNUC__)
-	#define BASE		r8
-#else
-	#define BASE		rsp
-#endif
-
-#define RA0(i, edx, edi)		\
-	AS2(	add edx, [Kt(i)]	)\
-	AS2(	add edx, [Wt(i)]	)\
-	AS2(	add edx, H(i)		)\
-
-#define RA1(i, edx, edi)
-
-#define RB0(i, edx, edi)
-
-#define RB1(i, edx, edi)	\
-	AS2(	mov AS_REG_7d, [Wt_2(i)]	)\
-	AS2(	mov edi, [Wt_15(i)])\
-	AS2(	mov ebx, AS_REG_7d	)\
-	AS2(	shr AS_REG_7d, 10		)\
-	AS2(	ror ebx, 17		)\
-	AS2(	xor AS_REG_7d, ebx	)\
-	AS2(	ror ebx, 2		)\
-	AS2(	xor ebx, AS_REG_7d	)/* s1(W_t-2) */\
-	AS2(	add ebx, [Wt_7(i)])\
-	AS2(	mov AS_REG_7d, edi	)\
-	AS2(	shr AS_REG_7d, 3		)\
-	AS2(	ror edi, 7		)\
-	AS2(	add ebx, [Wt(i)])/* s1(W_t-2) + W_t-7 + W_t-16 */\
-	AS2(	xor AS_REG_7d, edi	)\
-	AS2(	add edx, [Kt(i)])\
-	AS2(	ror edi, 11		)\
-	AS2(	add edx, H(i)	)\
-	AS2(	xor AS_REG_7d, edi	)/* s0(W_t-15) */\
-	AS2(	add AS_REG_7d, ebx	)/* W_t = s1(W_t-2) + W_t-7 + s0(W_t-15) W_t-16*/\
-	AS2(	mov [Wt(i)], AS_REG_7d)\
-	AS2(	add edx, AS_REG_7d	)\
-
-#define ROUND(i, r, eax, ecx, edi, edx)\
-	/* in: edi = E	*/\
-	/* unused: eax, ecx, temp: ebx, AS_REG_7d, out: edx = T1 */\
-	AS2(	mov edx, F(i)	)\
-	AS2(	xor edx, G(i)	)\
-	AS2(	and edx, edi	)\
-	AS2(	xor edx, G(i)	)/* Ch(E,F,G) = (G^(E&(F^G))) */\
-	AS2(	mov AS_REG_7d, edi	)\
-	AS2(	ror edi, 6		)\
-	AS2(	ror AS_REG_7d, 25		)\
-	RA##r(i, edx, edi		)/* H + Wt + Kt + Ch(E,F,G) */\
-	AS2(	xor AS_REG_7d, edi	)\
-	AS2(	ror edi, 5		)\
-	AS2(	xor AS_REG_7d, edi	)/* S1(E) */\
-	AS2(	add edx, AS_REG_7d	)/* T1 = S1(E) + Ch(E,F,G) + H + Wt + Kt */\
-	RB##r(i, edx, edi		)/* H + Wt + Kt + Ch(E,F,G) */\
-	/* in: ecx = A, eax = B^C, edx = T1 */\
-	/* unused: edx, temp: ebx, AS_REG_7d, out: eax = A, ecx = B^C, edx = E */\
-	AS2(	mov ebx, ecx	)\
-	AS2(	xor ecx, B(i)	)/* A^B */\
-	AS2(	and eax, ecx	)\
-	AS2(	xor eax, B(i)	)/* Maj(A,B,C) = B^((A^B)&(B^C) */\
-	AS2(	mov AS_REG_7d, ebx	)\
-	AS2(	ror ebx, 2		)\
-	AS2(	add eax, edx	)/* T1 + Maj(A,B,C) */\
-	AS2(	add edx, D(i)	)\
-	AS2(	mov D(i), edx	)\
-	AS2(	ror AS_REG_7d, 22		)\
-	AS2(	xor AS_REG_7d, ebx	)\
-	AS2(	ror ebx, 11		)\
-	AS2(	xor AS_REG_7d, ebx	)\
-	AS2(	add eax, AS_REG_7d	)/* T1 + S0(A) + Maj(A,B,C) */\
-	AS2(	mov H(i), eax	)\
-
-#define SWAP_COPY(i)		\
-	AS2(	mov		WORD_REG(bx), [WORD_REG(dx)+i*WORD_SZ])\
-	AS1(	bswap	WORD_REG(bx))\
-	AS2(	mov		[Wt(i*(1+CRYPTOPP_BOOL_X64)+CRYPTOPP_BOOL_X64)], WORD_REG(bx))
-
-#if defined(__GNUC__)
-	#if CRYPTOPP_BOOL_X64
-		FixedSizeAlignedSecBlock<byte, LOCALS_SIZE> workspace;
-	#endif
-	__asm__ __volatile__
-	(
-	#if CRYPTOPP_BOOL_X64
-		"lea %4, %%r8;"
-	#endif
-	".intel_syntax noprefix;"
-#elif defined(CRYPTOPP_GENERATE_X64_MASM)
-		ALIGN   8
-	X86_SHA256_HashBlocks	PROC FRAME
-		rex_push_reg rsi
-		push_reg rdi
-		push_reg rbx
-		push_reg rbp
-		alloc_stack(LOCALS_SIZE+8)
-		.endprolog
-		mov rdi, r8
-		lea rsi, [?SHA256_K@CryptoPP@@3QBIB + 48*4]
-#endif
-
-#if CRYPTOPP_BOOL_X86
-	#ifndef __GNUC__
-		AS2(	mov		edi, [len])
-		AS2(	lea		WORD_REG(si), [SHA256_K+48*4])
-	#endif
-	#if !defined(_MSC_VER) || (_MSC_VER < 1400)
-		AS_PUSH_IF86(bx)
-	#endif
-
-	AS_PUSH_IF86(bp)
-	AS2(	mov		ebx, esp)
-	AS2(	and		esp, -16)
-	AS2(	sub		WORD_REG(sp), LOCALS_SIZE)
-	AS_PUSH_IF86(bx)
-#endif
-	AS2(	mov		STATE_SAVE, WORD_REG(cx))
-	AS2(	mov		DATA_SAVE, WORD_REG(dx))
-	AS2(	add		WORD_REG(di), WORD_REG(dx))
-	AS2(	mov		DATA_END, WORD_REG(di))
-	AS2(	mov		K_END, WORD_REG(si))
-
-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
-#if CRYPTOPP_BOOL_X86
-	AS2(	test	edi, 1)
-	ASJ(	jnz,	2, f)
-#endif
-	AS2(	movdqa	xmm0, XMMWORD_PTR [WORD_REG(cx)+0*16])
-	AS2(	movdqa	xmm1, XMMWORD_PTR [WORD_REG(cx)+1*16])
-#endif
-
-#if CRYPTOPP_BOOL_X86
-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
-	ASJ(	jmp,	0, f)
-#endif
-	ASL(2)	// non-SSE2
-	AS2(	mov		esi, ecx)
-	AS2(	lea		edi, A(0))
-	AS2(	mov		ecx, 8)
-	AS1(	rep movsd)
-	AS2(	mov		esi, K_END)
-	ASJ(	jmp,	3, f)
-#endif
-
-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
-	ASL(0)
-	AS2(	movdqa	E(0), xmm1)
-	AS2(	movdqa	A(0), xmm0)
-#endif
-#if CRYPTOPP_BOOL_X86
-	ASL(3)
-#endif
-	AS2(	sub		WORD_REG(si), 48*4)
-	SWAP_COPY(0)	SWAP_COPY(1)	SWAP_COPY(2)	SWAP_COPY(3)
-	SWAP_COPY(4)	SWAP_COPY(5)	SWAP_COPY(6)	SWAP_COPY(7)
-#if CRYPTOPP_BOOL_X86
-	SWAP_COPY(8)	SWAP_COPY(9)	SWAP_COPY(10)	SWAP_COPY(11)
-	SWAP_COPY(12)	SWAP_COPY(13)	SWAP_COPY(14)	SWAP_COPY(15)
-#endif
-	AS2(	mov		edi, E(0))	// E
-	AS2(	mov		eax, B(0))	// B
-	AS2(	xor		eax, C(0))	// B^C
-	AS2(	mov		ecx, A(0))	// A
-
-	ROUND(0, 0, eax, ecx, edi, edx)
-	ROUND(1, 0, ecx, eax, edx, edi)
-	ROUND(2, 0, eax, ecx, edi, edx)
-	ROUND(3, 0, ecx, eax, edx, edi)
-	ROUND(4, 0, eax, ecx, edi, edx)
-	ROUND(5, 0, ecx, eax, edx, edi)
-	ROUND(6, 0, eax, ecx, edi, edx)
-	ROUND(7, 0, ecx, eax, edx, edi)
-	ROUND(8, 0, eax, ecx, edi, edx)
-	ROUND(9, 0, ecx, eax, edx, edi)
-	ROUND(10, 0, eax, ecx, edi, edx)
-	ROUND(11, 0, ecx, eax, edx, edi)
-	ROUND(12, 0, eax, ecx, edi, edx)
-	ROUND(13, 0, ecx, eax, edx, edi)
-	ROUND(14, 0, eax, ecx, edi, edx)
-	ROUND(15, 0, ecx, eax, edx, edi)
-
-	ASL(1)
-	AS2(add WORD_REG(si), 4*16)
-	ROUND(0, 1, eax, ecx, edi, edx)
-	ROUND(1, 1, ecx, eax, edx, edi)
-	ROUND(2, 1, eax, ecx, edi, edx)
-	ROUND(3, 1, ecx, eax, edx, edi)
-	ROUND(4, 1, eax, ecx, edi, edx)
-	ROUND(5, 1, ecx, eax, edx, edi)
-	ROUND(6, 1, eax, ecx, edi, edx)
-	ROUND(7, 1, ecx, eax, edx, edi)
-	ROUND(8, 1, eax, ecx, edi, edx)
-	ROUND(9, 1, ecx, eax, edx, edi)
-	ROUND(10, 1, eax, ecx, edi, edx)
-	ROUND(11, 1, ecx, eax, edx, edi)
-	ROUND(12, 1, eax, ecx, edi, edx)
-	ROUND(13, 1, ecx, eax, edx, edi)
-	ROUND(14, 1, eax, ecx, edi, edx)
-	ROUND(15, 1, ecx, eax, edx, edi)
-	AS2(	cmp		WORD_REG(si), K_END)
-	ASJ(	jne,	1, b)
-
-	AS2(	mov		WORD_REG(dx), DATA_SAVE)
-	AS2(	add		WORD_REG(dx), 64)
-	AS2(	mov		AS_REG_7, STATE_SAVE)
-	AS2(	mov		DATA_SAVE, WORD_REG(dx))
-
-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
-#if CRYPTOPP_BOOL_X86
-	AS2(	test	DWORD PTR DATA_END, 1)
-	ASJ(	jnz,	4, f)
-#endif
-	AS2(	movdqa	xmm1, XMMWORD_PTR [AS_REG_7+1*16])
-	AS2(	movdqa	xmm0, XMMWORD_PTR [AS_REG_7+0*16])
-	AS2(	paddd	xmm1, E(0))
-	AS2(	paddd	xmm0, A(0))
-	AS2(	movdqa	[AS_REG_7+1*16], xmm1)
-	AS2(	movdqa	[AS_REG_7+0*16], xmm0)
-	AS2(	cmp		WORD_REG(dx), DATA_END)
-	ASJ(	jl,		0, b)
-#endif
-
-#if CRYPTOPP_BOOL_X86
-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
-	ASJ(	jmp,	5, f)
-	ASL(4)	// non-SSE2
-#endif
-	AS2(	add		[AS_REG_7+0*4], ecx)	// A
-	AS2(	add		[AS_REG_7+4*4], edi)	// E
-	AS2(	mov		eax, B(0))
-	AS2(	mov		ebx, C(0))
-	AS2(	mov		ecx, D(0))
-	AS2(	add		[AS_REG_7+1*4], eax)
-	AS2(	add		[AS_REG_7+2*4], ebx)
-	AS2(	add		[AS_REG_7+3*4], ecx)
-	AS2(	mov		eax, F(0))
-	AS2(	mov		ebx, G(0))
-	AS2(	mov		ecx, H(0))
-	AS2(	add		[AS_REG_7+5*4], eax)
-	AS2(	add		[AS_REG_7+6*4], ebx)
-	AS2(	add		[AS_REG_7+7*4], ecx)
-	AS2(	mov		ecx, AS_REG_7d)
-	AS2(	cmp		WORD_REG(dx), DATA_END)
-	ASJ(	jl,		2, b)
-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
-	ASL(5)
-#endif
-#endif
-
-	AS_POP_IF86(sp)
-	AS_POP_IF86(bp)
-	#if !defined(_MSC_VER) || (_MSC_VER < 1400)
-		AS_POP_IF86(bx)
-	#endif
-
-#ifdef CRYPTOPP_GENERATE_X64_MASM
-	add		rsp, LOCALS_SIZE+8
-	pop		rbp
-	pop		rbx
-	pop		rdi
-	pop		rsi
-	ret
-	X86_SHA256_HashBlocks ENDP
-#endif
-
-#ifdef __GNUC__
-	".att_syntax prefix;"
-	: 
-	: "c" (state), "d" (data), "S" (SHA256_K+48), "D" (len)
-	#if CRYPTOPP_BOOL_X64
-		, "m" (workspace[0])
-	#endif
-	: "memory", "cc", "%eax"
-	#if CRYPTOPP_BOOL_X64
-		, "%rbx", "%r8"
-	#endif
-	);
-#endif
-}
-
-#endif	// #if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_GENERATE_X64_MASM)
-
-#ifndef CRYPTOPP_GENERATE_X64_MASM
-
-#ifdef CRYPTOPP_X64_MASM_AVAILABLE
-extern "C" {
-void CRYPTOPP_FASTCALL X86_SHA256_HashBlocks(word32 *state, const word32 *data, size_t len);
-}
-#endif
-
-#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_X64_MASM_AVAILABLE)
-
-size_t SHA256::HashMultipleBlocks(const word32 *input, size_t length)
-{
-	X86_SHA256_HashBlocks(m_state, input, (length&(size_t(0)-BLOCKSIZE)) - !HasSSE2());
-	return length % BLOCKSIZE;
-}
-
-size_t SHA224::HashMultipleBlocks(const word32 *input, size_t length)
-{
-	X86_SHA256_HashBlocks(m_state, input, (length&(size_t(0)-BLOCKSIZE)) - !HasSSE2());
-	return length % BLOCKSIZE;
-}
-
-#endif
-
-#define blk2(i) (W[i&15]+=s1(W[(i-2)&15])+W[(i-7)&15]+s0(W[(i-15)&15]))
-
-#define Ch(x,y,z) (z^(x&(y^z)))
-#define Maj(x,y,z) (y^((x^y)&(y^z)))
-
-#define a(i) T[(0-i)&7]
-#define b(i) T[(1-i)&7]
-#define c(i) T[(2-i)&7]
-#define d(i) T[(3-i)&7]
-#define e(i) T[(4-i)&7]
-#define f(i) T[(5-i)&7]
-#define g(i) T[(6-i)&7]
-#define h(i) T[(7-i)&7]
-
-#define R(i) h(i)+=S1(e(i))+Ch(e(i),f(i),g(i))+SHA256_K[i+j]+(j?blk2(i):blk0(i));\
-	d(i)+=h(i);h(i)+=S0(a(i))+Maj(a(i),b(i),c(i))
-
-// for SHA256
-#define S0(x) (rotrFixed(x,2)^rotrFixed(x,13)^rotrFixed(x,22))
-#define S1(x) (rotrFixed(x,6)^rotrFixed(x,11)^rotrFixed(x,25))
-#define s0(x) (rotrFixed(x,7)^rotrFixed(x,18)^(x>>3))
-#define s1(x) (rotrFixed(x,17)^rotrFixed(x,19)^(x>>10))
-
-void SHA256::Transform(word32 *state, const word32 *data)
-{
-	word32 W[16];
-#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_X64_MASM_AVAILABLE)
-	// this byte reverse is a waste of time, but this function is only called by MDC
-	ByteReverse(W, data, BLOCKSIZE);
-	X86_SHA256_HashBlocks(state, W, BLOCKSIZE - !HasSSE2());
-#else
-	word32 T[8];
-    /* Copy context->state[] to working vars */
-	memcpy(T, state, sizeof(T));
-    /* 64 operations, partially loop unrolled */
-	for (unsigned int j=0; j<64; j+=16)
-	{
-		R( 0); R( 1); R( 2); R( 3);
-		R( 4); R( 5); R( 6); R( 7);
-		R( 8); R( 9); R(10); R(11);
-		R(12); R(13); R(14); R(15);
-	}
-    /* Add the working vars back into context.state[] */
-    state[0] += a(0);
-    state[1] += b(0);
-    state[2] += c(0);
-    state[3] += d(0);
-    state[4] += e(0);
-    state[5] += f(0);
-    state[6] += g(0);
-    state[7] += h(0);
-#endif
-}
-
-/* 
-// smaller but slower
-void SHA256::Transform(word32 *state, const word32 *data)
-{
-	word32 T[20];
-	word32 W[32];
-	unsigned int i = 0, j = 0;
-	word32 *t = T+8;
-
-	memcpy(t, state, 8*4);
-	word32 e = t[4], a = t[0];
-
-	do 
-	{
-		word32 w = data[j];
-		W[j] = w;
-		w += SHA256_K[j];
-		w += t[7];
-		w += S1(e);
-		w += Ch(e, t[5], t[6]);
-		e = t[3] + w;
-		t[3] = t[3+8] = e;
-		w += S0(t[0]);
-		a = w + Maj(a, t[1], t[2]);
-		t[-1] = t[7] = a;
-		--t;
-		++j;
-		if (j%8 == 0)
-			t += 8;
-	} while (j<16);
-
-	do
-	{
-		i = j&0xf;
-		word32 w = s1(W[i+16-2]) + s0(W[i+16-15]) + W[i] + W[i+16-7];
-		W[i+16] = W[i] = w;
-		w += SHA256_K[j];
-		w += t[7];
-		w += S1(e);
-		w += Ch(e, t[5], t[6]);
-		e = t[3] + w;
-		t[3] = t[3+8] = e;
-		w += S0(t[0]);
-		a = w + Maj(a, t[1], t[2]);
-		t[-1] = t[7] = a;
-
-		w = s1(W[(i+1)+16-2]) + s0(W[(i+1)+16-15]) + W[(i+1)] + W[(i+1)+16-7];
-		W[(i+1)+16] = W[(i+1)] = w;
-		w += SHA256_K[j+1];
-		w += (t-1)[7];
-		w += S1(e);
-		w += Ch(e, (t-1)[5], (t-1)[6]);
-		e = (t-1)[3] + w;
-		(t-1)[3] = (t-1)[3+8] = e;
-		w += S0((t-1)[0]);
-		a = w + Maj(a, (t-1)[1], (t-1)[2]);
-		(t-1)[-1] = (t-1)[7] = a;
-
-		t-=2;
-		j+=2;
-		if (j%8 == 0)
-			t += 8;
-	} while (j<64);
-
-    state[0] += a;
-    state[1] += t[1];
-    state[2] += t[2];
-    state[3] += t[3];
-    state[4] += e;
-    state[5] += t[5];
-    state[6] += t[6];
-    state[7] += t[7];
-}
-*/
-
-#undef S0
-#undef S1
-#undef s0
-#undef s1
-#undef R
-
-// *************************************************************
-
-void SHA384::InitState(HashWordType *state)
-{
-	static const word64 s[8] = {
-		W64LIT(0xcbbb9d5dc1059ed8), W64LIT(0x629a292a367cd507),
-		W64LIT(0x9159015a3070dd17), W64LIT(0x152fecd8f70e5939),
-		W64LIT(0x67332667ffc00b31), W64LIT(0x8eb44a8768581511),
-		W64LIT(0xdb0c2e0d64f98fa7), W64LIT(0x47b5481dbefa4fa4)};
-	memcpy(state, s, sizeof(s));
-}
-
-void SHA512::InitState(HashWordType *state)
-{
-	static const word64 s[8] = {
-		W64LIT(0x6a09e667f3bcc908), W64LIT(0xbb67ae8584caa73b),
-		W64LIT(0x3c6ef372fe94f82b), W64LIT(0xa54ff53a5f1d36f1),
-		W64LIT(0x510e527fade682d1), W64LIT(0x9b05688c2b3e6c1f),
-		W64LIT(0x1f83d9abfb41bd6b), W64LIT(0x5be0cd19137e2179)};
-	memcpy(state, s, sizeof(s));
-}
-
-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86
-CRYPTOPP_ALIGN_DATA(16) static const word64 SHA512_K[80] CRYPTOPP_SECTION_ALIGN16 = {
-#else
-static const word64 SHA512_K[80] = {
-#endif
-	W64LIT(0x428a2f98d728ae22), W64LIT(0x7137449123ef65cd),
-	W64LIT(0xb5c0fbcfec4d3b2f), W64LIT(0xe9b5dba58189dbbc),
-	W64LIT(0x3956c25bf348b538), W64LIT(0x59f111f1b605d019),
-	W64LIT(0x923f82a4af194f9b), W64LIT(0xab1c5ed5da6d8118),
-	W64LIT(0xd807aa98a3030242), W64LIT(0x12835b0145706fbe),
-	W64LIT(0x243185be4ee4b28c), W64LIT(0x550c7dc3d5ffb4e2),
-	W64LIT(0x72be5d74f27b896f), W64LIT(0x80deb1fe3b1696b1),
-	W64LIT(0x9bdc06a725c71235), W64LIT(0xc19bf174cf692694),
-	W64LIT(0xe49b69c19ef14ad2), W64LIT(0xefbe4786384f25e3),
-	W64LIT(0x0fc19dc68b8cd5b5), W64LIT(0x240ca1cc77ac9c65),
-	W64LIT(0x2de92c6f592b0275), W64LIT(0x4a7484aa6ea6e483),
-	W64LIT(0x5cb0a9dcbd41fbd4), W64LIT(0x76f988da831153b5),
-	W64LIT(0x983e5152ee66dfab), W64LIT(0xa831c66d2db43210),
-	W64LIT(0xb00327c898fb213f), W64LIT(0xbf597fc7beef0ee4),
-	W64LIT(0xc6e00bf33da88fc2), W64LIT(0xd5a79147930aa725),
-	W64LIT(0x06ca6351e003826f), W64LIT(0x142929670a0e6e70),
-	W64LIT(0x27b70a8546d22ffc), W64LIT(0x2e1b21385c26c926),
-	W64LIT(0x4d2c6dfc5ac42aed), W64LIT(0x53380d139d95b3df),
-	W64LIT(0x650a73548baf63de), W64LIT(0x766a0abb3c77b2a8),
-	W64LIT(0x81c2c92e47edaee6), W64LIT(0x92722c851482353b),
-	W64LIT(0xa2bfe8a14cf10364), W64LIT(0xa81a664bbc423001),
-	W64LIT(0xc24b8b70d0f89791), W64LIT(0xc76c51a30654be30),
-	W64LIT(0xd192e819d6ef5218), W64LIT(0xd69906245565a910),
-	W64LIT(0xf40e35855771202a), W64LIT(0x106aa07032bbd1b8),
-	W64LIT(0x19a4c116b8d2d0c8), W64LIT(0x1e376c085141ab53),
-	W64LIT(0x2748774cdf8eeb99), W64LIT(0x34b0bcb5e19b48a8),
-	W64LIT(0x391c0cb3c5c95a63), W64LIT(0x4ed8aa4ae3418acb),
-	W64LIT(0x5b9cca4f7763e373), W64LIT(0x682e6ff3d6b2b8a3),
-	W64LIT(0x748f82ee5defb2fc), W64LIT(0x78a5636f43172f60),
-	W64LIT(0x84c87814a1f0ab72), W64LIT(0x8cc702081a6439ec),
-	W64LIT(0x90befffa23631e28), W64LIT(0xa4506cebde82bde9),
-	W64LIT(0xbef9a3f7b2c67915), W64LIT(0xc67178f2e372532b),
-	W64LIT(0xca273eceea26619c), W64LIT(0xd186b8c721c0c207),
-	W64LIT(0xeada7dd6cde0eb1e), W64LIT(0xf57d4f7fee6ed178),
-	W64LIT(0x06f067aa72176fba), W64LIT(0x0a637dc5a2c898a6),
-	W64LIT(0x113f9804bef90dae), W64LIT(0x1b710b35131c471b),
-	W64LIT(0x28db77f523047d84), W64LIT(0x32caab7b40c72493),
-	W64LIT(0x3c9ebe0a15c9bebc), W64LIT(0x431d67c49c100d4c),
-	W64LIT(0x4cc5d4becb3e42b6), W64LIT(0x597f299cfc657e2a),
-	W64LIT(0x5fcb6fab3ad6faec), W64LIT(0x6c44198c4a475817)
-};
-
-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86
-// put assembly version in separate function, otherwise MSVC 2005 SP1 doesn't generate correct code for the non-assembly version
-CRYPTOPP_NAKED static void CRYPTOPP_FASTCALL SHA512_SSE2_Transform(word64 *state, const word64 *data)
-{
-#ifdef __GNUC__
-	__asm__ __volatile__
-	(
-		".intel_syntax noprefix;"
-	AS1(	push	ebx)
-	AS2(	mov		ebx, eax)
-#else
-	AS1(	push	ebx)
-	AS1(	push	esi)
-	AS1(	push	edi)
-	AS2(	lea		ebx, SHA512_K)
-#endif
-
-	AS2(	mov		eax, esp)
-	AS2(	and		esp, 0xfffffff0)
-	AS2(	sub		esp, 27*16)				// 17*16 for expanded data, 20*8 for state
-	AS1(	push	eax)
-	AS2(	xor		eax, eax)
-	AS2(	lea		edi, [esp+4+8*8])		// start at middle of state buffer. will decrement pointer each round to avoid copying
-	AS2(	lea		esi, [esp+4+20*8+8])	// 16-byte alignment, then add 8
-
-	AS2(	movdqa	xmm0, [ecx+0*16])
-	AS2(	movdq2q	mm4, xmm0)
-	AS2(	movdqa	[edi+0*16], xmm0)
-	AS2(	movdqa	xmm0, [ecx+1*16])
-	AS2(	movdqa	[edi+1*16], xmm0)
-	AS2(	movdqa	xmm0, [ecx+2*16])
-	AS2(	movdq2q	mm5, xmm0)
-	AS2(	movdqa	[edi+2*16], xmm0)
-	AS2(	movdqa	xmm0, [ecx+3*16])
-	AS2(	movdqa	[edi+3*16], xmm0)
-	ASJ(	jmp,	0, f)
-
-#define SSE2_S0_S1(r, a, b, c)	\
-	AS2(	movq	mm6, r)\
-	AS2(	psrlq	r, a)\
-	AS2(	movq	mm7, r)\
-	AS2(	psllq	mm6, 64-c)\
-	AS2(	pxor	mm7, mm6)\
-	AS2(	psrlq	r, b-a)\
-	AS2(	pxor	mm7, r)\
-	AS2(	psllq	mm6, c-b)\
-	AS2(	pxor	mm7, mm6)\
-	AS2(	psrlq	r, c-b)\
-	AS2(	pxor	r, mm7)\
-	AS2(	psllq	mm6, b-a)\
-	AS2(	pxor	r, mm6)
-
-#define SSE2_s0(r, a, b, c)	\
-	AS2(	movdqa	xmm6, r)\
-	AS2(	psrlq	r, a)\
-	AS2(	movdqa	xmm7, r)\
-	AS2(	psllq	xmm6, 64-c)\
-	AS2(	pxor	xmm7, xmm6)\
-	AS2(	psrlq	r, b-a)\
-	AS2(	pxor	xmm7, r)\
-	AS2(	psrlq	r, c-b)\
-	AS2(	pxor	r, xmm7)\
-	AS2(	psllq	xmm6, c-a)\
-	AS2(	pxor	r, xmm6)
-
-#define SSE2_s1(r, a, b, c)	\
-	AS2(	movdqa	xmm6, r)\
-	AS2(	psrlq	r, a)\
-	AS2(	movdqa	xmm7, r)\
-	AS2(	psllq	xmm6, 64-c)\
-	AS2(	pxor	xmm7, xmm6)\
-	AS2(	psrlq	r, b-a)\
-	AS2(	pxor	xmm7, r)\
-	AS2(	psllq	xmm6, c-b)\
-	AS2(	pxor	xmm7, xmm6)\
-	AS2(	psrlq	r, c-b)\
-	AS2(	pxor	r, xmm7)
-
-	ASL(SHA512_Round)
-	// k + w is in mm0, a is in mm4, e is in mm5
-	AS2(	paddq	mm0, [edi+7*8])		// h
-	AS2(	movq	mm2, [edi+5*8])		// f
-	AS2(	movq	mm3, [edi+6*8])		// g
-	AS2(	pxor	mm2, mm3)
-	AS2(	pand	mm2, mm5)
-	SSE2_S0_S1(mm5,14,18,41)
-	AS2(	pxor	mm2, mm3)
-	AS2(	paddq	mm0, mm2)			// h += Ch(e,f,g)
-	AS2(	paddq	mm5, mm0)			// h += S1(e)
-	AS2(	movq	mm2, [edi+1*8])		// b
-	AS2(	movq	mm1, mm2)
-	AS2(	por		mm2, mm4)
-	AS2(	pand	mm2, [edi+2*8])		// c
-	AS2(	pand	mm1, mm4)
-	AS2(	por		mm1, mm2)
-	AS2(	paddq	mm1, mm5)			// temp = h + Maj(a,b,c)
-	AS2(	paddq	mm5, [edi+3*8])		// e = d + h
-	AS2(	movq	[edi+3*8], mm5)
-	AS2(	movq	[edi+11*8], mm5)
-	SSE2_S0_S1(mm4,28,34,39)			// S0(a)
-	AS2(	paddq	mm4, mm1)			// a = temp + S0(a)
-	AS2(	movq	[edi-8], mm4)
-	AS2(	movq	[edi+7*8], mm4)
-	AS1(	ret)
-
-	// first 16 rounds
-	ASL(0)
-	AS2(	movq	mm0, [edx+eax*8])
-	AS2(	movq	[esi+eax*8], mm0)
-	AS2(	movq	[esi+eax*8+16*8], mm0)
-	AS2(	paddq	mm0, [ebx+eax*8])
-	ASC(	call,	SHA512_Round)
-	AS1(	inc		eax)
-	AS2(	sub		edi, 8)
-	AS2(	test	eax, 7)
-	ASJ(	jnz,	0, b)
-	AS2(	add		edi, 8*8)
-	AS2(	cmp		eax, 16)
-	ASJ(	jne,	0, b)
-
-	// rest of the rounds
-	AS2(	movdqu	xmm0, [esi+(16-2)*8])
-	ASL(1)
-	// data expansion, W[i-2] already in xmm0
-	AS2(	movdqu	xmm3, [esi])
-	AS2(	paddq	xmm3, [esi+(16-7)*8])
-	AS2(	movdqa	xmm2, [esi+(16-15)*8])
-	SSE2_s1(xmm0, 6, 19, 61)
-	AS2(	paddq	xmm0, xmm3)
-	SSE2_s0(xmm2, 1, 7, 8)
-	AS2(	paddq	xmm0, xmm2)
-	AS2(	movdq2q	mm0, xmm0)
-	AS2(	movhlps	xmm1, xmm0)
-	AS2(	paddq	mm0, [ebx+eax*8])
-	AS2(	movlps	[esi], xmm0)
-	AS2(	movlps	[esi+8], xmm1)
-	AS2(	movlps	[esi+8*16], xmm0)
-	AS2(	movlps	[esi+8*17], xmm1)
-	// 2 rounds
-	ASC(	call,	SHA512_Round)
-	AS2(	sub		edi, 8)
-	AS2(	movdq2q	mm0, xmm1)
-	AS2(	paddq	mm0, [ebx+eax*8+8])
-	ASC(	call,	SHA512_Round)
-	// update indices and loop
-	AS2(	add		esi, 16)
-	AS2(	add		eax, 2)
-	AS2(	sub		edi, 8)
-	AS2(	test	eax, 7)
-	ASJ(	jnz,	1, b)
-	// do housekeeping every 8 rounds
-	AS2(	mov		esi, 0xf)
-	AS2(	and		esi, eax)
-	AS2(	lea		esi, [esp+4+20*8+8+esi*8])
-	AS2(	add		edi, 8*8)
-	AS2(	cmp		eax, 80)
-	ASJ(	jne,	1, b)
-
-#define SSE2_CombineState(i)	\
-	AS2(	movdqa	xmm0, [edi+i*16])\
-	AS2(	paddq	xmm0, [ecx+i*16])\
-	AS2(	movdqa	[ecx+i*16], xmm0)
-
-	SSE2_CombineState(0)
-	SSE2_CombineState(1)
-	SSE2_CombineState(2)
-	SSE2_CombineState(3)
-
-	AS1(	pop		esp)
-	AS1(	emms)
-
-#if defined(__GNUC__)
-	AS1(	pop		ebx)
-	".att_syntax prefix;"
-		:
-		: "a" (SHA512_K), "c" (state), "d" (data)
-		: "%esi", "%edi", "memory", "cc"
-	);
-#else
-	AS1(	pop		edi)
-	AS1(	pop		esi)
-	AS1(	pop		ebx)
-	AS1(	ret)
-#endif
-}
-#endif	// #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
-
-void SHA512::Transform(word64 *state, const word64 *data)
-{
-#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86
-	if (HasSSE2())
-	{
-		SHA512_SSE2_Transform(state, data);
-		return;
-	}
-#endif
-
-#define S0(x) (rotrFixed(x,28)^rotrFixed(x,34)^rotrFixed(x,39))
-#define S1(x) (rotrFixed(x,14)^rotrFixed(x,18)^rotrFixed(x,41))
-#define s0(x) (rotrFixed(x,1)^rotrFixed(x,8)^(x>>7))
-#define s1(x) (rotrFixed(x,19)^rotrFixed(x,61)^(x>>6))
-
-#define R(i) h(i)+=S1(e(i))+Ch(e(i),f(i),g(i))+SHA512_K[i+j]+(j?blk2(i):blk0(i));\
-	d(i)+=h(i);h(i)+=S0(a(i))+Maj(a(i),b(i),c(i))
-
-	word64 W[16];
-	word64 T[8];
-    /* Copy context->state[] to working vars */
-	memcpy(T, state, sizeof(T));
-    /* 80 operations, partially loop unrolled */
-	for (unsigned int j=0; j<80; j+=16)
-	{
-		R( 0); R( 1); R( 2); R( 3);
-		R( 4); R( 5); R( 6); R( 7);
-		R( 8); R( 9); R(10); R(11);
-		R(12); R(13); R(14); R(15);
-	}
-    /* Add the working vars back into context.state[] */
-    state[0] += a(0);
-    state[1] += b(0);
-    state[2] += c(0);
-    state[3] += d(0);
-    state[4] += e(0);
-    state[5] += f(0);
-    state[6] += g(0);
-    state[7] += h(0);
-}
-
-NAMESPACE_END
-
-#endif	// #ifndef CRYPTOPP_GENERATE_X64_MASM
-#endif	// #ifndef CRYPTOPP_IMPORTS
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/sha.h bitcoin-0.3.20/src/cryptopp/sha.h
--- bitcoin-0.3.20.orig/src/cryptopp/sha.h	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/sha.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-#ifndef CRYPTOPP_SHA_H
-#define CRYPTOPP_SHA_H
-
-#include "iterhash.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-/// <a href="http://www.weidai.com/scan-mirror/md.html#SHA-1">SHA-1</a>
-class CRYPTOPP_DLL SHA1 : public IteratedHashWithStaticTransform<word32, BigEndian, 64, 20, SHA1>
-{
-public:
-	static void CRYPTOPP_API InitState(HashWordType *state);
-	static void CRYPTOPP_API Transform(word32 *digest, const word32 *data);
-	static const char * CRYPTOPP_API StaticAlgorithmName() {return "SHA-1";}
-};
-
-typedef SHA1 SHA;	// for backwards compatibility
-
-//! implements the SHA-256 standard
-class CRYPTOPP_DLL SHA256 : public IteratedHashWithStaticTransform<word32, BigEndian, 64, 32, SHA256, 32, true>
-{
-public:
-#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_X64_MASM_AVAILABLE)
-	size_t HashMultipleBlocks(const word32 *input, size_t length);
-#endif
-	static void CRYPTOPP_API InitState(HashWordType *state);
-	static void CRYPTOPP_API Transform(word32 *digest, const word32 *data);
-	static const char * CRYPTOPP_API StaticAlgorithmName() {return "SHA-256";}
-};
-
-//! implements the SHA-224 standard
-class CRYPTOPP_DLL SHA224 : public IteratedHashWithStaticTransform<word32, BigEndian, 64, 32, SHA224, 28, true>
-{
-public:
-#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_X64_MASM_AVAILABLE)
-	size_t HashMultipleBlocks(const word32 *input, size_t length);
-#endif
-	static void CRYPTOPP_API InitState(HashWordType *state);
-	static void CRYPTOPP_API Transform(word32 *digest, const word32 *data) {SHA256::Transform(digest, data);}
-	static const char * CRYPTOPP_API StaticAlgorithmName() {return "SHA-224";}
-};
-
-//! implements the SHA-512 standard
-class CRYPTOPP_DLL SHA512 : public IteratedHashWithStaticTransform<word64, BigEndian, 128, 64, SHA512, 64, CRYPTOPP_BOOL_X86>
-{
-public:
-	static void CRYPTOPP_API InitState(HashWordType *state);
-	static void CRYPTOPP_API Transform(word64 *digest, const word64 *data);
-	static const char * CRYPTOPP_API StaticAlgorithmName() {return "SHA-512";}
-};
-
-//! implements the SHA-384 standard
-class CRYPTOPP_DLL SHA384 : public IteratedHashWithStaticTransform<word64, BigEndian, 128, 64, SHA384, 48, CRYPTOPP_BOOL_X86>
-{
-public:
-	static void CRYPTOPP_API InitState(HashWordType *state);
-	static void CRYPTOPP_API Transform(word64 *digest, const word64 *data) {SHA512::Transform(digest, data);}
-	static const char * CRYPTOPP_API StaticAlgorithmName() {return "SHA-384";}
-};
-
-NAMESPACE_END
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/simple.h bitcoin-0.3.20/src/cryptopp/simple.h
--- bitcoin-0.3.20.orig/src/cryptopp/simple.h	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/simple.h	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/smartptr.h bitcoin-0.3.20/src/cryptopp/smartptr.h
--- bitcoin-0.3.20.orig/src/cryptopp/smartptr.h	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/smartptr.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,223 +0,0 @@
-#ifndef CRYPTOPP_SMARTPTR_H
-#define CRYPTOPP_SMARTPTR_H
-
-#include "config.h"
-#include <algorithm>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-template <class T> class simple_ptr
-{
-public:
-	simple_ptr() : m_p(NULL) {}
-	~simple_ptr() {delete m_p;}
-	T *m_p;
-};
-
-template <class T> class member_ptr
-{
-public:
-	explicit member_ptr(T *p = NULL) : m_p(p) {}
-
-	~member_ptr();
-
-	const T& operator*() const { return *m_p; }
-	T& operator*() { return *m_p; }
-
-	const T* operator->() const { return m_p; }
-	T* operator->() { return m_p; }
-
-	const T* get() const { return m_p; }
-	T* get() { return m_p; }
-
-	T* release()
-	{
-		T *old_p = m_p;
-		m_p = 0;
-		return old_p;
-	} 
-
-	void reset(T *p = 0);
-
-protected:
-	member_ptr(const member_ptr<T>& rhs);		// copy not allowed
-	void operator=(const member_ptr<T>& rhs);	// assignment not allowed
-
-	T *m_p;
-};
-
-template <class T> member_ptr<T>::~member_ptr() {delete m_p;}
-template <class T> void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}
-
-// ********************************************************
-
-template<class T> class value_ptr : public member_ptr<T>
-{
-public:
-	value_ptr(const T &obj) : member_ptr<T>(new T(obj)) {}
-	value_ptr(T *p = NULL) : member_ptr<T>(p) {}
-	value_ptr(const value_ptr<T>& rhs)
-		: member_ptr<T>(rhs.m_p ? new T(*rhs.m_p) : NULL) {}
-
-	value_ptr<T>& operator=(const value_ptr<T>& rhs);
-	bool operator==(const value_ptr<T>& rhs)
-	{
-		return (!this->m_p && !rhs.m_p) || (this->m_p && rhs.m_p && *this->m_p == *rhs.m_p);
-	}
-};
-
-template <class T> value_ptr<T>& value_ptr<T>::operator=(const value_ptr<T>& rhs)
-{
-	T *old_p = this->m_p;
-	this->m_p = rhs.m_p ? new T(*rhs.m_p) : NULL;
-	delete old_p;
-	return *this;
-}
-
-// ********************************************************
-
-template<class T> class clonable_ptr : public member_ptr<T>
-{
-public:
-	clonable_ptr(const T &obj) : member_ptr<T>(obj.Clone()) {}
-	clonable_ptr(T *p = NULL) : member_ptr<T>(p) {}
-	clonable_ptr(const clonable_ptr<T>& rhs)
-		: member_ptr<T>(rhs.m_p ? rhs.m_p->Clone() : NULL) {}
-
-	clonable_ptr<T>& operator=(const clonable_ptr<T>& rhs);
-};
-
-template <class T> clonable_ptr<T>& clonable_ptr<T>::operator=(const clonable_ptr<T>& rhs)
-{
-	T *old_p = this->m_p;
-	this->m_p = rhs.m_p ? rhs.m_p->Clone() : NULL;
-	delete old_p;
-	return *this;
-}
-
-// ********************************************************
-
-template<class T> class counted_ptr
-{
-public:
-	explicit counted_ptr(T *p = 0);
-	counted_ptr(const T &r) : m_p(0) {attach(r);}
-	counted_ptr(const counted_ptr<T>& rhs);
-
-	~counted_ptr();
-
-	const T& operator*() const { return *m_p; }
-	T& operator*() { return *m_p; }
-
-	const T* operator->() const { return m_p; }
-	T* operator->() { return get(); }
-
-	const T* get() const { return m_p; }
-	T* get();
-
-	void attach(const T &p);
-
-	counted_ptr<T> & operator=(const counted_ptr<T>& rhs);
-
-private:
-	T *m_p;
-};
-
-template <class T> counted_ptr<T>::counted_ptr(T *p)
-	: m_p(p) 
-{
-	if (m_p)
-		m_p->m_referenceCount = 1;
-}
-
-template <class T> counted_ptr<T>::counted_ptr(const counted_ptr<T>& rhs)
-	: m_p(rhs.m_p)
-{
-	if (m_p)
-		m_p->m_referenceCount++;
-}
-
-template <class T> counted_ptr<T>::~counted_ptr()
-{
-	if (m_p && --m_p->m_referenceCount == 0)
-		delete m_p;
-}
-
-template <class T> void counted_ptr<T>::attach(const T &r)
-{
-	if (m_p && --m_p->m_referenceCount == 0)
-		delete m_p;
-	if (r.m_referenceCount == 0)
-	{
-		m_p = r.clone();
-		m_p->m_referenceCount = 1;
-	}
-	else
-	{
-		m_p = const_cast<T *>(&r);
-		m_p->m_referenceCount++;
-	}
-}
-
-template <class T> T* counted_ptr<T>::get()
-{
-	if (m_p && m_p->m_referenceCount > 1)
-	{
-		T *temp = m_p->clone();
-		m_p->m_referenceCount--;
-		m_p = temp;
-		m_p->m_referenceCount = 1;
-	}
-	return m_p;
-}
-
-template <class T> counted_ptr<T> & counted_ptr<T>::operator=(const counted_ptr<T>& rhs)
-{
-	if (m_p != rhs.m_p)
-	{
-		if (m_p && --m_p->m_referenceCount == 0)
-			delete m_p;
-		m_p = rhs.m_p;
-		if (m_p)
-			m_p->m_referenceCount++;
-	}
-	return *this;
-}
-
-// ********************************************************
-
-template <class T> class vector_member_ptrs
-{
-public:
-	vector_member_ptrs(size_t size=0)
-		: m_size(size), m_ptr(new member_ptr<T>[size]) {}
-	~vector_member_ptrs()
-		{delete [] this->m_ptr;}
-
-	member_ptr<T>& operator[](size_t index)
-		{assert(index<this->m_size); return this->m_ptr[index];}
-	const member_ptr<T>& operator[](size_t index) const
-		{assert(index<this->m_size); return this->m_ptr[index];}
-
-	size_t size() const {return this->m_size;}
-	void resize(size_t newSize)
-	{
-		member_ptr<T> *newPtr = new member_ptr<T>[newSize];
-		for (size_t i=0; i<this->m_size && i<newSize; i++)
-			newPtr[i].reset(this->m_ptr[i].release());
-		delete [] this->m_ptr;
-		this->m_size = newSize;
-		this->m_ptr = newPtr;
-	}
-
-private:
-	vector_member_ptrs(const vector_member_ptrs<T> &c);	// copy not allowed
-	void operator=(const vector_member_ptrs<T> &x);		// assignment not allowed
-
-	size_t m_size;
-	member_ptr<T> *m_ptr;
-};
-
-NAMESPACE_END
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/cryptopp/stdcpp.h bitcoin-0.3.20/src/cryptopp/stdcpp.h
--- bitcoin-0.3.20.orig/src/cryptopp/stdcpp.h	2011-02-09 18:50:08.000000000 +0100
+++ bitcoin-0.3.20/src/cryptopp/stdcpp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,27 +0,0 @@
-#ifndef CRYPTOPP_STDCPP_H
-#define CRYPTOPP_STDCPP_H
-
-#include <stddef.h>
-#include <assert.h>
-#include <limits.h>
-#include <memory>
-#include <string>
-#include <exception>
-#include <typeinfo>
-
-
-#ifdef _MSC_VER
-#include <string.h>	// CodeWarrior doesn't have memory.h
-#include <algorithm>
-#include <map>
-#include <vector>
-
-// re-disable this
-#pragma warning(disable: 4231)
-#endif
-
-#if defined(_MSC_VER) && defined(_CRTAPI1)
-#define CRYPTOPP_MSVCRT6
-#endif
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/json/json_spirit_error_position.h bitcoin-0.3.20/src/json/json_spirit_error_position.h
--- bitcoin-0.3.20.orig/src/json/json_spirit_error_position.h	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/json_spirit_error_position.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,54 +0,0 @@
-#ifndef JSON_SPIRIT_ERROR_POSITION
-#define JSON_SPIRIT_ERROR_POSITION
-
-//          Copyright John W. Wilkinson 2007 - 2009.
-// Distributed under the MIT License, see accompanying file LICENSE.txt
-
-// json spirit version 4.03
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-# pragma once
-#endif
-
-#include <string>
-
-namespace json_spirit
-{
-    // An Error_position exception is thrown by the "read_or_throw" functions below on finding an error.
-    // Note the "read_or_throw" functions are around 3 times slower than the standard functions "read" 
-    // functions that return a bool.
-    //
-    struct Error_position
-    {
-        Error_position();
-        Error_position( unsigned int line, unsigned int column, const std::string& reason );
-        bool operator==( const Error_position& lhs ) const;
-        unsigned int line_;
-        unsigned int column_;
-        std::string reason_;
-    };
-
-    inline Error_position::Error_position()
-    :   line_( 0 )
-    ,   column_( 0 )
-    {
-    }
-
-    inline Error_position::Error_position( unsigned int line, unsigned int column, const std::string& reason )
-    :   line_( line )
-    ,   column_( column )
-    ,   reason_( reason )
-    {
-    }
-
-    inline bool Error_position::operator==( const Error_position& lhs ) const
-    {
-        if( this == &lhs ) return true;
-
-        return ( reason_ == lhs.reason_ ) &&
-               ( line_   == lhs.line_ ) &&
-               ( column_ == lhs.column_ ); 
-}
-}
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/json/json_spirit.h bitcoin-0.3.20/src/json/json_spirit.h
--- bitcoin-0.3.20.orig/src/json/json_spirit.h	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/json_spirit.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-#ifndef JSON_SPIRIT
-#define JSON_SPIRIT
-
-//          Copyright John W. Wilkinson 2007 - 2009.
-// Distributed under the MIT License, see accompanying file LICENSE.txt
-
-// json spirit version 4.03
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-# pragma once
-#endif
-
-#include "json_spirit_value.h"
-#include "json_spirit_reader.h"
-#include "json_spirit_writer.h"
-#include "json_spirit_utils.h"
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/json/json_spirit_reader.cpp bitcoin-0.3.20/src/json/json_spirit_reader.cpp
--- bitcoin-0.3.20.orig/src/json/json_spirit_reader.cpp	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/json_spirit_reader.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,137 +0,0 @@
-//          Copyright John W. Wilkinson 2007 - 2009.
-// Distributed under the MIT License, see accompanying file LICENSE.txt
-
-// json spirit version 4.03
-
-#include "json_spirit_reader.h"
-#include "json_spirit_reader_template.h"
-
-using namespace json_spirit;
-
-bool json_spirit::read( const std::string& s, Value& value )
-{
-    return read_string( s, value );
-}
-
-void json_spirit::read_or_throw( const std::string& s, Value& value )
-{
-    read_string_or_throw( s, value );
-}
-
-bool json_spirit::read( std::istream& is, Value& value )
-{
-    return read_stream( is, value );
-}
-
-void json_spirit::read_or_throw( std::istream& is, Value& value )
-{
-    read_stream_or_throw( is, value );
-}
-
-bool json_spirit::read( std::string::const_iterator& begin, std::string::const_iterator end, Value& value )
-{
-    return read_range( begin, end, value );
-}
-
-void json_spirit::read_or_throw( std::string::const_iterator& begin, std::string::const_iterator end, Value& value )
-{
-    begin = read_range_or_throw( begin, end, value );
-}
-
-#ifndef BOOST_NO_STD_WSTRING
-
-bool json_spirit::read( const std::wstring& s, wValue& value )
-{
-    return read_string( s, value );
-}
-
-void json_spirit::read_or_throw( const std::wstring& s, wValue& value )
-{
-    read_string_or_throw( s, value );
-}
-
-bool json_spirit::read( std::wistream& is, wValue& value )
-{
-    return read_stream( is, value );
-}
-
-void json_spirit::read_or_throw( std::wistream& is, wValue& value )
-{
-    read_stream_or_throw( is, value );
-}
-
-bool json_spirit::read( std::wstring::const_iterator& begin, std::wstring::const_iterator end, wValue& value )
-{
-    return read_range( begin, end, value );
-}
-
-void json_spirit::read_or_throw( std::wstring::const_iterator& begin, std::wstring::const_iterator end, wValue& value )
-{
-    begin = read_range_or_throw( begin, end, value );
-}
-
-#endif
-
-bool json_spirit::read( const std::string& s, mValue& value )
-{
-    return read_string( s, value );
-}
-
-void json_spirit::read_or_throw( const std::string& s, mValue& value )
-{
-    read_string_or_throw( s, value );
-}
-
-bool json_spirit::read( std::istream& is, mValue& value )
-{
-    return read_stream( is, value );
-}
-
-void json_spirit::read_or_throw( std::istream& is, mValue& value )
-{
-    read_stream_or_throw( is, value );
-}
-
-bool json_spirit::read( std::string::const_iterator& begin, std::string::const_iterator end, mValue& value )
-{
-    return read_range( begin, end, value );
-}
-
-void json_spirit::read_or_throw( std::string::const_iterator& begin, std::string::const_iterator end, mValue& value )
-{
-    begin = read_range_or_throw( begin, end, value );
-}
-
-#ifndef BOOST_NO_STD_WSTRING
-
-bool json_spirit::read( const std::wstring& s, wmValue& value )
-{
-    return read_string( s, value );
-}
-
-void json_spirit::read_or_throw( const std::wstring& s, wmValue& value )
-{
-    read_string_or_throw( s, value );
-}
-
-bool json_spirit::read( std::wistream& is, wmValue& value )
-{
-    return read_stream( is, value );
-}
-
-void json_spirit::read_or_throw( std::wistream& is, wmValue& value )
-{
-    read_stream_or_throw( is, value );
-}
-
-bool json_spirit::read( std::wstring::const_iterator& begin, std::wstring::const_iterator end, wmValue& value )
-{
-    return read_range( begin, end, value );
-}
-
-void json_spirit::read_or_throw( std::wstring::const_iterator& begin, std::wstring::const_iterator end, wmValue& value )
-{
-    begin = read_range_or_throw( begin, end, value );
-}
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/json/json_spirit_reader.h bitcoin-0.3.20/src/json/json_spirit_reader.h
--- bitcoin-0.3.20.orig/src/json/json_spirit_reader.h	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/json_spirit_reader.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-#ifndef JSON_SPIRIT_READER
-#define JSON_SPIRIT_READER
-
-//          Copyright John W. Wilkinson 2007 - 2009.
-// Distributed under the MIT License, see accompanying file LICENSE.txt
-
-// json spirit version 4.03
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-# pragma once
-#endif
-
-#include "json_spirit_value.h"
-#include "json_spirit_error_position.h"
-#include <iostream>
-
-namespace json_spirit
-{
-    // functions to reads a JSON values
-
-    bool read( const std::string& s, Value& value );
-    bool read( std::istream& is,     Value& value );
-    bool read( std::string::const_iterator& begin, std::string::const_iterator end, Value& value );
-
-    void read_or_throw( const std::string& s, Value& value );  
-    void read_or_throw( std::istream& is,     Value& value );
-    void read_or_throw( std::string::const_iterator& begin, std::string::const_iterator end, Value& value );
-
-#ifndef BOOST_NO_STD_WSTRING
-
-    bool read( const std::wstring& s, wValue& value );
-    bool read( std::wistream&  is,    wValue& value );
-    bool read( std::wstring::const_iterator& begin, std::wstring::const_iterator end, wValue& value );    
-
-    void read_or_throw( const std::wstring& s, wValue& value );
-    void read_or_throw( std::wistream& is,     wValue& value );
-    void read_or_throw( std::wstring::const_iterator& begin, std::wstring::const_iterator end, wValue& value );
-
-#endif
-
-    bool read( const std::string& s, mValue& value );
-    bool read( std::istream& is,     mValue& value );
-    bool read( std::string::const_iterator& begin, std::string::const_iterator end, mValue& value );
-
-    void read_or_throw( const std::string& s, mValue& value );  
-    void read_or_throw( std::istream& is,     mValue& value );
-    void read_or_throw( std::string::const_iterator& begin, std::string::const_iterator end, mValue& value );
-
-#ifndef BOOST_NO_STD_WSTRING
-
-    bool read( const std::wstring& s, wmValue& value );
-    bool read( std::wistream& is,     wmValue& value );
-    bool read( std::wstring::const_iterator& begin, std::wstring::const_iterator end, wmValue& value );    
-
-    void read_or_throw( const std::wstring& s, wmValue& value );
-    void read_or_throw( std::wistream& is,     wmValue& value );
-    void read_or_throw( std::wstring::const_iterator& begin, std::wstring::const_iterator end, wmValue& value );
-
-#endif
-}
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/json/json_spirit_reader_template.h bitcoin-0.3.20/src/json/json_spirit_reader_template.h
--- bitcoin-0.3.20.orig/src/json/json_spirit_reader_template.h	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/json_spirit_reader_template.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,612 +0,0 @@
-#ifndef JSON_SPIRIT_READER_TEMPLATE
-#define JSON_SPIRIT_READER_TEMPLATE
-
-//          Copyright John W. Wilkinson 2007 - 2009.
-// Distributed under the MIT License, see accompanying file LICENSE.txt
-
-// json spirit version 4.03
-
-#include "json_spirit_value.h"
-#include "json_spirit_error_position.h"
-
-//#define BOOST_SPIRIT_THREADSAFE  // uncomment for multithreaded use, requires linking to boost.thread
-
-#include <boost/bind.hpp>
-#include <boost/function.hpp>
-#include <boost/version.hpp>
-
-#if BOOST_VERSION >= 103800
-    #include <boost/spirit/include/classic_core.hpp>
-    #include <boost/spirit/include/classic_confix.hpp>
-    #include <boost/spirit/include/classic_escape_char.hpp>
-    #include <boost/spirit/include/classic_multi_pass.hpp>
-    #include <boost/spirit/include/classic_position_iterator.hpp>
-    #define spirit_namespace boost::spirit::classic
-#else
-    #include <boost/spirit/core.hpp>
-    #include <boost/spirit/utility/confix.hpp>
-    #include <boost/spirit/utility/escape_char.hpp>
-    #include <boost/spirit/iterator/multi_pass.hpp>
-    #include <boost/spirit/iterator/position_iterator.hpp>
-    #define spirit_namespace boost::spirit
-#endif
-
-namespace json_spirit
-{
-    const spirit_namespace::int_parser < boost::int64_t >  int64_p  = spirit_namespace::int_parser < boost::int64_t  >();
-    const spirit_namespace::uint_parser< boost::uint64_t > uint64_p = spirit_namespace::uint_parser< boost::uint64_t >();
-
-    template< class Iter_type >
-    bool is_eq( Iter_type first, Iter_type last, const char* c_str )
-    {
-        for( Iter_type i = first; i != last; ++i, ++c_str )
-        {
-            if( *c_str == 0 ) return false;
-
-            if( *i != *c_str ) return false;
-        }
-
-        return true;
-    }
-
-    template< class Char_type >
-    Char_type hex_to_num( const Char_type c )
-    {
-        if( ( c >= '0' ) && ( c <= '9' ) ) return c - '0';
-        if( ( c >= 'a' ) && ( c <= 'f' ) ) return c - 'a' + 10;
-        if( ( c >= 'A' ) && ( c <= 'F' ) ) return c - 'A' + 10;
-        return 0;
-    }
-
-    template< class Char_type, class Iter_type >
-    Char_type hex_str_to_char( Iter_type& begin )
-    {
-        const Char_type c1( *( ++begin ) );
-        const Char_type c2( *( ++begin ) );
-
-        return ( hex_to_num( c1 ) << 4 ) + hex_to_num( c2 );
-    }       
-
-    template< class Char_type, class Iter_type >
-    Char_type unicode_str_to_char( Iter_type& begin )
-    {
-        const Char_type c1( *( ++begin ) );
-        const Char_type c2( *( ++begin ) );
-        const Char_type c3( *( ++begin ) );
-        const Char_type c4( *( ++begin ) );
-
-        return ( hex_to_num( c1 ) << 12 ) + 
-               ( hex_to_num( c2 ) <<  8 ) + 
-               ( hex_to_num( c3 ) <<  4 ) + 
-               hex_to_num( c4 );
-    }
-
-    template< class String_type >
-    void append_esc_char_and_incr_iter( String_type& s, 
-                                        typename String_type::const_iterator& begin, 
-                                        typename String_type::const_iterator end )
-    {
-        typedef typename String_type::value_type Char_type;
-             
-        const Char_type c2( *begin );
-
-        switch( c2 )
-        {
-            case 't':  s += '\t'; break;
-            case 'b':  s += '\b'; break;
-            case 'f':  s += '\f'; break;
-            case 'n':  s += '\n'; break;
-            case 'r':  s += '\r'; break;
-            case '\\': s += '\\'; break;
-            case '/':  s += '/';  break;
-            case '"':  s += '"';  break;
-            case 'x':  
-            {
-                if( end - begin >= 3 )  //  expecting "xHH..."
-                {
-                    s += hex_str_to_char< Char_type >( begin );  
-                }
-                break;
-            }
-            case 'u':  
-            {
-                if( end - begin >= 5 )  //  expecting "uHHHH..."
-                {
-                    s += unicode_str_to_char< Char_type >( begin );  
-                }
-                break;
-            }
-        }
-    }
-
-    template< class String_type >
-    String_type substitute_esc_chars( typename String_type::const_iterator begin, 
-                                   typename String_type::const_iterator end )
-    {
-        typedef typename String_type::const_iterator Iter_type;
-
-        if( end - begin < 2 ) return String_type( begin, end );
-
-        String_type result;
-        
-        result.reserve( end - begin );
-
-        const Iter_type end_minus_1( end - 1 );
-
-        Iter_type substr_start = begin;
-        Iter_type i = begin;
-
-        for( ; i < end_minus_1; ++i )
-        {
-            if( *i == '\\' )
-            {
-                result.append( substr_start, i );
-
-                ++i;  // skip the '\'
-             
-                append_esc_char_and_incr_iter( result, i, end );
-
-                substr_start = i + 1;
-            }
-        }
-
-        result.append( substr_start, end );
-
-        return result;
-    }
-
-    template< class String_type >
-    String_type get_str_( typename String_type::const_iterator begin, 
-                       typename String_type::const_iterator end )
-    {
-        assert( end - begin >= 2 );
-
-        typedef typename String_type::const_iterator Iter_type;
-
-        Iter_type str_without_quotes( ++begin );
-        Iter_type end_without_quotes( --end );
-
-        return substitute_esc_chars< String_type >( str_without_quotes, end_without_quotes );
-    }
-
-    inline std::string get_str( std::string::const_iterator begin, std::string::const_iterator end )
-    {
-        return get_str_< std::string >( begin, end );
-    }
-
-    inline std::wstring get_str( std::wstring::const_iterator begin, std::wstring::const_iterator end )
-    {
-        return get_str_< std::wstring >( begin, end );
-    }
-    
-    template< class String_type, class Iter_type >
-    String_type get_str( Iter_type begin, Iter_type end )
-    {
-        const String_type tmp( begin, end );  // convert multipass iterators to string iterators
-
-        return get_str( tmp.begin(), tmp.end() );
-    }
-
-    // this class's methods get called by the spirit parse resulting
-    // in the creation of a JSON object or array
-    //
-    // NB Iter_type could be a std::string iterator, wstring iterator, a position iterator or a multipass iterator
-    //
-    template< class Value_type, class Iter_type >
-    class Semantic_actions 
-    {
-    public:
-
-        typedef typename Value_type::Config_type Config_type;
-        typedef typename Config_type::String_type String_type;
-        typedef typename Config_type::Object_type Object_type;
-        typedef typename Config_type::Array_type Array_type;
-        typedef typename String_type::value_type Char_type;
-
-        Semantic_actions( Value_type& value )
-        :   value_( value )
-        ,   current_p_( 0 )
-        {
-        }
-
-        void begin_obj( Char_type c )
-        {
-            assert( c == '{' );
-
-            begin_compound< Object_type >();
-        }
-
-        void end_obj( Char_type c )
-        {
-            assert( c == '}' );
-
-            end_compound();
-        }
-
-        void begin_array( Char_type c )
-        {
-            assert( c == '[' );
-     
-            begin_compound< Array_type >();
-        }
-
-        void end_array( Char_type c )
-        {
-            assert( c == ']' );
-
-            end_compound();
-        }
-
-        void new_name( Iter_type begin, Iter_type end )
-        {
-            assert( current_p_->type() == obj_type );
-
-            name_ = get_str< String_type >( begin, end );
-        }
-
-        void new_str( Iter_type begin, Iter_type end )
-        {
-            add_to_current( get_str< String_type >( begin, end ) );
-        }
-
-        void new_true( Iter_type begin, Iter_type end )
-        {
-            assert( is_eq( begin, end, "true" ) );
-
-            add_to_current( true );
-        }
-
-        void new_false( Iter_type begin, Iter_type end )
-        {
-            assert( is_eq( begin, end, "false" ) );
-
-            add_to_current( false );
-        }
-
-        void new_null( Iter_type begin, Iter_type end )
-        {
-            assert( is_eq( begin, end, "null" ) );
-
-            add_to_current( Value_type() );
-        }
-
-        void new_int( boost::int64_t i )
-        {
-            add_to_current( i );
-        }
-
-        void new_uint64( boost::uint64_t ui )
-        {
-            add_to_current( ui );
-        }
-
-        void new_real( double d )
-        {
-            add_to_current( d );
-        }
-
-    private:
-
-        Semantic_actions& operator=( const Semantic_actions& ); 
-                                    // to prevent "assignment operator could not be generated" warning
-
-        Value_type* add_first( const Value_type& value )
-        {
-            assert( current_p_ == 0 );
-
-            value_ = value;
-            current_p_ = &value_;
-            return current_p_;
-        }
-
-        template< class Array_or_obj >
-        void begin_compound()
-        {
-            if( current_p_ == 0 )
-            {
-                add_first( Array_or_obj() );
-            }
-            else
-            {
-                stack_.push_back( current_p_ );
-
-                Array_or_obj new_array_or_obj;   // avoid copy by building new array or object in place
-
-                current_p_ = add_to_current( new_array_or_obj );
-            }
-        }
-
-        void end_compound()
-        {
-            if( current_p_ != &value_ )
-            {
-                current_p_ = stack_.back();
-                
-                stack_.pop_back();
-            }    
-        }
-
-        Value_type* add_to_current( const Value_type& value )
-        {
-            if( current_p_ == 0 )
-            {
-                return add_first( value );
-            }
-            else if( current_p_->type() == array_type )
-            {
-                current_p_->get_array().push_back( value );
-
-                return &current_p_->get_array().back(); 
-            }
-            
-            assert( current_p_->type() == obj_type );
-
-            return &Config_type::add( current_p_->get_obj(), name_, value );
-        }
-
-        Value_type& value_;             // this is the object or array that is being created
-        Value_type* current_p_;         // the child object or array that is currently being constructed
-
-        std::vector< Value_type* > stack_;   // previous child objects and arrays
-
-        String_type name_;              // of current name/value pair
-    };
-
-    template< typename Iter_type >
-    void throw_error( spirit_namespace::position_iterator< Iter_type > i, const std::string& reason )
-    {
-        throw Error_position( i.get_position().line, i.get_position().column, reason );
-    }
-
-    template< typename Iter_type >
-    void throw_error( Iter_type i, const std::string& reason )
-    {
-       throw reason;
-    }
-
-    // the spirit grammer 
-    //
-    template< class Value_type, class Iter_type >
-    class Json_grammer : public spirit_namespace::grammar< Json_grammer< Value_type, Iter_type > >
-    {
-    public:
-
-        typedef Semantic_actions< Value_type, Iter_type > Semantic_actions_t;
-
-        Json_grammer( Semantic_actions_t& semantic_actions )
-        :   actions_( semantic_actions )
-        {
-        }
-
-        static void throw_not_value( Iter_type begin, Iter_type end )
-        {
-    	    throw_error( begin, "not a value" );
-        }
-
-        static void throw_not_array( Iter_type begin, Iter_type end )
-        {
-    	    throw_error( begin, "not an array" );
-        }
-
-        static void throw_not_object( Iter_type begin, Iter_type end )
-        {
-    	    throw_error( begin, "not an object" );
-        }
-
-        static void throw_not_pair( Iter_type begin, Iter_type end )
-        {
-    	    throw_error( begin, "not a pair" );
-        }
-
-        static void throw_not_colon( Iter_type begin, Iter_type end )
-        {
-    	    throw_error( begin, "no colon in pair" );
-        }
-
-        static void throw_not_string( Iter_type begin, Iter_type end )
-        {
-    	    throw_error( begin, "not a string" );
-        }
-
-        template< typename ScannerT >
-        class definition
-        {
-        public:
-
-            definition( const Json_grammer& self )
-            {
-                using namespace spirit_namespace;
-
-                typedef typename Value_type::String_type::value_type Char_type;
-
-                // first we convert the semantic action class methods to functors with the 
-                // parameter signature expected by spirit
-
-                typedef boost::function< void( Char_type )            > Char_action;
-                typedef boost::function< void( Iter_type, Iter_type ) > Str_action;
-                typedef boost::function< void( double )               > Real_action;
-                typedef boost::function< void( boost::int64_t )       > Int_action;
-                typedef boost::function< void( boost::uint64_t )      > Uint64_action;
-
-                Char_action   begin_obj  ( boost::bind( &Semantic_actions_t::begin_obj,   &self.actions_, _1 ) );
-                Char_action   end_obj    ( boost::bind( &Semantic_actions_t::end_obj,     &self.actions_, _1 ) );
-                Char_action   begin_array( boost::bind( &Semantic_actions_t::begin_array, &self.actions_, _1 ) );
-                Char_action   end_array  ( boost::bind( &Semantic_actions_t::end_array,   &self.actions_, _1 ) );
-                Str_action    new_name   ( boost::bind( &Semantic_actions_t::new_name,    &self.actions_, _1, _2 ) );
-                Str_action    new_str    ( boost::bind( &Semantic_actions_t::new_str,     &self.actions_, _1, _2 ) );
-                Str_action    new_true   ( boost::bind( &Semantic_actions_t::new_true,    &self.actions_, _1, _2 ) );
-                Str_action    new_false  ( boost::bind( &Semantic_actions_t::new_false,   &self.actions_, _1, _2 ) );
-                Str_action    new_null   ( boost::bind( &Semantic_actions_t::new_null,    &self.actions_, _1, _2 ) );
-                Real_action   new_real   ( boost::bind( &Semantic_actions_t::new_real,    &self.actions_, _1 ) );
-                Int_action    new_int    ( boost::bind( &Semantic_actions_t::new_int,     &self.actions_, _1 ) );
-                Uint64_action new_uint64 ( boost::bind( &Semantic_actions_t::new_uint64,  &self.actions_, _1 ) );
-
-                // actual grammer
-
-                json_
-                    = value_ | eps_p[ &throw_not_value ]
-                    ;
-
-                value_
-                    = string_[ new_str ] 
-                    | number_ 
-                    | object_ 
-                    | array_ 
-                    | str_p( "true" ) [ new_true  ] 
-                    | str_p( "false" )[ new_false ] 
-                    | str_p( "null" ) [ new_null  ]
-                    ;
-
-                object_ 
-                    = ch_p('{')[ begin_obj ]
-                    >> !members_
-                    >> ( ch_p('}')[ end_obj ] | eps_p[ &throw_not_object ] )
-                    ;
-
-                members_
-                    = pair_ >> *( ',' >> pair_ )
-                    ;
-
-                pair_
-                    = string_[ new_name ]
-                    >> ( ':' | eps_p[ &throw_not_colon ] )
-                    >> ( value_ | eps_p[ &throw_not_value ] )
-                    ;
-
-                array_
-                    = ch_p('[')[ begin_array ]
-                    >> !elements_
-                    >> ( ch_p(']')[ end_array ] | eps_p[ &throw_not_array ] )
-                    ;
-
-                elements_
-                    = value_ >> *( ',' >> value_ )
-                    ;
-
-                string_ 
-                    = lexeme_d // this causes white space inside a string to be retained
-                      [
-                          confix_p
-                          ( 
-                              '"', 
-                              *lex_escape_ch_p,
-                              '"'
-                          ) 
-                      ]
-                    ;
-
-                number_
-                    = strict_real_p[ new_real   ] 
-                    | int64_p      [ new_int    ]
-                    | uint64_p     [ new_uint64 ]
-                    ;
-            }
-
-            spirit_namespace::rule< ScannerT > json_, object_, members_, pair_, array_, elements_, value_, string_, number_;
-
-            const spirit_namespace::rule< ScannerT >& start() const { return json_; }
-        };
-
-    private:
-
-        Json_grammer& operator=( const Json_grammer& ); // to prevent "assignment operator could not be generated" warning
-
-        Semantic_actions_t& actions_;
-    };
-
-    template< class Iter_type, class Value_type >
-    Iter_type read_range_or_throw( Iter_type begin, Iter_type end, Value_type& value )
-    {
-        Semantic_actions< Value_type, Iter_type > semantic_actions( value );
-     
-        const spirit_namespace::parse_info< Iter_type > info = 
-                            spirit_namespace::parse( begin, end, 
-                                                    Json_grammer< Value_type, Iter_type >( semantic_actions ), 
-                                                    spirit_namespace::space_p );
-
-        if( !info.hit )
-        {
-            assert( false ); // in theory exception should already have been thrown
-            throw_error( info.stop, "error" );
-        }
-
-        return info.stop;
-    }
-
-    template< class Iter_type, class Value_type >
-    void add_posn_iter_and_read_range_or_throw( Iter_type begin, Iter_type end, Value_type& value )
-    {
-        typedef spirit_namespace::position_iterator< Iter_type > Posn_iter_t;
-
-        const Posn_iter_t posn_begin( begin, end );
-        const Posn_iter_t posn_end( end, end );
-     
-        read_range_or_throw( posn_begin, posn_end, value );
-    }
-
-    template< class Iter_type, class Value_type >
-    bool read_range( Iter_type& begin, Iter_type end, Value_type& value )
-    {
-        try
-        {
-            begin = read_range_or_throw( begin, end, value );
-
-            return true;
-        }
-        catch( ... )
-        {
-            return false;
-        }
-    }
-
-    template< class String_type, class Value_type >
-    void read_string_or_throw( const String_type& s, Value_type& value )
-    {
-        add_posn_iter_and_read_range_or_throw( s.begin(), s.end(), value );
-    }
-
-    template< class String_type, class Value_type >
-    bool read_string( const String_type& s, Value_type& value )
-    {
-        typename String_type::const_iterator begin = s.begin();
-
-        return read_range( begin, s.end(), value );
-    }
-
-    template< class Istream_type >
-    struct Multi_pass_iters
-    {
-        typedef typename Istream_type::char_type Char_type;
-        typedef std::istream_iterator< Char_type, Char_type > istream_iter;
-        typedef spirit_namespace::multi_pass< istream_iter > Mp_iter;
-
-        Multi_pass_iters( Istream_type& is )
-        {
-            is.unsetf( std::ios::skipws );
-
-            begin_ = spirit_namespace::make_multi_pass( istream_iter( is ) );
-            end_   = spirit_namespace::make_multi_pass( istream_iter() );
-        }
-
-        Mp_iter begin_;
-        Mp_iter end_;
-    };
-
-    template< class Istream_type, class Value_type >
-    bool read_stream( Istream_type& is, Value_type& value )
-    {
-        Multi_pass_iters< Istream_type > mp_iters( is );
-
-        return read_range( mp_iters.begin_, mp_iters.end_, value );
-    }
-
-    template< class Istream_type, class Value_type >
-    void read_stream_or_throw( Istream_type& is, Value_type& value )
-    {
-        const Multi_pass_iters< Istream_type > mp_iters( is );
-
-        add_posn_iter_and_read_range_or_throw( mp_iters.begin_, mp_iters.end_, value );
-    }
-}
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/json/json_spirit_stream_reader.h bitcoin-0.3.20/src/json/json_spirit_stream_reader.h
--- bitcoin-0.3.20.orig/src/json/json_spirit_stream_reader.h	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/json_spirit_stream_reader.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
-#ifndef JSON_SPIRIT_READ_STREAM
-#define JSON_SPIRIT_READ_STREAM
-
-//          Copyright John W. Wilkinson 2007 - 2009.
-// Distributed under the MIT License, see accompanying file LICENSE.txt
-
-// json spirit version 4.03
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-# pragma once
-#endif
-
-#include "json_spirit_reader_template.h"
-
-namespace json_spirit
-{
-    // these classes allows you to read multiple top level contiguous values from a stream,
-    // the normal stream read functions have a bug that prevent multiple top level values 
-    // from being read unless they are separated by spaces
-
-    template< class Istream_type, class Value_type >
-    class Stream_reader
-    {
-    public:
-
-        Stream_reader( Istream_type& is )
-        :   iters_( is )
-        {
-        }
-
-        bool read_next( Value_type& value )
-        {
-            return read_range( iters_.begin_, iters_.end_, value );
-        }
-
-    private:
-
-        typedef Multi_pass_iters< Istream_type > Mp_iters;
-
-        Mp_iters iters_;
-    };
-
-    template< class Istream_type, class Value_type >
-    class Stream_reader_thrower
-    {
-    public:
-
-        Stream_reader_thrower( Istream_type& is )
-        :   iters_( is )
-        ,    posn_begin_( iters_.begin_, iters_.end_ )
-        ,    posn_end_( iters_.end_, iters_.end_ )
-        {
-        }
-
-        void read_next( Value_type& value )
-        {
-            posn_begin_ = read_range_or_throw( posn_begin_, posn_end_, value );
-        }
-
-    private:
-
-        typedef Multi_pass_iters< Istream_type > Mp_iters;
-        typedef spirit_namespace::position_iterator< typename Mp_iters::Mp_iter > Posn_iter_t;
-
-        Mp_iters iters_;
-        Posn_iter_t posn_begin_, posn_end_;
-    };
-}
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/json/json_spirit_utils.h bitcoin-0.3.20/src/json/json_spirit_utils.h
--- bitcoin-0.3.20.orig/src/json/json_spirit_utils.h	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/json_spirit_utils.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-#ifndef JSON_SPIRIT_UTILS
-#define JSON_SPIRIT_UTILS
-
-//          Copyright John W. Wilkinson 2007 - 2009.
-// Distributed under the MIT License, see accompanying file LICENSE.txt
-
-// json spirit version 4.03
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-# pragma once
-#endif
-
-#include "json_spirit_value.h"
-#include <map>
-
-namespace json_spirit
-{ 
-    template< class Obj_t, class Map_t >
-    void obj_to_map( const Obj_t& obj, Map_t& mp_obj )
-    {
-        mp_obj.clear();
-
-        for( typename Obj_t::const_iterator i = obj.begin(); i != obj.end(); ++i )
-        {
-            mp_obj[ i->name_ ] = i->value_;
-        }
-    }
-
-    template< class Obj_t, class Map_t >
-    void map_to_obj( const Map_t& mp_obj, Obj_t& obj )
-    {
-        obj.clear();
-
-        for( typename Map_t::const_iterator i = mp_obj.begin(); i != mp_obj.end(); ++i )
-        {
-            obj.push_back( typename Obj_t::value_type( i->first, i->second ) );
-        }
-    }
-
-    typedef std::map< std::string, Value > Mapped_obj;
-
-#ifndef BOOST_NO_STD_WSTRING
-    typedef std::map< std::wstring, wValue > wMapped_obj;
-#endif
-
-    template< class Object_type, class String_type >
-    const typename Object_type::value_type::Value_type& find_value( const Object_type& obj, const String_type& name )
-    {
-        for( typename Object_type::const_iterator i = obj.begin(); i != obj.end(); ++i )
-        {
-            if( i->name_ == name )
-            {
-                return i->value_;
-            }
-        }
-
-        return Object_type::value_type::Value_type::null;
-    }
-}
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/json/json_spirit_value.cpp bitcoin-0.3.20/src/json/json_spirit_value.cpp
--- bitcoin-0.3.20.orig/src/json/json_spirit_value.cpp	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/json_spirit_value.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-/* Copyright (c) 2007 John W Wilkinson
-
-   This source code can be used for any purpose as long as
-   this comment is retained. */
-
-// json spirit version 2.00
-
-#include "json_spirit_value.h"
diff -Naur bitcoin-0.3.20.orig/src/json/json_spirit_value.h bitcoin-0.3.20/src/json/json_spirit_value.h
--- bitcoin-0.3.20.orig/src/json/json_spirit_value.h	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/json_spirit_value.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,534 +0,0 @@
-#ifndef JSON_SPIRIT_VALUE
-#define JSON_SPIRIT_VALUE
-
-//          Copyright John W. Wilkinson 2007 - 2009.
-// Distributed under the MIT License, see accompanying file LICENSE.txt
-
-// json spirit version 4.03
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-# pragma once
-#endif
-
-#include <vector>
-#include <map>
-#include <string>
-#include <cassert>
-#include <sstream>
-#include <stdexcept>
-#include <boost/config.hpp> 
-#include <boost/cstdint.hpp> 
-#include <boost/shared_ptr.hpp> 
-#include <boost/variant.hpp> 
-
-namespace json_spirit
-{
-    enum Value_type{ obj_type, array_type, str_type, bool_type, int_type, real_type, null_type };
-    static const char* Value_type_name[]={"obj", "array", "str", "bool", "int", "real", "null"};
-
-    template< class Config >    // Config determines whether the value uses std::string or std::wstring and
-                                // whether JSON Objects are represented as vectors or maps
-    class Value_impl
-    {
-    public:
-
-        typedef Config Config_type;
-        typedef typename Config::String_type String_type;
-        typedef typename Config::Object_type Object;
-        typedef typename Config::Array_type Array;
-        typedef typename String_type::const_pointer Const_str_ptr;  // eg const char*
-
-        Value_impl();  // creates null value
-        Value_impl( Const_str_ptr      value ); 
-        Value_impl( const String_type& value );
-        Value_impl( const Object&      value );
-        Value_impl( const Array&       value );
-        Value_impl( bool               value );
-        Value_impl( int                value );
-        Value_impl( boost::int64_t     value );
-        Value_impl( boost::uint64_t    value );
-        Value_impl( double             value );
-
-        Value_impl( const Value_impl& other );
-
-        bool operator==( const Value_impl& lhs ) const;
-
-        Value_impl& operator=( const Value_impl& lhs );
-
-        Value_type type() const;
-
-        bool is_uint64() const;
-        bool is_null() const;
-
-        const String_type& get_str()    const;
-        const Object&      get_obj()    const;
-        const Array&       get_array()  const;
-        bool               get_bool()   const;
-        int                get_int()    const;
-        boost::int64_t     get_int64()  const;
-        boost::uint64_t    get_uint64() const;
-        double             get_real()   const;
-
-        Object& get_obj();
-        Array&  get_array();
-
-        template< typename T > T get_value() const;  // example usage: int    i = value.get_value< int >();
-                                                     // or             double d = value.get_value< double >();
-
-        static const Value_impl null;
-
-    private:
-
-        void check_type( const Value_type vtype ) const;
-
-        typedef boost::variant< String_type, 
-                                boost::recursive_wrapper< Object >, boost::recursive_wrapper< Array >, 
-                                bool, boost::int64_t, double > Variant;
-
-        Value_type type_;
-        Variant v_;
-        bool is_uint64_;
-    };
-
-    // vector objects
-
-    template< class Config >
-    struct Pair_impl
-    {
-        typedef typename Config::String_type String_type;
-        typedef typename Config::Value_type Value_type;
-
-        Pair_impl( const String_type& name, const Value_type& value );
-
-        bool operator==( const Pair_impl& lhs ) const;
-
-        String_type name_;
-        Value_type value_;
-    };
-
-    template< class String >
-    struct Config_vector
-    {
-        typedef String String_type;
-        typedef Value_impl< Config_vector > Value_type;
-        typedef Pair_impl < Config_vector > Pair_type;
-        typedef std::vector< Value_type > Array_type;
-        typedef std::vector< Pair_type > Object_type;
-
-        static Value_type& add( Object_type& obj, const String_type& name, const Value_type& value )
-        {
-            obj.push_back( Pair_type( name , value ) );
-
-            return obj.back().value_;
-        }
-                
-        static String_type get_name( const Pair_type& pair )
-        {
-            return pair.name_;
-        }
-                
-        static Value_type get_value( const Pair_type& pair )
-        {
-            return pair.value_;
-        }
-    };
-
-    // typedefs for ASCII
-
-    typedef Config_vector< std::string > Config;
-
-    typedef Config::Value_type  Value;
-    typedef Config::Pair_type   Pair;
-    typedef Config::Object_type Object;
-    typedef Config::Array_type  Array;
-
-    // typedefs for Unicode
-
-#ifndef BOOST_NO_STD_WSTRING
-
-    typedef Config_vector< std::wstring > wConfig;
-
-    typedef wConfig::Value_type  wValue;
-    typedef wConfig::Pair_type   wPair;
-    typedef wConfig::Object_type wObject;
-    typedef wConfig::Array_type  wArray;
-#endif
-
-    // map objects
-
-    template< class String >
-    struct Config_map
-    {
-        typedef String String_type;
-        typedef Value_impl< Config_map > Value_type;
-        typedef std::vector< Value_type > Array_type;
-        typedef std::map< String_type, Value_type > Object_type;
-        typedef typename Object_type::value_type Pair_type;
-
-        static Value_type& add( Object_type& obj, const String_type& name, const Value_type& value )
-        {
-            return obj[ name ] = value;
-        }
-                
-        static String_type get_name( const Pair_type& pair )
-        {
-            return pair.first;
-        }
-                
-        static Value_type get_value( const Pair_type& pair )
-        {
-            return pair.second;
-        }
-    };
-
-    // typedefs for ASCII
-
-    typedef Config_map< std::string > mConfig;
-
-    typedef mConfig::Value_type  mValue;
-    typedef mConfig::Object_type mObject;
-    typedef mConfig::Array_type  mArray;
-
-    // typedefs for Unicode
-
-#ifndef BOOST_NO_STD_WSTRING
-
-    typedef Config_map< std::wstring > wmConfig;
-
-    typedef wmConfig::Value_type  wmValue;
-    typedef wmConfig::Object_type wmObject;
-    typedef wmConfig::Array_type  wmArray;
-
-#endif
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-    //
-    // implementation
-
-    template< class Config >
-    const Value_impl< Config > Value_impl< Config >::null;
-
-    template< class Config >
-    Value_impl< Config >::Value_impl()
-    :   type_( null_type )
-    ,   is_uint64_( false )
-    {
-    }
-
-    template< class Config >
-    Value_impl< Config >::Value_impl( const Const_str_ptr value )
-    :   type_( str_type )
-    ,   v_( String_type( value ) )
-    ,   is_uint64_( false )
-    {
-    }
-
-    template< class Config >
-    Value_impl< Config >::Value_impl( const String_type& value )
-    :   type_( str_type )
-    ,   v_( value )
-    ,   is_uint64_( false )
-    {
-    }
-
-    template< class Config >
-    Value_impl< Config >::Value_impl( const Object& value )
-    :   type_( obj_type )
-    ,   v_( value )
-    ,   is_uint64_( false )
-    {
-    }
-
-    template< class Config >
-    Value_impl< Config >::Value_impl( const Array& value )
-    :   type_( array_type )
-    ,   v_( value )
-    ,   is_uint64_( false )
-    {
-    }
-
-    template< class Config >
-    Value_impl< Config >::Value_impl( bool value )
-    :   type_( bool_type )
-    ,   v_( value )
-    ,   is_uint64_( false )
-    {
-    }
-
-    template< class Config >
-    Value_impl< Config >::Value_impl( int value )
-    :   type_( int_type )
-    ,   v_( static_cast< boost::int64_t >( value ) )
-    ,   is_uint64_( false )
-    {
-    }
-
-    template< class Config >
-    Value_impl< Config >::Value_impl( boost::int64_t value )
-    :   type_( int_type )
-    ,   v_( value )
-    ,   is_uint64_( false )
-    {
-    }
-
-    template< class Config >
-    Value_impl< Config >::Value_impl( boost::uint64_t value )
-    :   type_( int_type )
-    ,   v_( static_cast< boost::int64_t >( value ) )
-    ,   is_uint64_( true )
-    {
-    }
-
-    template< class Config >
-    Value_impl< Config >::Value_impl( double value )
-    :   type_( real_type )
-    ,   v_( value )
-    ,   is_uint64_( false )
-    {
-    }
-
-    template< class Config >
-    Value_impl< Config >::Value_impl( const Value_impl< Config >& other )
-    :   type_( other.type() )
-    ,   v_( other.v_ )
-    ,   is_uint64_( other.is_uint64_ )
-    {
-    }
-
-    template< class Config >
-    Value_impl< Config >& Value_impl< Config >::operator=( const Value_impl& lhs )
-    {
-        Value_impl tmp( lhs );
-
-        std::swap( type_, tmp.type_ );
-        std::swap( v_, tmp.v_ );
-        std::swap( is_uint64_, tmp.is_uint64_ );
-
-        return *this;
-    }
-
-    template< class Config >
-    bool Value_impl< Config >::operator==( const Value_impl& lhs ) const
-    {
-        if( this == &lhs ) return true;
-
-        if( type() != lhs.type() ) return false;
-
-        return v_ == lhs.v_; 
-    }
-
-    template< class Config >
-    Value_type Value_impl< Config >::type() const
-    {
-        return type_;
-    }
-
-    template< class Config >
-    bool Value_impl< Config >::is_uint64() const
-    {
-        return is_uint64_;
-    }
-
-    template< class Config >
-    bool Value_impl< Config >::is_null() const
-    {
-        return type() == null_type;
-    }
-
-    template< class Config >
-    void Value_impl< Config >::check_type( const Value_type vtype ) const
-    {
-        if( type() != vtype ) 
-        {
-            std::ostringstream os;
-
-            ///// Bitcoin: Tell the types by name instead of by number
-            os << "value is type " << Value_type_name[type()] << ", expected " << Value_type_name[vtype];
-
-            throw std::runtime_error( os.str() );
-        }
-    }
-
-    template< class Config >
-    const typename Config::String_type& Value_impl< Config >::get_str() const
-    {
-        check_type(  str_type );
-
-        return *boost::get< String_type >( &v_ );
-    }
-
-    template< class Config >
-    const typename Value_impl< Config >::Object& Value_impl< Config >::get_obj() const
-    {
-        check_type( obj_type );
-
-        return *boost::get< Object >( &v_ );
-    }
-     
-    template< class Config >
-    const typename Value_impl< Config >::Array& Value_impl< Config >::get_array() const
-    {
-        check_type(  array_type );
-
-        return *boost::get< Array >( &v_ );
-    }
-     
-    template< class Config >
-    bool Value_impl< Config >::get_bool() const
-    {
-        check_type(  bool_type );
-
-        return boost::get< bool >( v_ );
-    }
-     
-    template< class Config >
-    int Value_impl< Config >::get_int() const
-    {
-        check_type(  int_type );
-
-        return static_cast< int >( get_int64() );
-    }
-    
-    template< class Config >
-    boost::int64_t Value_impl< Config >::get_int64() const
-    {
-        check_type(  int_type );
-
-        return boost::get< boost::int64_t >( v_ );
-    }
-    
-    template< class Config >
-    boost::uint64_t Value_impl< Config >::get_uint64() const
-    {
-        check_type(  int_type );
-
-        return static_cast< boost::uint64_t >( get_int64() );
-    }
-
-    template< class Config >
-    double Value_impl< Config >::get_real() const
-    {
-        if( type() == int_type )
-        {
-            return is_uint64() ? static_cast< double >( get_uint64() )
-                               : static_cast< double >( get_int64() );
-        }
-
-        check_type(  real_type );
-
-        return boost::get< double >( v_ );
-    }
-
-    template< class Config >
-    typename Value_impl< Config >::Object& Value_impl< Config >::get_obj()
-    {
-        check_type(  obj_type );
-
-        return *boost::get< Object >( &v_ );
-    }
-
-    template< class Config >
-    typename Value_impl< Config >::Array& Value_impl< Config >::get_array()
-    {
-        check_type(  array_type );
-
-        return *boost::get< Array >( &v_ );
-    }
-
-    template< class Config >
-    Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )
-    :   name_( name )
-    ,   value_( value )
-    {
-    }
-
-    template< class Config >
-    bool Pair_impl< Config >::operator==( const Pair_impl< Config >& lhs ) const
-    {
-        if( this == &lhs ) return true;
-
-        return ( name_ == lhs.name_ ) && ( value_ == lhs.value_ );
-    }
-
-    // converts a C string, ie. 8 bit char array, to a string object
-    //
-    template < class String_type >
-    String_type to_str( const char* c_str )
-    {
-        String_type result;
-
-        for( const char* p = c_str; *p != 0; ++p )
-        {
-            result += *p;
-        }
-
-        return result;
-    }
-
-    //
-
-    namespace internal_
-    {
-        template< typename T >
-        struct Type_to_type
-        {
-        };
-
-        template< class Value > 
-        int get_value( const Value& value, Type_to_type< int > )
-        {
-            return value.get_int();
-        }
-       
-        template< class Value > 
-        boost::int64_t get_value( const Value& value, Type_to_type< boost::int64_t > )
-        {
-            return value.get_int64();
-        }
-       
-        template< class Value > 
-        boost::uint64_t get_value( const Value& value, Type_to_type< boost::uint64_t > )
-        {
-            return value.get_uint64();
-        }
-       
-        template< class Value > 
-        double get_value( const Value& value, Type_to_type< double > )
-        {
-            return value.get_real();
-        }
-       
-        template< class Value > 
-        typename Value::String_type get_value( const Value& value, Type_to_type< typename Value::String_type > )
-        {
-            return value.get_str();
-        }
-       
-        template< class Value > 
-        typename Value::Array get_value( const Value& value, Type_to_type< typename Value::Array > )
-        {
-            return value.get_array();
-        }
-       
-        template< class Value > 
-        typename Value::Object get_value( const Value& value, Type_to_type< typename Value::Object > )
-        {
-            return value.get_obj();
-        }
-       
-        template< class Value > 
-        bool get_value( const Value& value, Type_to_type< bool > )
-        {
-            return value.get_bool();
-        }
-    }
-
-    template< class Config >
-    template< typename T > 
-    T Value_impl< Config >::get_value() const
-    {
-        return internal_::get_value( *this, internal_::Type_to_type< T >() );
-    }
-}
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/json/json_spirit_writer.cpp bitcoin-0.3.20/src/json/json_spirit_writer.cpp
--- bitcoin-0.3.20.orig/src/json/json_spirit_writer.cpp	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/json_spirit_writer.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,95 +0,0 @@
-//          Copyright John W. Wilkinson 2007 - 2009.
-// Distributed under the MIT License, see accompanying file LICENSE.txt
-
-// json spirit version 4.03
-
-#include "json_spirit_writer.h"
-#include "json_spirit_writer_template.h"
-
-void json_spirit::write( const Value& value, std::ostream& os )
-{
-    write_stream( value, os, false );
-}
-
-void json_spirit::write_formatted( const Value& value, std::ostream& os )
-{
-    write_stream( value, os, true );
-}
-
-std::string json_spirit::write( const Value& value )
-{
-    return write_string( value, false );
-}
-
-std::string json_spirit::write_formatted( const Value& value )
-{
-    return write_string( value, true );
-}
-
-#ifndef BOOST_NO_STD_WSTRING
-
-void json_spirit::write( const wValue& value, std::wostream& os )
-{
-    write_stream( value, os, false );
-}
-
-void json_spirit::write_formatted( const wValue& value, std::wostream& os )
-{
-    write_stream( value, os, true );
-}
-
-std::wstring json_spirit::write( const wValue&  value )
-{
-    return write_string( value, false );
-}
-
-std::wstring json_spirit::write_formatted( const wValue&  value )
-{
-    return write_string( value, true );
-}
-
-#endif
-
-void json_spirit::write( const mValue& value, std::ostream& os )
-{
-    write_stream( value, os, false );
-}
-
-void json_spirit::write_formatted( const mValue& value, std::ostream& os )
-{
-    write_stream( value, os, true );
-}
-
-std::string json_spirit::write( const mValue& value )
-{
-    return write_string( value, false );
-}
-
-std::string json_spirit::write_formatted( const mValue& value )
-{
-    return write_string( value, true );
-}
-
-#ifndef BOOST_NO_STD_WSTRING
-
-void json_spirit::write( const wmValue& value, std::wostream& os )
-{
-    write_stream( value, os, false );
-}
-
-void json_spirit::write_formatted( const wmValue& value, std::wostream& os )
-{
-    write_stream( value, os, true );
-}
-
-std::wstring json_spirit::write( const wmValue&  value )
-{
-    return write_string( value, false );
-}
-
-std::wstring json_spirit::write_formatted( const wmValue&  value )
-{
-    return write_string( value, true );
-}
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/json/json_spirit_writer.h bitcoin-0.3.20/src/json/json_spirit_writer.h
--- bitcoin-0.3.20.orig/src/json/json_spirit_writer.h	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/json_spirit_writer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-#ifndef JSON_SPIRIT_WRITER
-#define JSON_SPIRIT_WRITER
-
-//          Copyright John W. Wilkinson 2007 - 2009.
-// Distributed under the MIT License, see accompanying file LICENSE.txt
-
-// json spirit version 4.03
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-# pragma once
-#endif
-
-#include "json_spirit_value.h"
-#include <iostream>
-
-namespace json_spirit
-{
-    // functions to convert JSON Values to text, 
-    // the "formatted" versions add whitespace to format the output nicely
-
-    void         write          ( const Value& value, std::ostream&  os );
-    void         write_formatted( const Value& value, std::ostream&  os );
-    std::string  write          ( const Value& value );
-    std::string  write_formatted( const Value& value );
-
-#ifndef BOOST_NO_STD_WSTRING
-
-    void         write          ( const wValue& value, std::wostream& os );
-    void         write_formatted( const wValue& value, std::wostream& os );
-    std::wstring write          ( const wValue& value );
-    std::wstring write_formatted( const wValue& value );
-
-#endif
-
-    void         write          ( const mValue& value, std::ostream&  os );
-    void         write_formatted( const mValue& value, std::ostream&  os );
-    std::string  write          ( const mValue& value );
-    std::string  write_formatted( const mValue& value );
-
-#ifndef BOOST_NO_STD_WSTRING
-
-    void         write          ( const wmValue& value, std::wostream& os );
-    void         write_formatted( const wmValue& value, std::wostream& os );
-    std::wstring write          ( const wmValue& value );
-    std::wstring write_formatted( const wmValue& value );
-
-#endif
-}
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/json/json_spirit_writer_template.h bitcoin-0.3.20/src/json/json_spirit_writer_template.h
--- bitcoin-0.3.20.orig/src/json/json_spirit_writer_template.h	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/json_spirit_writer_template.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,248 +0,0 @@
-#ifndef JSON_SPIRIT_WRITER_TEMPLATE
-#define JSON_SPIRIT_WRITER_TEMPLATE
-
-//          Copyright John W. Wilkinson 2007 - 2009.
-// Distributed under the MIT License, see accompanying file LICENSE.txt
-
-// json spirit version 4.03
-
-#include "json_spirit_value.h"
-
-#include <cassert>
-#include <sstream>
-#include <iomanip>
-
-namespace json_spirit
-{
-    inline char to_hex_char( unsigned int c )
-    {
-        assert( c <= 0xF );
-
-        const char ch = static_cast< char >( c );
-
-        if( ch < 10 ) return '0' + ch;
-
-        return 'A' - 10 + ch;
-    }
-
-    template< class String_type >
-    String_type non_printable_to_string( unsigned int c )
-    {
-        typedef typename String_type::value_type Char_type;
-
-        String_type result( 6, '\\' );
-
-        result[1] = 'u';
-
-        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;
-        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;
-        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;
-        result[ 2 ] = to_hex_char( c & 0x000F );
-
-        return result;
-    }
-
-    template< typename Char_type, class String_type >
-    bool add_esc_char( Char_type c, String_type& s )
-    {
-        switch( c )
-        {
-            case '"':  s += to_str< String_type >( "\\\"" ); return true;
-            case '\\': s += to_str< String_type >( "\\\\" ); return true;
-            case '\b': s += to_str< String_type >( "\\b"  ); return true;
-            case '\f': s += to_str< String_type >( "\\f"  ); return true;
-            case '\n': s += to_str< String_type >( "\\n"  ); return true;
-            case '\r': s += to_str< String_type >( "\\r"  ); return true;
-            case '\t': s += to_str< String_type >( "\\t"  ); return true;
-        }
-
-        return false;
-    }
-
-    template< class String_type >
-    String_type add_esc_chars( const String_type& s )
-    {
-        typedef typename String_type::const_iterator Iter_type;
-        typedef typename String_type::value_type     Char_type;
-
-        String_type result;
-
-        const Iter_type end( s.end() );
-
-        for( Iter_type i = s.begin(); i != end; ++i )
-        {
-            const Char_type c( *i );
-
-            if( add_esc_char( c, result ) ) continue;
-
-            const wint_t unsigned_c( ( c >= 0 ) ? c : 256 + c );
-
-            if( iswprint( unsigned_c ) )
-            {
-                result += c;
-            }
-            else
-            {
-                result += non_printable_to_string< String_type >( unsigned_c );
-            }
-        }
-
-        return result;
-    }
-
-    // this class generates the JSON text,
-    // it keeps track of the indentation level etc.
-    //
-    template< class Value_type, class Ostream_type >
-    class Generator
-    {
-        typedef typename Value_type::Config_type Config_type;
-        typedef typename Config_type::String_type String_type;
-        typedef typename Config_type::Object_type Object_type;
-        typedef typename Config_type::Array_type Array_type;
-        typedef typename String_type::value_type Char_type;
-        typedef typename Object_type::value_type Obj_member_type;
-
-    public:
-
-        Generator( const Value_type& value, Ostream_type& os, bool pretty )
-        :   os_( os )
-        ,   indentation_level_( 0 )
-        ,   pretty_( pretty )
-        {
-            output( value );
-        }
-
-    private:
-
-        void output( const Value_type& value )
-        {
-            switch( value.type() )
-            {
-                case obj_type:   output( value.get_obj() );   break;
-                case array_type: output( value.get_array() ); break;
-                case str_type:   output( value.get_str() );   break;
-                case bool_type:  output( value.get_bool() );  break;
-                case int_type:   output_int( value );         break;
-
-                /// Bitcoin: Added std::fixed and changed precision from 16 to 8
-                case real_type:  os_ << std::showpoint << std::fixed << std::setprecision(8)
-                                     << value.get_real();     break;
-
-                case null_type:  os_ << "null";               break;
-                default: assert( false );
-            }
-        }
-
-        void output( const Object_type& obj )
-        {
-            output_array_or_obj( obj, '{', '}' );
-        }
-
-        void output( const Array_type& arr )
-        {
-            output_array_or_obj( arr, '[', ']' );
-        }
-
-        void output( const Obj_member_type& member )
-        {
-            output( Config_type::get_name( member ) ); space(); 
-            os_ << ':'; space(); 
-            output( Config_type::get_value( member ) );
-        }
-
-        void output_int( const Value_type& value )
-        {
-            if( value.is_uint64() )
-            {
-                os_ << value.get_uint64();
-            }
-            else
-            {
-               os_ << value.get_int64();
-            }
-        }
-
-        void output( const String_type& s )
-        {
-            os_ << '"' << add_esc_chars( s ) << '"';
-        }
-
-        void output( bool b )
-        {
-            os_ << to_str< String_type >( b ? "true" : "false" );
-        }
-
-        template< class T >
-        void output_array_or_obj( const T& t, Char_type start_char, Char_type end_char )
-        {
-            os_ << start_char; new_line();
-
-            ++indentation_level_;
-            
-            for( typename T::const_iterator i = t.begin(); i != t.end(); ++i )
-            {
-                indent(); output( *i );
-
-                typename T::const_iterator next = i;
-
-                if( ++next != t.end())
-                {
-                    os_ << ',';
-                }
-
-                new_line();
-            }
-
-            --indentation_level_;
-
-            indent(); os_ << end_char;
-        }
-        
-        void indent()
-        {
-            if( !pretty_ ) return;
-
-            for( int i = 0; i < indentation_level_; ++i )
-            { 
-                os_ << "    ";
-            }
-        }
-
-        void space()
-        {
-            if( pretty_ ) os_ << ' ';
-        }
-
-        void new_line()
-        {
-            if( pretty_ ) os_ << '\n';
-        }
-
-        Generator& operator=( const Generator& ); // to prevent "assignment operator could not be generated" warning
-
-        Ostream_type& os_;
-        int indentation_level_;
-        bool pretty_;
-    };
-
-    template< class Value_type, class Ostream_type >
-    void write_stream( const Value_type& value, Ostream_type& os, bool pretty )
-    {
-        Generator< Value_type, Ostream_type >( value, os, pretty );
-    }
-
-    template< class Value_type >
-    typename Value_type::String_type write_string( const Value_type& value, bool pretty )
-    {
-        typedef typename Value_type::String_type::value_type Char_type;
-
-        std::basic_ostringstream< Char_type > os;
-
-        write_stream( value, os, pretty );
-
-        return os.str();
-    }
-}
-
-#endif
diff -Naur bitcoin-0.3.20.orig/src/json/LICENSE.txt bitcoin-0.3.20/src/json/LICENSE.txt
--- bitcoin-0.3.20.orig/src/json/LICENSE.txt	2011-02-09 18:50:07.000000000 +0100
+++ bitcoin-0.3.20/src/json/LICENSE.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-The MIT License
-
-Copyright (c) 2007 - 2009 John W. Wilkinson
-
-Permission is hereby granted, free of charge, to any person
-obtaining a copy of this software and associated documentation
-files (the "Software"), to deal in the Software without
-restriction, including without limitation the rights to use,
-copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the
-Software is furnished to do so, subject to the following
-conditions:
-
-The above copyright notice and this permission notice shall be
-included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-OTHER DEALINGS IN THE SOFTWARE.
diff -Naur bitcoin-0.3.20.orig/src/makefile.unix bitcoin-0.3.20/src/makefile.unix
--- bitcoin-0.3.20.orig/src/makefile.unix	2011-02-18 17:20:19.000000000 +0100
+++ bitcoin-0.3.20/src/makefile.unix	2011-02-28 00:12:57.901600003 +0100
@@ -2,36 +2,40 @@
 # Distributed under the MIT/X11 software license, see the accompanying
 # file license.txt or http://www.opensource.org/licenses/mit-license.php.
 
+# Default prefix for make install
+ifeq ($(PREFIX),)
+PREFIX = /usr
+endif
 
 INCLUDEPATHS= \
- -I"/usr/local/include/wx-2.9" \
- -I"/usr/local/lib/wx/include/gtk2-unicode-debug-static-2.9"
+ -I"$(PREFIX)/usr/include" \
+ -I"$(PREFIX)/usr/include/wx-2.9" \
+ -I"$(PREFIX)/usr/lib/wx/include/gtk2-unicode-2.9"
 
-# for wxWidgets 2.9.1, add -l Xxf86vm
+# for wxWidgets 2.9.1, add -lXxf86vm
 WXLIBS= \
- -Wl,-Bstatic \
-   -l wx_gtk2ud-2.9 \
+ -L"$(PREFIX)/usr/lib" \
  -Wl,-Bdynamic \
-   -l gtk-x11-2.0 \
-   -l SM
+   -lwx_baseu-2.9 \
+   -lwx_gtk2u_core-2.9 \
+   -lwx_gtk2u_html-2.9 \
+   -lwx_gtk2u_adv-2.9
 
 # for boost 1.37, add -mt to the boost libraries
 LIBS= \
- -Wl,-Bstatic \
-   -l boost_system-mt \
-   -l boost_filesystem-mt \
-   -l boost_program_options-mt \
-   -l boost_thread-mt \
-   -l db_cxx \
-   -l ssl \
-   -l crypto \
+ -L"$(PREFIX)/lib" \
  -Wl,-Bdynamic \
-   -l gthread-2.0 \
-   -l z \
-   -l dl
+   -lpthread \
+   -lcrypto \
+   -lboost_program_options-mt \
+   -lboost_system-mt \
+   -lboost_thread-mt \
+   -lboost_filesystem-mt \
+   -ldb_cxx \
+   -lssl \
+   -lcryptopp
 
-DEFS=-D__WXGTK__ -DNOPCH -DFOURWAYSSE2 -DUSE_SSL
-DEBUGFLAGS=-g -D__WXDEBUG__
+DEFS=-D_FILE_OFFSET_BITS=64 -DWXUSINGDLL -D__WXGTK__ -DNOPCH -DFOURWAYSSE2 -DUSE_SSL
 CFLAGS=-O2 -Wno-invalid-offsetof -Wformat $(DEBUGFLAGS) $(DEFS) $(INCLUDEPATHS)
 HEADERS=headers.h strlcpy.h serialize.h uint256.h util.h key.h bignum.h base58.h \
     script.h db.h net.h irc.h main.h rpc.h uibase.h ui.h noui.h init.h
@@ -45,19 +49,12 @@
     obj/main.o \
     obj/rpc.o \
     obj/init.o \
-    cryptopp/obj/sha.o \
-    cryptopp/obj/cpu.o
-
 
 all: bitcoin
 
-
 obj/%.o: %.cpp $(HEADERS)
 	g++ -c $(CFLAGS) -DGUI -o $@ $<
 
-cryptopp/obj/%.o: cryptopp/%.cpp
-	g++ -c $(CFLAGS) -O3 -o $@ $<
-
 obj/sha256.o: sha256.cpp
 	g++ -c $(CFLAGS) -msse2 -O3 -march=amdfam10 -o $@ $<
 
diff -Naur bitcoin-0.3.20.orig/src/rpc.cpp bitcoin-0.3.20/src/rpc.cpp
--- bitcoin-0.3.20.orig/src/rpc.cpp	2011-02-18 17:20:01.000000000 +0100
+++ bitcoin-0.3.20/src/rpc.cpp	2011-02-28 00:13:47.111600003 +0100
@@ -12,9 +12,9 @@
 #include <boost/asio/ssl.hpp> 
 typedef boost::asio::ssl::stream<boost::asio::ip::tcp::socket> SSLStream;
 #endif
-#include "json/json_spirit_reader_template.h"
-#include "json/json_spirit_writer_template.h"
-#include "json/json_spirit_utils.h"
+#include <json_spirit_reader_template.h>
+#include <json_spirit_writer_template.h>
+#include <json_spirit_utils.h>
 #define printf OutputDebugStringF
 // MinGW 3.4.5 gets "fatal error: had to relocate PCH" if the json headers are
 // precompiled in headers.h.  The problem might be when the pch file goes over
